-- TweaksUI Unit Frames Module
-- Custom unit frame overlays with full control over appearance
-- Works WITH Blizzard's systems for targeting/menus, replaces visuals
-- v1.3.0 - Performance optimizations for raid frames

local ADDON_NAME, TweaksUI = ...

-- Forward declarations for variables used before their primary definition
local customFrames  -- Defined later, holds custom unit frames

-- Create the module
local UnitFrames = TweaksUI.ModuleManager:NewModule(
    TweaksUI.MODULE_IDS.UNIT_FRAMES,
    "Unit Frames",
    "Fully customizable unit frames for player, target, and more"
)

-- ============================================================================
-- EXTERNAL ADDON DETECTION
-- ============================================================================
-- Detect other addons that handle party/raid frames to avoid conflicts
-- When detected, we disable only the specific frame types they handle

-- Detection state (stores addon name if detected, nil otherwise)
local externalAddonDetected = {
    party = nil,    -- Name of addon handling party frames
    raid = nil,     -- Name of addon handling raid frames
}

-- List of addons that handle party/raid frames
-- Each entry: { addonName, handlesParty, handlesRaid }
-- Only addons CONFIRMED to be updated for Midnight (12.0)
local PARTY_RAID_ADDONS = {
    -- Format: { "AddonFolderName", handlesParty, handlesRaid }
    
    -- =========================================================================
    -- CONFIRMED UPDATED FOR MIDNIGHT 12.0
    -- =========================================================================
    { "DandersFrames", true, true },            -- Built specifically for Midnight
    { "Cell", true, true },                     -- Confirmed returning for Midnight (Icy Veins)
    { "Grid2", true, true },                    -- Developer confirmed on WowAce
    { "MidnightSimpleUnitFrames", true, true }, -- Built for Midnight 12.0
    
    -- =========================================================================
    -- NOTES:
    -- - Only addons with CONFIRMED Midnight 12.0 support are listed
    -- - SUF, VuhDo, HealBot, etc. are NOT confirmed to work yet
    -- - ElvUI is a full UI replacement and handles conflicts differently
    -- - Enhanced Raid Frames only ENHANCES Blizzard frames, doesn't replace
    -- - Detection only triggers if the addon is actually loaded
    -- =========================================================================
}

-- Helper function to check if an addon is loaded
local function IsAddonLoaded(addonName)
    if C_AddOns and C_AddOns.IsAddOnLoaded then
        return C_AddOns.IsAddOnLoaded(addonName)
    elseif IsAddOnLoaded then
        return IsAddOnLoaded(addonName)
    end
    return false
end

-- Check for external addons on module load
local function DetectExternalAddons()
    for _, addonInfo in ipairs(PARTY_RAID_ADDONS) do
        local addonName, handlesParty, handlesRaid = addonInfo[1], addonInfo[2], addonInfo[3]
        if IsAddonLoaded(addonName) then
            if handlesParty and not externalAddonDetected.party then
                externalAddonDetected.party = addonName
            end
            if handlesRaid and not externalAddonDetected.raid then
                externalAddonDetected.raid = addonName
            end
        end
    end
end

-- Public API to check if party frames should be disabled
function UnitFrames:IsPartyDisabledByExternalAddon()
    return externalAddonDetected.party ~= nil
end

-- Public API to check if raid frames should be disabled
function UnitFrames:IsRaidDisabledByExternalAddon()
    return externalAddonDetected.raid ~= nil
end

-- Public API to check if either party or raid frames should be disabled
function UnitFrames:IsPartyRaidDisabledByExternalAddon()
    return externalAddonDetected.party ~= nil or externalAddonDetected.raid ~= nil
end

-- Get the name of the addon that disabled party frames
function UnitFrames:GetExternalPartyAddon()
    return externalAddonDetected.party
end

-- Get the name of the addon that disabled raid frames
function UnitFrames:GetExternalRaidAddon()
    return externalAddonDetected.raid
end

-- Legacy API for backward compatibility
function UnitFrames:GetExternalPartyRaidAddon()
    return externalAddonDetected.party or externalAddonDetected.raid
end

-- ============================================================================
-- MIDNIGHT SECRET VALUE HANDLING & NEW API UTILITIES (Beta 4+)
-- ============================================================================

-- Safe value function for Midnight secret values
-- Uses issecretvalue() API to check if value is secret (if available)
-- Secret values can be DISPLAYED via string.format but NOT used for logic/arithmetic
local function SafeValue(value)
    if value == nil then return nil end
    
    -- Check if this is a secret value using Midnight API (if available)
    if issecretvalue then
        local ok, isSecret = pcall(issecretvalue, value)
        if ok and isSecret then
            -- Secret values can't be used for comparisons/logic
            return nil
        end
    end
    
    -- Not a secret (or API not available), return the value
    return value
end

-- Safe number function - specifically for values that need arithmetic
-- Returns nil if value is secret or can't be used for math
local function SafeNumber(value)
    if value == nil then return nil end
    
    -- Check if this is a secret value (if API available)
    if issecretvalue then
        local ok, isSecret = pcall(issecretvalue, value)
        if ok and isSecret then
            return nil
        end
    end
    
    -- Verify it's actually a number we can do math on
    local ok, result = pcall(function()
        return value + 0
    end)
    
    if ok then
        return result
    else
        return nil
    end
end

-- ============================================================================
-- MIDNIGHT API FLAGS (v2.0.0 - Midnight-only)
-- ============================================================================
-- All API checks are simplified for Midnight (12.0+) - no TWW fallbacks needed
-- Consolidated into single table to reduce local count (Lua 200 local limit)

local API = {
    -- Midnight native smooth bar interpolation
    BAR_INTERPOLATION = Enum.StatusBarInterpolation.ExponentialEaseOut,
    -- Midnight API features (all available in 12.0+)
    HAS_MIDNIGHT_APIS = true,
    HAS_HEALTH_MISSING = true,
    HAS_AURA_SORTING = true,
    HAS_SET_ALPHA_BOOL = true,
    HAS_DISPEL_COLOR_API = true,
    HAS_AURA_DURATION_API = true,
    HAS_TIMER_BARS = true,
    -- Color curve API for secret booleans (PTR 1+)
    HAS_COLOR_FROM_BOOLEAN = (C_CurveUtil and C_CurveUtil.EvaluateColorFromBoolean ~= nil),
    -- Duration Object APIs (Midnight Beta 4+)
    HAS_DURATION_OBJECTS = true,
    HAS_AURA_DURATION_OBJECT = true,
    -- Cast duration object APIs
    HAS_CAST_DURATION = UnitCastingDuration ~= nil,
    HAS_CHANNEL_DURATION = UnitChannelDuration ~= nil,
}

-- Shorthand references for frequently used values
local BAR_INTERPOLATION = API.BAR_INTERPOLATION
local HAS_TIMER_BARS = API.HAS_TIMER_BARS
local HAS_COLOR_FROM_BOOLEAN = API.HAS_COLOR_FROM_BOOLEAN

-- ============================================================================
-- SECRET BOOLEAN COLOR HANDLING (v2.1.5)
-- ============================================================================
-- For notInterruptible which may be secret on non-player casts

-- Color curve for notInterruptible handling (created on demand)
local uninterruptibleColorCurve = nil
local function GetUninterruptibleColorCurve()
    if uninterruptibleColorCurve then return uninterruptibleColorCurve end
    
    -- Create a color curve: true = grey (uninterruptible), false = white (apply base color)
    -- Midnight uses C_CurveUtil.CreateColorCurve(), not a global CreateColorCurve
    if C_CurveUtil and C_CurveUtil.CreateColorCurve then
        uninterruptibleColorCurve = C_CurveUtil.CreateColorCurve()
        -- AddPoint takes (position, ColorMixin)
        -- 0.0 (false) = white (1,1,1) - means "use normal color"
        -- 1.0 (true) = grey (0.7,0.7,0.7) - uninterruptible
        uninterruptibleColorCurve:AddPoint(0, CreateColor(1, 1, 1, 1))
        uninterruptibleColorCurve:AddPoint(1, CreateColor(0.7, 0.7, 0.7, 1))
    end
    return uninterruptibleColorCurve
end

-- Apply cast bar color with proper notInterruptible handling
-- Works with both readable and secret boolean values
-- Uses SetVertexColorFromBoolean for secret values (Midnight API)
local function ApplyCastBarColor(statusBar, notInterruptible, baseR, baseG, baseB, isPlayerUnit)
    -- For player casts, notInterruptible is never secret - use direct approach
    if isPlayerUnit then
        local isUninterruptible = false
        pcall(function()
            if notInterruptible then
                isUninterruptible = true
            end
        end)
        
        if isUninterruptible then
            statusBar:SetStatusBarColor(0.7, 0.7, 0.7, 1)  -- Grey
        else
            statusBar:SetStatusBarColor(baseR, baseG, baseB, 1)
        end
        return isUninterruptible
    end
    
    -- For non-player units, notInterruptible might be secret in Midnight
    -- Check if it's a secret value first
    local isSecret = false
    if issecretvalue then
        local ok, result = pcall(issecretvalue, notInterruptible)
        if ok then
            isSecret = result
        end
    end
    
    -- If it's a secret value, use SetVertexColorFromBoolean (Midnight API)
    if isSecret then
        local tex = statusBar:GetStatusBarTexture()
        if tex and tex.SetVertexColorFromBoolean then
            local normalColor = CreateColor(baseR, baseG, baseB, 1)
            local greyColor = CreateColor(0.7, 0.7, 0.7, 1)
            -- notInterruptible = true means use grey, false means use normal color
            tex:SetVertexColorFromBoolean(notInterruptible, greyColor, normalColor)
            return false  -- Can't know for sure, return default
        else
            -- Fallback - just use base color since we can't determine
            statusBar:SetStatusBarColor(baseR, baseG, baseB, 1)
            return false
        end
    end
    
    -- Not a secret value - try direct read
    local isUninterruptible = false
    local couldRead = pcall(function()
        if notInterruptible then
            isUninterruptible = true
        end
    end)
    
    if couldRead then
        -- Value was readable
        if isUninterruptible then
            statusBar:SetStatusBarColor(0.7, 0.7, 0.7, 1)
        else
            statusBar:SetStatusBarColor(baseR, baseG, baseB, 1)
        end
        return isUninterruptible
    end
    
    -- Fallback: can't determine, use base color
    statusBar:SetStatusBarColor(baseR, baseG, baseB, 1)
    return false
end

-- Midnight Beta uses "secret values" for health/power that prevent addons from doing arithmetic.
-- Until Blizzard provides a working percentage API, we display "?" for percentage formats.

-- Safe health percent function for Midnight Beta
-- Uses CurveConstants.ScaleTo100 curve to get 0-100 scaled value
local function SafeUnitHealthPercent(unit, usePredicted)
    if type(UnitHealthPercent) == "function" then
        local ok, pct
        
        -- Try with CurveConstants.ScaleTo100 first (correct Midnight API)
        -- This should return a non-secret 0-100 value
        if CurveConstants and CurveConstants.ScaleTo100 then
            ok, pct = pcall(UnitHealthPercent, unit, usePredicted, CurveConstants.ScaleTo100)
            if ok and pct ~= nil then
                return pct
            end
        end
        
        -- Fallback: try with true (older API)
        ok, pct = pcall(UnitHealthPercent, unit, usePredicted, true)
        if ok and pct ~= nil then
            return pct
        end
        
        -- Last resort: bare call (returns 0-1, need to scale)
        -- Wrap multiplication in pcall in case pct is a secret value
        ok, pct = pcall(UnitHealthPercent, unit, usePredicted)
        if ok and pct ~= nil then
            local scaleOk, scaled = pcall(function() return pct * 100 end)
            if scaleOk then
                return scaled
            end
        end
    end
    
    -- Fallback: calculate from health/maxHealth
    if UnitHealth and UnitHealthMax then
        local cur = UnitHealth(unit)
        local max = UnitHealthMax(unit)
        local success, result = pcall(function()
            if cur and max and max > 0 then
                return (cur / max) * 100
            end
            return 0
        end)
        if success then return result end
    end
    
    return nil
end

-- Safe health text formatter for Midnight Beta
-- Uses multiple approaches to get health percentage:
-- 1. ScaleTo100 curve (if available)
-- 2. UnitHealthPercent with true for scaleTo100 (old API)
-- 3. StatusBar decoder trick
-- 4. Raw 0-1 format (shows 0% or 1%)
local function FormatHealthTextMidnight(unit, format, health, maxHealth)
    if format == "percent" then
        local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
        if pct then
            return string.format("%.0f%%", pct)
        end
        return "?%"
        
    elseif format == "current" then
        -- AbbreviateLargeNumbers accepts secrets and returns secret strings
        if AbbreviateLargeNumbers then
            return AbbreviateLargeNumbers(health)
        elseif AbbreviateNumber then
            return AbbreviateNumber(health)
        end
        return tostring(health or 0)
        
    elseif format == "deficit" then
        -- UnitHealthMissing returns the missing health as a secret value
        if UnitHealthMissing then
            local missing = UnitHealthMissing(unit)
            if AbbreviateLargeNumbers then
                local missingStr = AbbreviateLargeNumbers(missing)
                -- C_StringUtil.WrapString can wrap secret strings
                if C_StringUtil and C_StringUtil.WrapString then
                    return C_StringUtil.WrapString(missingStr, "-", "")
                end
                -- string.format with %s accepts secret strings
                return string.format("-%s", missingStr)
            end
        end
        -- Fallback for non-Midnight
        local success, result = pcall(function()
            local deficit = (maxHealth or 0) - (health or 0)
            if deficit > 0 then
                return "-" .. (AbbreviateNumber and AbbreviateNumber(deficit) or tostring(deficit))
            end
            return ""
        end)
        return success and result or ""
        
    elseif format == "deficit_percent" then
        local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
        if pct and pct < 100 then
            return string.format("-%.0f%%", 100 - pct)
        end
        return ""
    end
    return ""
end

-- Create health gradient color curve for Midnight (if available)
local healthGradientCurve = nil
local function GetOrCreateHealthGradientCurve()
    if healthGradientCurve then return healthGradientCurve end
    
    -- Midnight uses C_CurveUtil.CreateColorCurve(), not a global CreateColorCurve
    if C_CurveUtil and C_CurveUtil.CreateColorCurve then
        healthGradientCurve = C_CurveUtil.CreateColorCurve()
        -- AddPoint takes (position, ColorMixin)
        healthGradientCurve:AddPoint(0, CreateColor(1, 0, 0, 1))      -- Red at 0%
        healthGradientCurve:AddPoint(0.5, CreateColor(1, 1, 0, 1))    -- Yellow at 50%
        healthGradientCurve:AddPoint(1, CreateColor(0, 1, 0, 1))      -- Green at 100%
        return healthGradientCurve
    end
    return nil
end

-- ============================================================================
-- DISPEL UTILITIES (Consolidated to reduce local variable count)
-- Midnight-only: Uses curve API for all dispel type handling
-- Secret values cannot be compared - must pass through curves
-- ============================================================================

local DispelUtils = {}

-- Dispel type colors (more vibrant)
DispelUtils.COLORS = {
    Magic = { r = 0.3, g = 0.7, b = 1.0 },    -- Blue (more vibrant)
    Curse = { r = 0.7, g = 0.2, b = 1.0 },    -- Purple (more vibrant)
    Disease = { r = 0.8, g = 0.5, b = 0.1 },  -- Brown/Orange (more vibrant)
    Poison = { r = 0.2, g = 0.8, b = 0.2 },   -- Green (more vibrant)
    Bleed = { r = 1.0, g = 0.2, b = 0.2 },    -- Red
    [""] = { r = 1.0, g = 0.2, b = 0.2 },     -- Red (enrage/none)
}

-- Numeric dispel type to name mapping
DispelUtils.TYPE_TO_NAME = {
    [1] = "Magic",
    [2] = "Curse",
    [3] = "Disease",
    [4] = "Poison",
    [11] = "Bleed",
}

-- Dispel type enum values (for curve creation only, not comparison)
DispelUtils.ENUM = {
    None = 0, Magic = 1, Curse = 2, Disease = 3, Poison = 4, Enrage = 9, Bleed = 11,
}

-- Cache for curves
DispelUtils.colorCurve = nil
DispelUtils.detectionCurves = {}
DispelUtils.initialized = false

-- Create the main dispel color curve
function DispelUtils:CreateColorCurve()
    if not C_CurveUtil or not C_CurveUtil.CreateColorCurve then return nil end
    
    local curve = C_CurveUtil.CreateColorCurve()
    curve:SetType(Enum.LuaCurveType.Step)
    
    -- Dispel type enum values: 0=None, 1=Magic, 2=Curse, 3=Disease, 4=Poison, 9=Enrage, 11=Bleed
    curve:AddPoint(0, CreateColor(0.8, 0.0, 0.0, 0))   -- None - no color (alpha=0)
    curve:AddPoint(1, CreateColor(0.3, 0.7, 1.0, 1))   -- Magic - Blue
    curve:AddPoint(2, CreateColor(0.7, 0.2, 1.0, 1))   -- Curse - Purple
    curve:AddPoint(3, CreateColor(0.8, 0.5, 0.1, 1))   -- Disease - Brown
    curve:AddPoint(4, CreateColor(0.2, 0.8, 0.2, 1))   -- Poison - Green
    curve:AddPoint(9, CreateColor(0.8, 0.0, 0.0, 0))   -- Enrage - no color (alpha=0)
    curve:AddPoint(11, CreateColor(1.0, 0.2, 0.2, 1))  -- Bleed - Red
    
    return curve
end

-- Player dispel types by class
DispelUtils.playerDispelTypes = {}

function DispelUtils:UpdatePlayerDispelTypes()
    wipe(self.playerDispelTypes)
    
    local _, playerClass = UnitClass("player")
    
    if playerClass == "PRIEST" then
        self.playerDispelTypes.Magic = true
        self.playerDispelTypes.Disease = true
    elseif playerClass == "PALADIN" then
        self.playerDispelTypes.Magic = true
        self.playerDispelTypes.Poison = true
        self.playerDispelTypes.Disease = true
    elseif playerClass == "SHAMAN" then
        self.playerDispelTypes.Magic = true
        self.playerDispelTypes.Curse = true
    elseif playerClass == "DRUID" then
        self.playerDispelTypes.Magic = true
        self.playerDispelTypes.Curse = true
        self.playerDispelTypes.Poison = true
    elseif playerClass == "MAGE" then
        self.playerDispelTypes.Curse = true
    elseif playerClass == "MONK" then
        self.playerDispelTypes.Magic = true
        self.playerDispelTypes.Poison = true
        self.playerDispelTypes.Disease = true
    elseif playerClass == "EVOKER" then
        self.playerDispelTypes.Magic = true
        self.playerDispelTypes.Poison = true
    elseif playerClass == "WARLOCK" then
        self.playerDispelTypes.Magic = true
    end
    -- DK, DH, Hunter, Rogue, Warrior have no dispels
    
    -- Invalidate filtered curve so it gets rebuilt
    self.playerFilteredCurve = nil
end

-- Create a color curve that only shows types the player can dispel
function DispelUtils:CreatePlayerFilteredCurve()
    if not C_CurveUtil or not C_CurveUtil.CreateColorCurve then return nil end
    
    -- Ensure player dispel types are up to date
    if not next(self.playerDispelTypes) then
        self:UpdatePlayerDispelTypes()
    end
    
    local curve = C_CurveUtil.CreateColorCurve()
    curve:SetType(Enum.LuaCurveType.Step)
    
    -- Dispel type enum to name mapping
    local enumToName = {
        [1] = "Magic",
        [2] = "Curse", 
        [3] = "Disease",
        [4] = "Poison",
        [11] = "Bleed",
    }
    
    -- Dispel type enum values: 0=None, 1=Magic, 2=Curse, 3=Disease, 4=Poison, 9=Enrage, 11=Bleed
    curve:AddPoint(0, CreateColor(0.8, 0.0, 0.0, 0))   -- None - no color
    
    -- Only add colors for types player can dispel
    if self.playerDispelTypes.Magic then
        curve:AddPoint(1, CreateColor(0.3, 0.7, 1.0, 1))   -- Magic - Blue
    else
        curve:AddPoint(1, CreateColor(0, 0, 0, 0))
    end
    
    if self.playerDispelTypes.Curse then
        curve:AddPoint(2, CreateColor(0.7, 0.2, 1.0, 1))   -- Curse - Purple
    else
        curve:AddPoint(2, CreateColor(0, 0, 0, 0))
    end
    
    if self.playerDispelTypes.Disease then
        curve:AddPoint(3, CreateColor(0.8, 0.5, 0.1, 1))   -- Disease - Brown
    else
        curve:AddPoint(3, CreateColor(0, 0, 0, 0))
    end
    
    if self.playerDispelTypes.Poison then
        curve:AddPoint(4, CreateColor(0.2, 0.8, 0.2, 1))   -- Poison - Green
    else
        curve:AddPoint(4, CreateColor(0, 0, 0, 0))
    end
    
    curve:AddPoint(9, CreateColor(0, 0, 0, 0))   -- Enrage - never shown
    
    -- Bleed is special - no class can dispel it, but option to show
    curve:AddPoint(11, CreateColor(0, 0, 0, 0))  -- Bleed - hidden by default in filtered
    
    return curve
end

-- Get player-filtered curve, creating if needed
function DispelUtils:GetPlayerFilteredCurve()
    if not self.playerFilteredCurve then
        self.playerFilteredCurve = self:CreatePlayerFilteredCurve()
    end
    return self.playerFilteredCurve
end

-- Create a detection curve for a specific dispel type
-- Returns alpha=1 for matching type, alpha=0 for non-matching
function DispelUtils:CreateDetectionCurve(targetType)
    if not C_CurveUtil or not C_CurveUtil.CreateColorCurve then return nil end
    
    local curve = C_CurveUtil.CreateColorCurve()
    curve:SetType(Enum.LuaCurveType.Step)
    
    -- All known dispel type values
    local allTypes = {0, 1, 2, 3, 4, 9, 11}
    for _, typeVal in ipairs(allTypes) do
        if typeVal == targetType then
            curve:AddPoint(typeVal, CreateColor(1, 1, 1, 1))  -- Match: alpha=1
        else
            curve:AddPoint(typeVal, CreateColor(0, 0, 0, 0))  -- No match: alpha=0
        end
    end
    
    return curve
end

-- Lazy initialization - called on first use
function DispelUtils:EnsureInitialized()
    if self.initialized then return end
    if not HAS_DISPEL_COLOR_API then return end
    
    self.colorCurve = self:CreateColorCurve()
    self.detectionCurves.Magic = self:CreateDetectionCurve(1)
    self.detectionCurves.Curse = self:CreateDetectionCurve(2)
    self.detectionCurves.Disease = self:CreateDetectionCurve(3)
    self.detectionCurves.Poison = self:CreateDetectionCurve(4)
    self.detectionCurves.Bleed = self:CreateDetectionCurve(11)
    self.initialized = true
end

-- Get color curve, initializing if needed
function DispelUtils:GetColorCurve()
    self:EnsureInitialized()
    return self.colorCurve
end

-- Get detection curve, initializing if needed
function DispelUtils:GetDetectionCurve(dispelTypeName)
    self:EnsureInitialized()
    return self.detectionCurves[dispelTypeName]
end

-- IMPORTANT: In Midnight, ALL values from curves are SECRET
-- We cannot do ANY comparison or arithmetic on them
-- We can ONLY pass them directly to UI functions

-- Get dispel color from aura using curve API
-- Returns the color object directly for passing to SetVertexColor
function DispelUtils:GetColorFromAura(unit, auraData)
    if not auraData then return nil end
    if not auraData.auraInstanceID then return nil end
    if not C_UnitAuras or not C_UnitAuras.GetAuraDispelTypeColor then return nil end
    
    local curve = self:GetColorCurve()
    if not curve then return nil end
    
    -- Returns color object - caller must pass directly to SetVertexColor
    return C_UnitAuras.GetAuraDispelTypeColor(unit, auraData.auraInstanceID, curve)
end

-- Apply dispel color directly to a texture (no extraction, no comparison)
function DispelUtils:ApplyColorToTexture(texture, unit, auraData)
    if not texture then return false end
    local color = self:GetColorFromAura(unit, auraData)
    if not color then return false end
    
    -- Pass color object directly - handles secret values
    pcall(function()
        local r, g, b, a = color:GetRGBA()
        texture:SetVertexColor(r, g, b, a)
    end)
    return true
end

-- Apply detection curve alpha to indicator (for type-specific indicators)
-- This makes the indicator visible (alpha=1) only if it matches the type
function DispelUtils:ApplyTypeAlphaToIndicator(indicator, unit, auraData, dispelTypeName)
    if not indicator then return false end
    if not auraData or not auraData.auraInstanceID then return false end
    if not C_UnitAuras or not C_UnitAuras.GetAuraDispelTypeColor then return false end
    
    local curve = self:GetDetectionCurve(dispelTypeName)
    if not curve then return false end
    
    local color = C_UnitAuras.GetAuraDispelTypeColor(unit, auraData.auraInstanceID, curve)
    if not color then return false end
    
    -- Pass alpha directly to SetAlpha - no comparison needed
    -- If type matches: alpha=1 (visible), if not: alpha=0 (invisible)
    pcall(function()
        local _, _, _, a = color:GetRGBA()
        indicator:SetAlpha(a)
    end)
    return true
end

-- Check if ANY dispellable debuff exists on unit (for showing/hiding container)
-- Returns true if color curve returns any color with alpha > 0
-- NOTE: This still requires comparison, so may not work in all contexts
function DispelUtils:UnitHasDispellableDebuff(unit)
    if not C_UnitAuras or not C_UnitAuras.GetUnitAuras then return false end
    
    local auras = C_UnitAuras.GetUnitAuras(unit, "HARMFUL")
    if not auras then return false end
    
    local curve = self:GetColorCurve()
    if not curve then return false end
    
    for _, aura in ipairs(auras) do
        if aura.auraInstanceID then
            local color = C_UnitAuras.GetAuraDispelTypeColor(unit, aura.auraInstanceID, curve)
            if color then
                -- Try to check alpha - may fail if secret
                local hasDispel = false
                pcall(function()
                    local _, _, _, a = color:GetRGBA()
                    if a and a > 0 then
                        hasDispel = true
                    end
                end)
                if hasDispel then return true end
            end
        end
    end
    return false
end

-- These functions are DEPRECATED in Midnight - they require comparison
-- Kept for backwards compatibility but will return nil/false when values are secret
function DispelUtils:AuraHasType(unit, auraData, dispelTypeName)
    -- Cannot determine type without comparison - always returns false in Midnight
    return false
end

function DispelUtils:GetTypeName(unit, auraData)
    -- Cannot determine type name without comparison - always returns nil in Midnight
    return nil
end

-- ============================================================================
-- EMPOWERED CAST BAR HELPERS
-- Stage position calculations for empowered spells (Evoker, etc.)
-- ============================================================================

local MAX_EMPOWER_STAGES = 6
local HAS_EMPOWER_STAGE_PERCENTAGES = (UnitEmpoweredStagePercentages ~= nil)

-- Get the number of empower stages from UnitChannelInfo or UnitEmpoweredStagePercentages
-- Returns numStages (always returns a valid number 2-6, or nil if not empowered)
local function GetEmpowerNumStages(unit)
    if not unit then return nil end
    
    local numStages = nil
    
    -- Method 1: Try UnitEmpoweredStagePercentages first (most reliable)
    if HAS_EMPOWER_STAGE_PERCENTAGES then
        local success, percentages = pcall(function()
            return UnitEmpoweredStagePercentages(unit, true)  -- include hold-at-max
        end)
        
        if success and percentages and type(percentages) == "table" and #percentages > 1 then
            -- Count minus 1 (for hold-at-max) gives number of stages
            local count = #percentages - 1
            if count >= 2 and count <= MAX_EMPOWER_STAGES then
                numStages = count
            end
        end
    end
    
    -- Method 2: Try to get from UnitChannelInfo return values
    -- UnitChannelInfo returns: name, text, texture, startTimeMS, endTimeMS, isTradeSkill, notInterruptible, spellID, isEmpowered, numStages
    -- Position 10 is numStages (1-indexed)
    if not numStages then
        local success, results = pcall(function()
            return {UnitChannelInfo(unit)}
        end)
        
        if success and results and #results >= 10 then
            local apiStages = results[10]
            if apiStages then
                local safeStages = SafeNumber(apiStages)
                if safeStages and type(safeStages) == "number" and safeStages >= 2 and safeStages <= MAX_EMPOWER_STAGES then
                    numStages = safeStages
                end
            end
        end
    end
    
    return numStages
end

-- Check if a unit is currently casting an empowered spell
local function IsEmpoweredCast(unit)
    if not unit then return false end
    
    -- Method 1: Check UnitEmpoweredStagePercentages - if it returns data, it's empowered
    if HAS_EMPOWER_STAGE_PERCENTAGES then
        local success, percentages = pcall(function()
            return UnitEmpoweredStagePercentages(unit, true)
        end)
        if success and percentages and type(percentages) == "table" and #percentages > 1 then
            return true
        end
    end
    
    -- Method 2: Check UnitChannelInfo isEmpowered flag
    -- UnitChannelInfo returns: name, text, texture, startTimeMS, endTimeMS, isTradeSkill, notInterruptible, spellID, isEmpowered, numStages
    -- Position 9 is isEmpowered (1-indexed)
    local success, results = pcall(function()
        return {UnitChannelInfo(unit)}
    end)
    if success and results then
        -- Check position 9 for isEmpowered flag
        local isEmpoweredFlag = results[9]
        if isEmpoweredFlag then
            -- Try to evaluate if it's a secret boolean
            local ok, val = pcall(function() return isEmpoweredFlag and true or false end)
            if ok and val then
                return true
            end
        end
    end
    
    return false
end

-- Get stage percentages for empowered spells (cumulative positions 0-1)
-- Uses UnitEmpoweredStagePercentages API or hardcoded fallback
-- Returns: table of cumulative percentages where each stage ENDS (divider positions)
local function GetEmpowerStagePositions(numStages, unit)
    -- Method 1: Use UnitEmpoweredStagePercentages API if available
    if HAS_EMPOWER_STAGE_PERCENTAGES and unit then
        local success, percentages = pcall(function()
            -- MUST include hold-at-max to get positions relative to the FULL bar
            return UnitEmpoweredStagePercentages(unit, true)
        end)
        
        if success and percentages and type(percentages) == "table" and #percentages >= numStages then
            -- Convert individual stage percentages to cumulative positions
            local positions = {}
            local cumulative = 0
            for i = 1, numStages do
                cumulative = cumulative + (percentages[i] or 0)
                positions[i] = cumulative
            end
            return positions
        end
    end
    
    -- Method 2: Hardcoded fallback positions (account for ~35% hold-at-max time)
    if numStages == 6 then
        return {0.10, 0.22, 0.34, 0.46, 0.58, 0.70}
    elseif numStages == 5 then
        return {0.12, 0.26, 0.40, 0.54, 0.68}
    elseif numStages == 4 then
        return {0.15, 0.32, 0.49, 0.66}
    elseif numStages == 3 then
        return {0.20, 0.40, 0.60}
    elseif numStages == 2 then
        return {0.30, 0.60}
    else
        -- Fallback: distribute in first 70% of bar
        local positions = {}
        local usableRange = 0.70
        for i = 1, numStages do
            positions[i] = (i / numStages) * usableRange
        end
        return positions
    end
end

-- Calculate current empower stage based on progress
-- Returns: 0 = charging, 1-N = completed that stage
local function GetCurrentEmpowerStage(progress, stagePositions, numStages)
    if not progress or not stagePositions or not numStages then return 0 end
    if progress <= 0 then return 0 end
    if progress >= 1 then return numStages end
    
    if progress < stagePositions[1] then
        return 0
    end
    
    local currentStage = 1
    for i = 2, #stagePositions do
        if progress >= stagePositions[i] then
            currentStage = i
        else
            break
        end
    end
    
    return currentStage
end

-- Setup empowered stage dividers on a cast bar
local function SetupEmpowerDividers(castBar, unit, numStages)
    if not castBar then return end
    
    if not numStages or numStages <= 1 then
        -- Hide all dividers
        if castBar.stageDividers then
            for i = 1, MAX_EMPOWER_STAGES do
                if castBar.stageDividers[i] then
                    castBar.stageDividers[i]:Hide()
                end
            end
        end
        castBar.empowerDividersSetup = false
        return
    end
    
    -- Create dividers if needed
    if not castBar.stageDividers then
        castBar.stageDividers = {}
        for i = 1, MAX_EMPOWER_STAGES do
            local divider = castBar:CreateTexture(nil, "OVERLAY", nil, 7)
            divider:SetColorTexture(1, 1, 1, 0.8)
            divider:Hide()
            castBar.stageDividers[i] = divider
        end
    end
    
    -- Hide all dividers first
    for i = 1, MAX_EMPOWER_STAGES do
        if castBar.stageDividers[i] then
            castBar.stageDividers[i]:Hide()
        end
    end
    
    -- Get stage positions
    local positions = GetEmpowerStagePositions(numStages, unit)
    if not positions or #positions == 0 then
        castBar.empowerDividersSetup = false
        return
    end
    
    castBar.stagePositions = positions
    castBar.numEmpowerStages = numStages
    
    -- Get bar dimensions - use GetRight/GetLeft for two-point anchored frames
    local barWidth = 0
    local barHeight = castBar:GetHeight()
    
    -- Try GetRight/GetLeft first (works for two-point anchored frames)
    local left, right = castBar:GetLeft(), castBar:GetRight()
    if left and right and right > left then
        barWidth = right - left
    end
    
    -- Fallback to GetWidth
    if barWidth <= 0 then
        barWidth = castBar:GetWidth()
    end
    
    -- Final fallback - get from parent frame
    if barWidth <= 0 then
        local parent = castBar:GetParent()
        if parent then
            local pLeft, pRight = parent:GetLeft(), parent:GetRight()
            if pLeft and pRight and pRight > pLeft then
                barWidth = pRight - pLeft - 10  -- Subtract some padding
            else
                barWidth = parent:GetWidth() - 10
            end
        end
    end
    
    -- Last resort fallback
    if barWidth <= 0 then barWidth = 150 end
    if barHeight <= 0 then barHeight = 12 end
    
    local dividerWidth = 2
    local dividerHeight = barHeight
    
    -- Position dividers at stage completion points
    for i = 1, numStages do
        local divider = castBar.stageDividers[i]
        if divider and positions[i] then
            local xPos = positions[i] * barWidth
            divider:ClearAllPoints()
            divider:SetPoint("CENTER", castBar, "LEFT", xPos, 0)
            divider:SetSize(dividerWidth, dividerHeight)
            divider:SetColorTexture(1, 1, 1, 0.9)
            divider:SetDrawLayer("OVERLAY", 7)
            divider:Show()
        end
    end
    
    -- Mark that dividers are set up for this cast
    castBar.empowerDividersSetup = true
end

-- Hide empowered dividers
local function HideEmpowerDividers(castBar)
    if castBar and castBar.stageDividers then
        for i = 1, MAX_EMPOWER_STAGES do
            if castBar.stageDividers[i] then
                castBar.stageDividers[i]:Hide()
            end
        end
    end
    if castBar then
        castBar.stagePositions = nil
        castBar.numEmpowerStages = nil
        castBar.empowerDividersSetup = false
    end
end

-- ============================================================================
-- DISPEL BOX HELPER (Midnight-compatible)
-- Creates colored boxes for dispellable debuffs using curve API
-- ============================================================================

local function UpdateDispelBoxes(frame, unit, size, maxBoxes, onlyPlayerDispellable)
    if not frame then return end
    if not C_UnitAuras or not C_UnitAuras.GetUnitAuras or not C_UnitAuras.GetAuraDispelTypeColor then return end
    
    maxBoxes = maxBoxes or 5
    size = size or 12
    
    -- Create box pool if needed
    if not frame.dispelBoxes then
        frame.dispelBoxes = {}
    end
    
    -- Hide all existing boxes first
    for _, box in ipairs(frame.dispelBoxes) do
        box:Hide()
    end
    
    if not UnitExists(unit) then return end
    
    -- Choose curve based on filter setting
    local colorCurve
    if onlyPlayerDispellable then
        colorCurve = DispelUtils:GetPlayerFilteredCurve()
    else
        colorCurve = DispelUtils:GetColorCurve()
    end
    if not colorCurve then return end
    
    local auras = C_UnitAuras.GetUnitAuras(unit, "HARMFUL")
    if not auras then return end
    
    -- First pass: count dispellable debuffs
    local dispellableCount = 0
    local dispellableAuras = {}
    for _, aura in ipairs(auras) do
        if aura.auraInstanceID and dispellableCount < maxBoxes then
            local color = C_UnitAuras.GetAuraDispelTypeColor(unit, aura.auraInstanceID, colorCurve)
            if color then
                dispellableCount = dispellableCount + 1
                dispellableAuras[dispellableCount] = { aura = aura, color = color }
            end
        end
    end
    
    if dispellableCount == 0 then return end
    
    -- Get or create parent container
    local parent = frame.debuffContainer or frame
    
    -- Position boxes - first box always at RIGHT, additional boxes extend left
    for i, data in ipairs(dispellableAuras) do
        local box = frame.dispelBoxes[i]
        if not box then
            box = CreateFrame("Frame", nil, parent, "BackdropTemplate")
            box:SetBackdrop({
                bgFile = "Interface\\BUTTONS\\WHITE8X8",
                edgeFile = "Interface\\BUTTONS\\WHITE8X8",
                edgeSize = 1,
            })
            box.tex = box:CreateTexture(nil, "ARTWORK")
            box.tex:SetAllPoints()
            box.tex:SetColorTexture(1, 1, 1, 1)
            frame.dispelBoxes[i] = box
        end
        
        box:SetSize(size, size)
        box:ClearAllPoints()
        
        -- First box at RIGHT, additional boxes to its left
        local xOffset = (i - 1) * (size + 2)
        box:SetPoint("RIGHT", parent, "RIGHT", -xOffset, 0)
        
        -- Apply color from curve
        pcall(function()
            local r, g, b, a = data.color:GetRGBA()
            box.tex:SetVertexColor(r, g, b)
            box:SetBackdropBorderColor(0, 0, 0, a)
            box:SetAlpha(a)
        end)
        
        box:Show()
    end
end

-- Export helper
TweaksUI.UpdateDispelBoxes = UpdateDispelBoxes

-- Legacy function for backwards compatibility (non-secret values only)
function DispelUtils:GetColor(dispelTypeOrName)
    local r, g, b = 0.8, 0, 0
    if type(dispelTypeOrName) == "number" then
        local name = self.TYPE_TO_NAME[dispelTypeOrName]
        if name and self.COLORS[name] then
            local c = self.COLORS[name]
            r, g, b = c.r, c.g, c.b
        end
    elseif type(dispelTypeOrName) == "string" and self.COLORS[dispelTypeOrName] then
        local c = self.COLORS[dispelTypeOrName]
        r, g, b = c.r, c.g, c.b
    end
    return r, g, b
end

-- Scan auras and populate debuffsFound table (Midnight-safe)
local function ScanDispellableDebuffs(unit, debuffsFound)
    if not UnitExists(unit) then return end
    if not C_UnitAuras or not C_UnitAuras.GetUnitAuras then return end
    
    local sortRule = Enum.UnitAuraSortRule and Enum.UnitAuraSortRule.Expiration or nil
    local auras = C_UnitAuras.GetUnitAuras(unit, "HARMFUL", nil, sortRule)
    
    if auras then
        for _, aura in ipairs(auras) do
            local dispelType = DispelUtils:GetTypeName(unit, aura)
            if dispelType then
                debuffsFound[dispelType] = true
            end
        end
    end
end

-- Debug command to inspect aura structure: /tuidebugauras
-- Debug slash command for individual frame range fade
SLASH_TUIRANGEINDIV1 = "/tuirangeindiv"
SlashCmdList["TUIRANGEINDIV"] = function(msg)
    local args = {}
    for arg in msg:gmatch("%S+") do
        table.insert(args, arg:lower())
    end
    
    local cmd = args[1] or "status"
    
    if cmd == "on" then
        if settings and settings.general then
            if not settings.general.rangeFade then
                settings.general.rangeFade = { enabled = true, outOfRangeAlpha = 0.4, perElementFade = false }
            else
                settings.general.rangeFade.enabled = true
            end
            IndividualRangeFade:Start()
            print("|cff00ff00TweaksUI:|r Individual frame range fade ENABLED")
        else
            print("|cffff0000TweaksUI:|r Settings not initialized")
        end
    elseif cmd == "off" then
        if settings and settings.general and settings.general.rangeFade then
            settings.general.rangeFade.enabled = false
            IndividualRangeFade:Stop()
            print("|cff00ff00TweaksUI:|r Individual frame range fade DISABLED")
        end
    elseif cmd == "status" then
        print("|cff00ccffTweaksUI Individual Frame Range Fade:|r")
        print("  Ticker active: " .. tostring(Tickers.individualRange ~= nil))
        if settings and settings.general and settings.general.rangeFade then
            local rf = settings.general.rangeFade
            print("  Enabled: " .. tostring(rf.enabled))
            print("  Out of range alpha: " .. tostring(rf.outOfRangeAlpha or 0.4))
            print("  Per-element fade: " .. tostring(rf.perElementFade or false))
        else
            print("  Settings: NOT CONFIGURED")
        end
        
        -- Show frame status
        for _, unit in ipairs({"target", "focus", "targettarget", "pet"}) do
            local frame = customFrames[unit]
            if frame then
                local exists = UnitExists(unit) and "exists" or "no unit"
                local shown = frame:IsShown() and "shown" or "hidden"
                local alpha = frame:GetAlpha()
                local rangeState = frame.tuiInRange
                local rangeStr = rangeState == true and "|cff00ff00IN RANGE|r" or 
                                (rangeState == false and "|cffff0000OUT OF RANGE|r" or "unknown")
                print(string.format("  %s: %s, %s, alpha=%.2f, %s", unit, exists, shown, alpha, rangeStr))
            else
                print(string.format("  %s: no custom frame", unit))
            end
        end
    else
        print("|cff00ff00TweaksUI Range Fade Commands:|r")
        print("  /tuirangeindiv [status] - Show status")
        print("  /tuirangeindiv on - Enable range fade")
        print("  /tuirangeindiv off - Disable range fade")
    end
end

SLASH_TUIDEBUGAURAS1 = "/tuidebugauras"
SlashCmdList["TUIDEBUGAURAS"] = function()
    print("|cff00ff00TweaksUI: Scanning player debuffs (Midnight - NO comparison allowed)...|r")
    if not C_UnitAuras or not C_UnitAuras.GetUnitAuras then
        print("|cffff0000  C_UnitAuras API not available|r")
        return
    end
    
    if not C_UnitAuras.GetAuraDispelTypeColor then
        print("|cffff0000  C_UnitAuras.GetAuraDispelTypeColor not available - not on Midnight?|r")
        return
    end
    
    -- Force initialization
    DispelUtils:EnsureInitialized()
    
    print(string.format("  Initialized: %s, ColorCurve: %s", 
        tostring(DispelUtils.initialized),
        DispelUtils.colorCurve and "yes" or "NO"))
    
    local colorCurve = DispelUtils:GetColorCurve()
    if not colorCurve then
        print("|cffff0000  DispelUtils color curve failed to initialize|r")
        return
    end
    
    local auras = C_UnitAuras.GetUnitAuras("player", "HARMFUL")
    if not auras or #auras == 0 then
        print("  No debuffs found on player")
        return
    end
    
    print(string.format("  Found %d debuffs:", #auras))
    print("  |cffff8800NOTE: All curve values are SECRET - cannot read or compare|r")
    
    for i, aura in ipairs(auras) do
        print(string.format("  [%d] auraInstanceID: %s, name: %s", 
            i, tostring(aura.auraInstanceID or "nil"), aura.name or "?"))
        
        -- Test color curve - just confirm we get a color object
        local color = C_UnitAuras.GetAuraDispelTypeColor("player", aura.auraInstanceID, colorCurve)
        if color then
            print("      Color curve: returned color object (values are secret)")
        else
            print("      Color curve: nil (no dispel type)")
        end
        
        -- Test each detection curve - just confirm we get results
        print("      Detection curves:")
        for _, typeName in ipairs({"Magic", "Curse", "Disease", "Poison", "Bleed"}) do
            local detCurve = DispelUtils:GetDetectionCurve(typeName)
            if detCurve then
                local detColor = C_UnitAuras.GetAuraDispelTypeColor("player", aura.auraInstanceID, detCurve)
                if detColor then
                    print(string.format("        %s: got color (alpha is secret - pass to SetAlpha)", typeName))
                else
                    print(string.format("        %s: nil", typeName))
                end
            else
                print(string.format("        %s: NO CURVE", typeName))
            end
        end
    end
    
    print("  |cff00ff00Testing ApplyTypeAlphaToIndicator would require actual UI indicators|r")
end

-- Compatibility aliases (used throughout the file)
-- Now require unit token to use unit+auraInstanceID signature
local function GetDispelColorFromAura(unit, auraData)
    return DispelUtils:GetColorFromAura(unit, auraData)
end

local function AuraHasDispelType(unit, auraData, dispelTypeName)
    return DispelUtils:AuraHasType(unit, auraData, dispelTypeName)
end

local function GetAuraDispelTypeName(unit, auraData)
    return DispelUtils:GetTypeName(unit, auraData)
end

local function GetDispelColor(dispelTypeOrName)
    return DispelUtils:GetColor(dispelTypeOrName)
end

-- ============================================================================
-- RESOURCE/CLASS POWER DEFINITIONS (Phase 2)
-- ============================================================================

local SPECIAL_RESOURCES = { STAGGER = "STAGGER", SOUL_FRAGMENTS = "SOUL_FRAGMENTS", MAELSTROM_WEAPON = "MAELSTROM_WEAPON" }

-- In Midnight Beta 3+, secondary resources are no longer secret
local MIDNIGHT_NON_SECRET_RESOURCES = {
    [Enum.PowerType.ComboPoints] = true,
    [Enum.PowerType.Runes] = true,
    [Enum.PowerType.SoulShards] = true,
    [Enum.PowerType.HolyPower] = true,
    [Enum.PowerType.Chi] = true,
    [Enum.PowerType.ArcaneCharges] = true,
    [Enum.PowerType.Essence] = true,
}

-- Primary resources by class
local PRIMARY_RESOURCES = {
    DEATHKNIGHT = Enum.PowerType.RunicPower,
    DEMONHUNTER = Enum.PowerType.Fury,
    DRUID = { default = Enum.PowerType.Mana, forms = { [1] = Enum.PowerType.Energy, [5] = Enum.PowerType.Rage, [31] = Enum.PowerType.LunarPower } },
    EVOKER = Enum.PowerType.Mana, HUNTER = Enum.PowerType.Focus, MAGE = Enum.PowerType.Mana,
    MONK = { [268] = Enum.PowerType.Energy, [269] = Enum.PowerType.Energy, [270] = Enum.PowerType.Mana },
    PALADIN = Enum.PowerType.Mana,
    PRIEST = { [256] = Enum.PowerType.Mana, [257] = Enum.PowerType.Mana, [258] = Enum.PowerType.Insanity },
    ROGUE = Enum.PowerType.Energy,
    SHAMAN = { [262] = Enum.PowerType.Maelstrom, [263] = Enum.PowerType.Mana, [264] = Enum.PowerType.Mana },
    WARLOCK = Enum.PowerType.Mana, WARRIOR = Enum.PowerType.Rage,
}

-- Secondary resources (class power) by class/spec
local SECONDARY_RESOURCES = {
    DEATHKNIGHT = Enum.PowerType.Runes,
    -- Demon Hunter: Soul Fragments for all specs
    -- Also include specIndex fallbacks: 1=Havoc, 2=Vengeance
    DEMONHUNTER = { 
        default = SPECIAL_RESOURCES.SOUL_FRAGMENTS, 
        [577] = SPECIAL_RESOURCES.SOUL_FRAGMENTS, 
        [581] = SPECIAL_RESOURCES.SOUL_FRAGMENTS,
        [1] = SPECIAL_RESOURCES.SOUL_FRAGMENTS,
        [2] = SPECIAL_RESOURCES.SOUL_FRAGMENTS,
    },
    DRUID = { forms = { [1] = Enum.PowerType.ComboPoints } },
    EVOKER = Enum.PowerType.Essence,
    MAGE = { [62] = Enum.PowerType.ArcaneCharges },
    -- Monk: specID 268=Brewmaster(Stagger), 269=Windwalker(Chi), 270=Mistweaver(none)
    -- Also include specIndex fallbacks: 1=Brewmaster, 3=Windwalker
    MONK = { [268] = SPECIAL_RESOURCES.STAGGER, [269] = Enum.PowerType.Chi, [1] = SPECIAL_RESOURCES.STAGGER, [3] = Enum.PowerType.Chi },
    PALADIN = Enum.PowerType.HolyPower,
    ROGUE = Enum.PowerType.ComboPoints,
    -- Enhancement Shaman (263) uses Maelstrom Weapon (aura-based stacking resource)
    -- Also include specIndex fallback: 2=Enhancement
    SHAMAN = { [263] = SPECIAL_RESOURCES.MAELSTROM_WEAPON, [2] = SPECIAL_RESOURCES.MAELSTROM_WEAPON },
    WARLOCK = Enum.PowerType.SoulShards,
}

-- Resource colors
local RESOURCE_COLORS = {
    [Enum.PowerType.Mana] = { r = 0, g = 0, b = 1 },
    [Enum.PowerType.Rage] = { r = 1, g = 0, b = 0 },
    [Enum.PowerType.Focus] = { r = 1, g = 0.5, b = 0.25 },
    [Enum.PowerType.Energy] = { r = 1, g = 1, b = 0 },
    [Enum.PowerType.ComboPoints] = { r = 1, g = 0.96, b = 0.41 },
    [Enum.PowerType.Runes] = { r = 0.5, g = 0.5, b = 0.5 },
    [Enum.PowerType.RunicPower] = { r = 0, g = 0.82, b = 1 },
    [Enum.PowerType.SoulShards] = { r = 0.58, g = 0.51, b = 0.79 },
    [Enum.PowerType.LunarPower] = { r = 0.3, g = 0.52, b = 0.9 },
    [Enum.PowerType.HolyPower] = { r = 0.95, g = 0.9, b = 0.6 },
    [Enum.PowerType.Maelstrom] = { r = 0, g = 0.5, b = 1 },
    [Enum.PowerType.Chi] = { r = 0.71, g = 1, b = 0.92 },
    [Enum.PowerType.Insanity] = { r = 0.4, g = 0, b = 0.8 },
    [Enum.PowerType.ArcaneCharges] = { r = 0.1, g = 0.1, b = 0.98 },
    [Enum.PowerType.Fury] = { r = 0.79, g = 0.26, b = 0.99 },
    [Enum.PowerType.Essence] = { r = 0.2, g = 0.58, b = 0.5 },
    [SPECIAL_RESOURCES.STAGGER] = { r = 0.52, g = 1, b = 0.52 },
    [SPECIAL_RESOURCES.SOUL_FRAGMENTS] = { r = 0.64, g = 0.19, b = 0.79 },
    [SPECIAL_RESOURCES.MAELSTROM_WEAPON] = { r = 0.0, g = 0.5, b = 1.0 },  -- Blue like Maelstrom power
}

-- Get resource color
local function GetResourceColor(powerType)
    if RESOURCE_COLORS[powerType] then
        local c = RESOURCE_COLORS[powerType]
        return c.r, c.g, c.b
    end
    local info = PowerBarColor and PowerBarColor[powerType]
    return info and info.r or 1, info and info.g or 1, info and info.b or 1
end

-- Get secondary resource for a unit (player only for now)
local function GetSecondaryResourceForUnit(unit)
    if unit ~= "player" then return nil end
    
    local _, playerClass = UnitClass("player")
    if not playerClass then return nil end
    
    local data = SECONDARY_RESOURCES[playerClass]
    if not data then return nil end
    
    -- Check for form-based resources (Druid)
    if type(data) == "table" and data.forms then
        local formID = GetShapeshiftFormID and GetShapeshiftFormID()
        return formID and data.forms[formID] or data.default
    end
    
    -- Check for spec-based resources
    if type(data) == "table" then
        local specIndex = GetSpecialization and GetSpecialization()
        local specID = specIndex and GetSpecializationInfo(specIndex)
        -- Try spec ID first, then fall back to spec index
        local result = specID and data[specID]
        if not result and specIndex then
            result = data[specIndex]
        end
        return result or data.default
    end
    
    return data
end

-- Get secondary resource values
local function GetSecondaryResourceValues(unit)
    local resourceType = GetSecondaryResourceForUnit(unit)
    if not resourceType then return nil, nil, nil end
    
    -- Handle Stagger (Brewmaster Monk) - return raw values, let StatusBar handle secrets
    if resourceType == SPECIAL_RESOURCES.STAGGER then
        local stagger = UnitStagger and UnitStagger(unit) or 0
        local maxHealth = UnitHealthMax(unit) or 1
        -- Return raw stagger as current, maxHealth as max (StatusBar handles secrets)
        return stagger, maxHealth, resourceType, stagger
    end
    
    -- Handle Soul Fragments (Demon Hunter) - tracked via spell count, not UnitPower
    if resourceType == SPECIAL_RESOURCES.SOUL_FRAGMENTS then
        -- Soul Fragments are displayed via spell count on Soul Cleave/Spirit Bomb
        -- For Unit Frames, we'll return nil since it's complex to track
        -- Users should use the dedicated ResourceBars module for Soul Fragments
        return nil, nil, nil
    end
    
    -- Handle Maelstrom Weapon (Enhancement Shaman) - tracked via aura stacks
    if resourceType == SPECIAL_RESOURCES.MAELSTROM_WEAPON then
        local MAELSTROM_WEAPON_SPELL_ID = 344179
        local stacks = 0
        local maxStacks = 10
        
        -- Try GetPlayerAuraBySpellID first (Midnight API, or fallback pcall for safety)
        if C_UnitAuras and C_UnitAuras.GetPlayerAuraBySpellID then
            local ok, auraData = pcall(C_UnitAuras.GetPlayerAuraBySpellID, MAELSTROM_WEAPON_SPELL_ID)
            if ok and auraData then
                stacks = auraData.applications or 0
            end
        elseif AuraUtil and AuraUtil.FindAuraByName then
            -- Fallback for older clients
            local name = GetSpellInfo(MAELSTROM_WEAPON_SPELL_ID)
            if name then
                local _, _, stackCount = AuraUtil.FindAuraByName(name, unit, "HELPFUL")
                stacks = stackCount or 0
            end
        end
        
        return stacks, maxStacks, resourceType
    end
    
    -- Handle Runes (DK)
    if resourceType == Enum.PowerType.Runes then
        local max = UnitPowerMax(unit, resourceType) or 6
        local ready = 0
        for i = 1, max do
            local _, _, runeReady = GetRuneCooldown(i)
            if runeReady then ready = ready + 1 end
        end
        return ready, max, resourceType
    end
    
    -- Standard power types
    local current = UnitPower(unit, resourceType)
    local max = UnitPowerMax(unit, resourceType)
    if not max or max == 0 then return nil, nil, nil end
    
    return current, max, resourceType
end

-- Check if a resource type uses continuous bar display (vs discrete segments)
local function IsContinuousResource(resourceType)
    if resourceType == SPECIAL_RESOURCES.STAGGER then return true end
    return false
end

-- Get aura sort rule enum from settings string
local function GetAuraSortRule()
    if not HAS_AURA_SORTING or not settings or not settings.general then
        return Enum.UnitAuraSortRule and Enum.UnitAuraSortRule.Default or nil
    end
    local ruleStr = settings.general.auraSortRule or "Default"
    local enumTable = Enum.UnitAuraSortRule
    if enumTable and enumTable[ruleStr] then
        return enumTable[ruleStr]
    end
    return enumTable and enumTable.Default or nil
end

-- Get aura sort direction from settings string
local function GetAuraSortDirection()
    if not HAS_AURA_SORTING or not settings or not settings.general then
        return Enum.UnitAuraSortDirection and Enum.UnitAuraSortDirection.Normal or nil
    end
    local dirStr = settings.general.auraSortDirection or "Normal"
    local enumTable = Enum.UnitAuraSortDirection
    if enumTable and enumTable[dirStr] then
        return enumTable[dirStr]
    end
    return enumTable and enumTable.Normal or nil
end

-- Helper to set status bar value with optional smooth animation
local function SetBarValueSmooth(bar, value, useSmooth, settings)
    if not bar then return end
    -- Check if smooth bars are enabled in settings (default true)
    local smoothEnabled = settings and settings.smoothBars
    if smoothEnabled == nil then smoothEnabled = true end
    
    if smoothEnabled and useSmooth and BAR_INTERPOLATION then
        bar:SetValue(value, BAR_INTERPOLATION)
    else
        bar:SetValue(value)
    end
end

-- Helper to get health gradient color using Midnight curve or fallback
local function GetHealthGradientColorMidnight(unit, fallbackPercent)
    -- Try using UnitHealthPercent with curve (Midnight Beta 4+)
    -- Signature: UnitHealthPercent(unit [, usePredicted, curve])
    if UnitHealthPercent and GetOrCreateHealthGradientCurve() then
        local success, color = pcall(function()
            return UnitHealthPercent(unit, false, GetOrCreateHealthGradientCurve())
        end)
        if success and color and color.GetRGBA then
            return color:GetRGBA()
        end
    end
    
    -- Fallback to manual calculation (only works with non-secret values)
    if type(fallbackPercent) == "number" then
        local pct = fallbackPercent / 100
        if pct > 0.5 then
            local factor = (pct - 0.5) * 2
            return 1 - factor, 1, 0, 1
        else
            local factor = pct * 2
            return 1, factor, 0, 1
        end
    end
    
    return 0, 1, 0, 1  -- Default green
end

-- ============================================================================
-- RANGE CHECKING SYSTEM
-- ============================================================================

-- Forward declarations for frame tables (defined later, needed by range checker)
local partyMemberFrames = {}
local raidSmallMemberFrames = {}
local raidLargeMemberFrames = {}
local tankMemberFrames = {}
local settings = nil

-- Forward declaration for UpdateFrameData (defined later in file)
local UpdateFrameData

-- Ticker state (consolidated to reduce local count)
local Tickers = {
    rangeCheck = nil,
    partyHealth = nil,
    staggerUpdate = nil,
    maelstromWeapon = nil,
    individualRange = nil,
    raidCounter = 0,
}

-- Interval constants (consolidated)
local INTERVALS = {
    RANGE_CHECK = 0.2,
    PARTY_HEALTH = 0.5,
    RAID_HEALTH = 1.0,
    STAGGER = 0.1,
    MAELSTROM = 0.1,
}

-- Initialize party health update ticker
local function InitPartyHealthTicker()
    if Tickers.partyHealth then return end
    
    Tickers.partyHealth = C_Timer.NewTicker(INTERVALS.PARTY_HEALTH, function()
        -- Don't run if customFrames not initialized yet
        if not customFrames then return end
        
        -- Update individual unit frames (target, targettarget, focus)
        -- These need regular updates because events may not fire properly in Midnight
        -- Note: Removed pcall wrappers to avoid closure allocation overhead
        if customFrames["target"] and settings and settings.target and settings.target.enabled and UnitExists("target") then
            UpdateFrameData("target")
        end
        if customFrames["targettarget"] and settings and settings.targettarget and settings.targettarget.enabled and UnitExists("targettarget") then
            UpdateFrameData("targettarget")
        end
        if customFrames["focus"] and settings and settings.focus and settings.focus.enabled and UnitExists("focus") then
            UpdateFrameData("focus")
        end
        
        -- Only update party if party frames are enabled and not handled by external addon
        -- Use data-only updates for better performance
        if not UnitFrames:IsPartyDisabledByExternalAddon() then
            if settings and settings.party and settings.party.enabled and IsInGroup() and not IsInRaid() then
                for i = 1, 5 do
                    UnitFrames:UpdatePartyMemberDataOnly(i)
                end
            end
        end
        
        -- Only update raid if raid frames are enabled and not handled by external addon
        -- Raid updates run at half frequency (every 1.0s instead of 0.5s)
        -- Use data-only updates for better performance
        if not UnitFrames:IsRaidDisabledByExternalAddon() then
            Tickers.raidCounter = Tickers.raidCounter + 1
            if Tickers.raidCounter >= 2 then
                Tickers.raidCounter = 0
                if settings and settings.raid and settings.raid.enabled and IsInRaid() then
                    UnitFrames:UpdateAllRaidMemberData()
                end
            end
        end
    end)
end

local function StopPartyHealthTicker()
    if Tickers.partyHealth then
        Tickers.partyHealth:Cancel()
        Tickers.partyHealth = nil
    end
end

-- Stagger update ticker for Brewmaster Monk
-- Initialize stagger update ticker
local function InitStaggerTicker()
    if Tickers.staggerUpdate then return end
    
    -- Only start if player is Brewmaster Monk
    local _, playerClass = UnitClass("player")
    if playerClass ~= "MONK" then return end
    
    local specIndex = GetSpecialization()
    local specID = specIndex and GetSpecializationInfo(specIndex)
    local isBrewmaster = (specID == 268) or (specIndex == 1)
    if not isBrewmaster then return end
    
    Tickers.staggerUpdate = C_Timer.NewTicker(INTERVALS.STAGGER, function()
        -- Update player frame stagger display
        if playerFrame and playerFrame:IsShown() and playerFrame.classPower then
            local current, max, resourceType, rawValue = GetSecondaryResourceValues("player")
            if resourceType == SPECIAL_RESOURCES.STAGGER and current and max then
                -- Update the status bar (current is raw stagger, max is maxHealth)
                if playerFrame.classPower.statusBar then
                    playerFrame.classPower.statusBar:SetMinMaxValues(0, max)
                    playerFrame.classPower.statusBar:SetValue(current)
                    
                    -- Update color based on stagger level
                    -- Player's own stagger is non-secret in Midnight, avoid pcall overhead
                    local r, g, b = 0.52, 1, 0.52  -- Default light green
                    local staggerPct = 0
                    if max > 0 then
                        staggerPct = (current / max) * 100
                    end
                    
                    if staggerPct >= 60 then
                        r, g, b = 1, 0.35, 0.35  -- Heavy (red)
                    elseif staggerPct >= 30 then
                        r, g, b = 1, 0.85, 0.35  -- Moderate (yellow)
                    end
                    playerFrame.classPower.statusBar:SetStatusBarColor(r, g, b, 1)
                    
                    -- Update text based on format setting
                    if playerFrame.classPower.statusBarText then
                        local textFormat = settings and settings.player and settings.player.classPower and settings.player.classPower.staggerTextFormat or "percent"
                        
                        if textFormat == "amount" then
                            -- Use AbbreviateLargeNumbers for secret-safe formatting
                            playerFrame.classPower.statusBarText:SetText(AbbreviateLargeNumbers(current))
                        elseif textFormat == "percent" then
                            playerFrame.classPower.statusBarText:SetFormattedText("%.0f%%", staggerPct)
                        elseif textFormat == "both" then
                            local amountStr = AbbreviateLargeNumbers(current)
                            playerFrame.classPower.statusBarText:SetText(amountStr .. " (" .. string.format("%.0f%%", staggerPct) .. ")")
                        end
                    end
                end
            end
        end
    end)
end

local function StopStaggerTicker()
    if Tickers.staggerUpdate then
        Tickers.staggerUpdate:Cancel()
        Tickers.staggerUpdate = nil
    end
end

-- Maelstrom Weapon update ticker for Enhancement Shaman
local function InitMaelstromWeaponTicker()
    if Tickers.maelstromWeapon then return end
    
    -- Only start if player is Enhancement Shaman
    local _, playerClass = UnitClass("player")
    if playerClass ~= "SHAMAN" then return end
    
    local specIndex = GetSpecialization()
    local specID = specIndex and GetSpecializationInfo(specIndex)
    local isEnhancement = (specID == 263) or (specIndex == 2)
    if not isEnhancement then return end
    
    Tickers.maelstromWeapon = C_Timer.NewTicker(INTERVALS.MAELSTROM, function()
        -- Update player frame Maelstrom Weapon display
        if playerFrame and playerFrame:IsShown() and playerFrame.classPower then
            local current, max, resourceType = GetSecondaryResourceValues("player")
            if resourceType == SPECIAL_RESOURCES.MAELSTROM_WEAPON and current and max then
                -- Update segments for discrete display
                for i = 1, max do
                    local seg = playerFrame.classPower.segments[i]
                    if seg and seg.fill then
                        if i <= current then
                            seg.fill:Show()
                        else
                            seg.fill:Hide()
                        end
                    end
                end
            end
        end
    end)
end

local function StopMaelstromWeaponTicker()
    if Tickers.maelstromWeapon then
        Tickers.maelstromWeapon:Cancel()
        Tickers.maelstromWeapon = nil
    end
end

-- Initialize range checking system
-- DEPRECATED: This old system is replaced by RangeFade.lua module
-- Keeping function stub to prevent errors from existing calls
local function InitRangeChecker()
    -- NO-OP: RangeFade module now handles party/raid range checking
    -- This prevents the flashing caused by two systems competing
    return
end

-- Individual frame range ticker (for target, focus, etc.)
-- Uses Tickers.individualRange instead of separate local
-- Individual range fade functions consolidated into a table to reduce local count
local IndividualRangeFade = {}

function IndividualRangeFade:UpdateFrame(unit)
    local frame = customFrames[unit]
    if not frame or not frame:IsShown() then return end
    
    local unitSettings = settings and settings[unit]
    if not unitSettings or not unitSettings.enabled then return end
    
    -- Check for per-unit rangeFade or fall back to general settings
    local rangeFadeSettings = unitSettings.rangeFade
    local rangeFadeEnabled = false
    local outOfRangeAlpha = 0.4
    local perElementFade = false
    
    if rangeFadeSettings then
        rangeFadeEnabled = rangeFadeSettings.enabled
        outOfRangeAlpha = rangeFadeSettings.outOfRangeAlpha or 0.4
        perElementFade = rangeFadeSettings.perElementFade or false
    elseif settings.general and settings.general.rangeFade then
        local gs = settings.general.rangeFade
        rangeFadeEnabled = gs.enabled
        outOfRangeAlpha = gs.outOfRangeAlpha or 0.4
        perElementFade = gs.perElementFade or false
    end
    
    if not rangeFadeEnabled then
        -- Reset to full alpha if range fade was disabled
        if frame.tuiLastRangeAlpha ~= nil and frame.tuiLastRangeAlpha ~= 1.0 then
            frame:SetAlpha(1.0)
            if frame.healthBar then frame.healthBar:SetAlpha(1.0) end
            if frame.powerBar then frame.powerBar:SetAlpha(1.0) end
            if frame.nameText then frame.nameText:SetAlpha(1.0) end
            if frame.healthText then frame.healthText:SetAlpha(1.0) end
            frame.tuiLastRangeAlpha = 1.0
        end
        return
    end
    
    -- Skip player frame
    if unit == "player" then return end
    
    -- Check if unit exists
    if not UnitExists(unit) then
        -- Reset alpha when unit doesn't exist
        if frame.tuiLastRangeAlpha ~= 1.0 then
            frame:SetAlpha(1.0)
            frame.tuiLastRangeAlpha = 1.0
        end
        return
    end
    
    local inRange = true
    
    -- Determine range based on unit type
    if UnitIsFriend("player", unit) then
        -- For friendly units, UnitInRange works
        local rangeResult = UnitInRange(unit)
        local success, isInRange = pcall(function()
            if rangeResult == nil then return true end
            return rangeResult == true
        end)
        inRange = success and isInRange or true
    else
        -- For hostile units, use CheckInteractDistance
        local interactDist = CheckInteractDistance(unit, 4) -- 28 yards
        if interactDist ~= nil then
            inRange = interactDist
        else
            -- Try IsItemInRange with a ranged item
            local inItemRange = IsItemInRange(34471, unit) -- Vial of the Sunwell (35 yards)
            if inItemRange ~= nil then
                inRange = inItemRange
            else
                -- Can't determine, assume in range
                inRange = true
            end
        end
    end
    
    -- Apply alpha based on range
    local targetAlpha = inRange and 1.0 or outOfRangeAlpha
    
    -- Only update if alpha changed
    if frame.tuiLastRangeAlpha ~= targetAlpha then
        frame.tuiLastRangeAlpha = targetAlpha
        frame.tuiInRange = inRange
        
        if perElementFade and not inRange then
            -- Per-element fade
            local elementAlphas = (rangeFadeSettings and rangeFadeSettings.elementAlphas) or {
                healthBar = 0.3,
                powerBar = 0.3,
                nameText = 0.6,
                healthText = 0.4,
            }
            frame:SetAlpha(1.0) -- Keep frame at full alpha
            if frame.healthBar then frame.healthBar:SetAlpha(elementAlphas.healthBar) end
            if frame.powerBar then frame.powerBar:SetAlpha(elementAlphas.powerBar) end
            if frame.nameText then frame.nameText:SetAlpha(elementAlphas.nameText) end
            if frame.healthText then frame.healthText:SetAlpha(elementAlphas.healthText) end
        else
            -- Simple frame-level alpha
            frame:SetAlpha(targetAlpha)
            -- Reset element alphas
            if frame.healthBar then frame.healthBar:SetAlpha(1.0) end
            if frame.powerBar then frame.powerBar:SetAlpha(1.0) end
            if frame.nameText then frame.nameText:SetAlpha(1.0) end
            if frame.healthText then frame.healthText:SetAlpha(1.0) end
        end
    end
end

function IndividualRangeFade:OnTick()
    -- Update range for individual frames
    self:UpdateFrame("target")
    self:UpdateFrame("focus")
    self:UpdateFrame("targettarget")
    self:UpdateFrame("pet")
end

function IndividualRangeFade:Start()
    if Tickers.individualRange then return end
    
    -- Check if range fade is enabled in general settings
    if not settings or not settings.general or not settings.general.rangeFade then return end
    if not settings.general.rangeFade.enabled then return end
    
    Tickers.individualRange = C_Timer.NewTicker(0.2, function() IndividualRangeFade:OnTick() end)
    TweaksUI:PrintDebug("Individual frame range ticker started")
end

function IndividualRangeFade:Stop()
    if Tickers.individualRange then
        Tickers.individualRange:Cancel()
        Tickers.individualRange = nil
    end
    
    -- Reset alphas
    for _, unit in ipairs({"target", "focus", "targettarget", "pet"}) do
        local frame = customFrames[unit]
        if frame then
            frame:SetAlpha(1.0)
            frame.tuiLastRangeAlpha = nil
        end
    end
end

-- Stop range checker when not needed
local function StopRangeChecker()
    if Tickers.rangeCheck then
        Tickers.rangeCheck:Cancel()
        Tickers.rangeCheck = nil
    end
    
    -- Reset all party frame alphas
    if partyMemberFrames then
        for i = 1, 4 do
            local frame = partyMemberFrames[i]
            if frame then frame:SetAlpha(1) end
        end
    end
    
    -- Reset all raid frame alphas (small)
    if raidSmallMemberFrames then
        for i, frame in ipairs(raidSmallMemberFrames) do
            if frame then frame:SetAlpha(1) end
        end
    end
    
    -- Reset all raid frame alphas (large)
    if raidLargeMemberFrames then
        for i, frame in ipairs(raidLargeMemberFrames) do
            if frame then frame:SetAlpha(1) end
        end
    end
    
    -- Reset all tank frame alphas
    if tankMemberFrames then
        for i, frame in pairs(tankMemberFrames) do
            if frame then frame:SetAlpha(1) end
        end
    end
end

-- ============================================================================
-- DEBUFF INDICATOR STYLE HELPERS
-- ============================================================================

-- Debuff type colors (matching Blizzard's dispel colors)
-- Forward declared here for use in UpdateDebuffIndicatorStyle
local DEBUFF_TYPE_COLORS = {
    Magic = { 0.2, 0.6, 1.0, 1 },     -- Blue
    Curse = { 0.6, 0.0, 1.0, 1 },     -- Purple
    Disease = { 0.6, 0.4, 0.0, 1 },   -- Brown
    Poison = { 0.0, 0.6, 0.0, 1 },    -- Green
    Bleed = { 0.8, 0.0, 0.0, 1 },     -- Red (for bleeds)
}

-- Function to update indicator appearance based on style setting
local function UpdateDebuffIndicatorStyle(indicator, style, size)
    if not indicator then return end
    
    indicator:SetSize(size, size)
    
    local color = indicator.color or DEBUFF_TYPE_COLORS[indicator.debuffType] or {0.5, 0.5, 0.5, 1}
    
    if style == "squares" then
        -- Show colored square, hide icon
        if indicator.square then indicator.square:Show() end
        if indicator.icon then indicator.icon:Hide() end
        indicator:SetBackdrop({
            bgFile = nil,
            edgeFile = "Interface\\Buttons\\WHITE8X8",
            edgeSize = 1,
        })
        indicator:SetBackdropBorderColor(0, 0, 0, 1)
        
    elseif style == "icons" then
        -- Show icon, hide square
        if indicator.square then indicator.square:Hide() end
        if indicator.icon then indicator.icon:Show() end
        indicator:SetBackdrop(nil)  -- No border on icon-only mode
        
    elseif style == "both" then
        -- Show icon with colored border
        if indicator.square then indicator.square:Hide() end
        if indicator.icon then indicator.icon:Show() end
        indicator:SetBackdrop({
            bgFile = nil,
            edgeFile = "Interface\\Buttons\\WHITE8X8",
            edgeSize = 2,
        })
        indicator:SetBackdropBorderColor(color[1], color[2], color[3], 1)
    end
end

-- ============================================================================
-- CONSTANTS
-- ============================================================================

-- Consolidate dropdown option constants into single table
local DropdownOptions = {
    HEALTH_TEXT_FORMATS = {
        { id = "none", name = "Hidden" },
        { id = "current", name = "Current (45,230)" },
        { id = "max", name = "Maximum (100,000)" },
        { id = "percent", name = "Percent (45%)" },
        { id = "current_max", name = "Current / Max" },
        { id = "current_percent", name = "Current | Percent" },
        { id = "percent_current", name = "Percent | Current" },
        { id = "deficit", name = "Deficit (-54,770)" },
        { id = "deficit_percent", name = "Deficit % (-55%)" },
    },
    POWER_TEXT_FORMATS = {
        { id = "none", name = "Hidden" },
        { id = "current", name = "Current" },
        { id = "max", name = "Maximum" },
        { id = "percent", name = "Percent" },
        { id = "current_max", name = "Current / Max" },
    },
    HEALTH_COLOR_MODES = {
        { id = "class", name = "Class Color" },
        { id = "reaction", name = "Reaction Color" },
        { id = "custom", name = "Custom Color" },
        { id = "gradient", name = "Health Gradient" },
    },
    POWER_COLOR_MODES = {
        { id = "power", name = "Power Type" },
        { id = "custom", name = "Custom Color" },
    },
    NAME_COLOR_MODES = {
        { id = "white", name = "White" },
        { id = "class", name = "Class Color" },
        { id = "reaction", name = "Reaction Color" },
        { id = "custom", name = "Custom Color" },
    },
    PORTRAIT_MODES = {
        { id = "none", name = "Hidden" },
        { id = "2d", name = "2D Portrait" },
        { id = "3d", name = "3D Model" },
        { id = "class", name = "Class Icon" },
    },
    PORTRAIT_POSITIONS = {
        { id = "left", name = "Left" },
        { id = "right", name = "Right" },
    },
    FONT_OUTLINES = {
        { id = "", name = "None" },
        { id = "OUTLINE", name = "Thin" },
        { id = "THICKOUTLINE", name = "Thick" },
    },
}

-- Default font name for UnitFrames
local DEFAULT_FONT = "Friz Quadrata TT"

-- Helper to get font path from Media system (respects global font setting)
local function GetFontPath(fontNameOverride)
    -- First check global font
    if TweaksUI.Media then
        local globalFont = TweaksUI.Media:GetGlobalFontName()
        if globalFont then
            return TweaksUI.Media:GetFont(globalFont)
        end
    end
    
    -- Then check UnitFrames module font setting
    if settings and settings.general and settings.general.font then
        if TweaksUI.Media then
            return TweaksUI.Media:GetFont(settings.general.font)
        end
    end
    
    -- Then use passed-in font name or default
    local fontName = fontNameOverride or DEFAULT_FONT
    if TweaksUI.Media then
        return TweaksUI.Media:GetFont(fontName)
    end
    return "Fonts\\FRIZQT__.TTF"
end

-- Default texture for UnitFrames
local DEFAULT_TEXTURE = "Blizzard"

-- Helper to get texture path from Media system (respects global texture setting)
local function GetTexturePath(textureNameOverride)
    -- First check global texture
    if TweaksUI.Media and TweaksUI.Media:IsUsingGlobalTexture() then
        local globalTexture = TweaksUI.Media:GetGlobalTextureName()
        if globalTexture then
            return TweaksUI.Media:GetStatusBarTexture(globalTexture)
        end
    end
    
    -- Then use passed-in texture name or default
    local textureName = textureNameOverride or DEFAULT_TEXTURE
    if TweaksUI.Media then
        return TweaksUI.Media:GetStatusBarTexture(textureName)
    end
    return "Interface\\TargetingFrame\\UI-StatusBar"
end

-- Default font outline
local DEFAULT_OUTLINE = "OUTLINE"

-- Helper to get font outline from Media system (respects global font setting)
local function GetFontOutline(outlineOverride)
    -- First check global font outline
    if TweaksUI.Media then
        local globalOutline = TweaksUI.Media:GetGlobalFontOutline()
        if globalOutline then
            return globalOutline
        end
    end
    
    -- Then use passed-in outline or default
    return outlineOverride or DEFAULT_OUTLINE
end

-- Add more options to DropdownOptions table
DropdownOptions.ANCHOR_POINTS = {
    { id = "TOPLEFT", name = "Top Left" },
    { id = "TOP", name = "Top" },
    { id = "TOPRIGHT", name = "Top Right" },
    { id = "LEFT", name = "Left" },
    { id = "CENTER", name = "Center" },
    { id = "RIGHT", name = "Right" },
    { id = "BOTTOMLEFT", name = "Bottom Left" },
    { id = "BOTTOM", name = "Bottom" },
    { id = "BOTTOMRIGHT", name = "Bottom Right" },
}
DropdownOptions.GROW_DIRECTIONS = {
    { id = "RIGHT", name = "Right" },
    { id = "LEFT", name = "Left" },
    { id = "UP", name = "Up" },
    { id = "DOWN", name = "Down" },
}
DropdownOptions.HORIZONTAL_ALIGN = {
    { id = "LEFT", name = "Left" },
    { id = "CENTER", name = "Center" },
    { id = "RIGHT", name = "Right" },
}
DropdownOptions.VERTICAL_ALIGN = {
    { id = "TOP", name = "Top" },
    { id = "MIDDLE", name = "Middle" },
    { id = "BOTTOM", name = "Bottom" },
}
DropdownOptions.ROLE_SORT_OPTIONS = {
    { id = "TANK_HEALER_DPS", name = "Tank / Healer / DPS" },
    { id = "HEALER_TANK_DPS", name = "Healer / Tank / DPS" },
    { id = "DPS_TANK_HEALER", name = "DPS / Tank / Healer" },
    { id = "DPS_HEALER_TANK", name = "DPS / Healer / Tank" },
    { id = "NONE", name = "No Sorting (Group Order)" },
}
DropdownOptions.GROWTH_DIRECTIONS = {
    { id = "DOWN", name = "Down" },
    { id = "UP", name = "Up" },
    { id = "RIGHT", name = "Right" },
    { id = "LEFT", name = "Left" },
}
DropdownOptions.AURA_SORT_RULES = {
    { id = "Default", name = "Default" },
    { id = "Expiration", name = "By Time Remaining" },
    { id = "ExpirationOnly", name = "Time (No Priority)" },
    { id = "Name", name = "By Name" },
    { id = "NameOnly", name = "Name (No Priority)" },
    { id = "BigDefensive", name = "Big Defensives First" },
    { id = "Unsorted", name = "Unsorted" },
}
DropdownOptions.AURA_SORT_DIRECTIONS = {
    { id = "Normal", name = "Normal (Ascending)" },
    { id = "Reverse", name = "Reverse (Descending)" },
}
DropdownOptions.DEBUFF_INDICATOR_STYLES = {
    { id = "squares", name = "Colored Squares" },
    { id = "icons", name = "Blizzard Icons" },
    { id = "both", name = "Icons with Color Border" },
}

-- Local aliases for backwards compatibility with panel building code
-- NOTE: These MUST be defined AFTER all DropdownOptions properties are added
local HEALTH_TEXT_FORMATS = DropdownOptions.HEALTH_TEXT_FORMATS
local POWER_TEXT_FORMATS = DropdownOptions.POWER_TEXT_FORMATS
local HEALTH_COLOR_MODES = DropdownOptions.HEALTH_COLOR_MODES
local POWER_COLOR_MODES = DropdownOptions.POWER_COLOR_MODES
local NAME_COLOR_MODES = DropdownOptions.NAME_COLOR_MODES
local PORTRAIT_MODES = DropdownOptions.PORTRAIT_MODES
local PORTRAIT_POSITIONS = DropdownOptions.PORTRAIT_POSITIONS
local FONT_OUTLINES = DropdownOptions.FONT_OUTLINES
local ANCHOR_POINTS = DropdownOptions.ANCHOR_POINTS
local GROW_DIRECTIONS = DropdownOptions.GROW_DIRECTIONS
local HORIZONTAL_ALIGN = DropdownOptions.HORIZONTAL_ALIGN
local VERTICAL_ALIGN = DropdownOptions.VERTICAL_ALIGN
local ROLE_SORT_OPTIONS = DropdownOptions.ROLE_SORT_OPTIONS
local GROWTH_DIRECTIONS = DropdownOptions.GROWTH_DIRECTIONS
local AURA_SORT_RULES = DropdownOptions.AURA_SORT_RULES
local AURA_SORT_DIRECTIONS = DropdownOptions.AURA_SORT_DIRECTIONS
local DEBUFF_INDICATOR_STYLES = DropdownOptions.DEBUFF_INDICATOR_STYLES

-- Consolidate non-dropdown constants
local Constants = {
    ROLE_PRIORITY = {
        TANK_HEALER_DPS = { TANK = 1, HEALER = 2, DAMAGER = 3, NONE = 4 },
        HEALER_TANK_DPS = { HEALER = 1, TANK = 2, DAMAGER = 3, NONE = 4 },
        DPS_TANK_HEALER = { DAMAGER = 1, TANK = 2, HEALER = 3, NONE = 4 },
        DPS_HEALER_TANK = { DAMAGER = 1, HEALER = 2, TANK = 3, NONE = 4 },
    },
    DEBUFF_TYPE_ATLASES = {
        Magic = "RaidFrame-Icon-DebuffMagic",
        Curse = "RaidFrame-Icon-DebuffCurse",
        Disease = "RaidFrame-Icon-DebuffDisease",
        Poison = "RaidFrame-Icon-DebuffPoison",
        Bleed = "RaidFrame-Icon-DebuffBleed",
    },
    DEBUFF_TYPE_TEXTURES = {
        Magic = "Interface\\RaidFrame\\RaidFrame-Icon-DebuffMagic",
        Curse = "Interface\\RaidFrame\\RaidFrame-Icon-DebuffCurse",
        Disease = "Interface\\RaidFrame\\RaidFrame-Icon-DebuffDisease",
        Poison = "Interface\\RaidFrame\\RaidFrame-Icon-DebuffPoison",
    },
    POWER_COLORS = {
        [Enum.PowerType.Mana] = { 0.0, 0.0, 1.0 },
        [Enum.PowerType.Rage] = { 1.0, 0.0, 0.0 },
        [Enum.PowerType.Focus] = { 1.0, 0.5, 0.25 },
        [Enum.PowerType.Energy] = { 1.0, 1.0, 0.0 },
        [Enum.PowerType.ComboPoints] = { 1.0, 0.96, 0.41 },
        [Enum.PowerType.Runes] = { 0.5, 0.5, 0.5 },
        [Enum.PowerType.RunicPower] = { 0.0, 0.82, 1.0 },
        [Enum.PowerType.SoulShards] = { 0.58, 0.51, 0.79 },
        [Enum.PowerType.LunarPower] = { 0.3, 0.52, 0.9 },
        [Enum.PowerType.HolyPower] = { 0.95, 0.9, 0.6 },
        [Enum.PowerType.Maelstrom] = { 0.0, 0.5, 1.0 },
        [Enum.PowerType.Chi] = { 0.71, 1.0, 0.92 },
        [Enum.PowerType.Insanity] = { 0.4, 0.0, 0.8 },
        [Enum.PowerType.ArcaneCharges] = { 0.1, 0.1, 0.98 },
        [Enum.PowerType.Fury] = { 0.79, 0.26, 0.99 },
        [Enum.PowerType.Pain] = { 1.0, 0.61, 0.0 },
        [Enum.PowerType.Essence] = { 0.2, 0.58, 0.5 },
    },  -- close POWER_COLORS
}  -- close Constants

-- ============================================================================
-- DEFAULT SETTINGS
-- ============================================================================

local function GetDefaultFrameSettings(unit)
    local isPlayer = (unit == "player")
    local isTarget = (unit == "target")
    local isFocus = (unit == "focus")
    local isToT = (unit == "targettarget")
    local isPet = (unit == "pet")
    local isParty = unit:match("^party%d$")
    
    -- Default positions based on unit type
    local defaultX, defaultY
    local defaultWidth, defaultHeight = 220, 46
    
    if isPlayer then
        defaultX, defaultY = -300, -150
    elseif isTarget then
        defaultX, defaultY = 300, -150
    elseif isFocus then
        defaultX, defaultY = -300, -220
    elseif isToT then
        defaultX, defaultY = 300, -220
        defaultWidth, defaultHeight = 160, 32  -- Smaller for ToT
    elseif isPet then
        defaultX, defaultY = -300, -290
        defaultWidth, defaultHeight = 160, 32  -- Smaller for Pet
    elseif isParty then
        -- Stack party frames vertically on the left
        local partyNum = tonumber(unit:match("%d")) or 1
        defaultX, defaultY = -450, 100 - ((partyNum - 1) * 55)
        defaultWidth, defaultHeight = 180, 44  -- Medium size for party
    else
        defaultX, defaultY = 0, 0
    end
    
    -- Smaller frames get adjusted defaults
    local isSmallFrame = (isToT or isPet)
    local isMediumFrame = isParty
    
    -- Enable core solo frames by default, keep group frames disabled
    -- Users should opt-in to party/raid/boss/tank frames
    local enabledByDefault = isPlayer or isTarget or isFocus or isToT or isPet
    
    return {
        enabled = enabledByDefault,  -- Enable core frames, disable group frames
        
        -- Frame dimensions and position
        frame = {
            width = defaultWidth,
            height = defaultHeight,
            autoSize = true,  -- Dynamically calculate size based on elements
            x = defaultX,
            y = defaultY,
            anchor = "CENTER",
            scale = 1.0,
            -- Background appearance
            showBackground = true,
            bgColor = { 0.02, 0.02, 0.02, 0.92 },
            -- Border appearance
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
            -- Spacing
            padding = 1,  -- Padding inside frame
            barSpacing = 1,  -- Space between health and power bars
            -- Extra background extension (for text outside bars)
            bgExtendTop = 0,  -- Extend background above frame
            bgExtendBottom = 0,  -- Extend background below frame
        },
        
        -- Health Bar
        healthBar = {
            enabled = true,
            height = isSmallFrame and 20 or 30,
            texture = "Blizzard",
            colorMode = "class",
            customColor = { 0, 0.8, 0, 1 },
            bgEnabled = true,
            bgColor = { 0.12, 0.12, 0.12, 0.85 },
            borderEnabled = false,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
        },
        
        -- Power Bar
        powerBar = {
            enabled = not isSmallFrame,  -- Disabled by default for small frames
            height = isSmallFrame and 6 or 12,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgEnabled = true,
            bgColor = { 0.08, 0.08, 0.08, 0.85 },
            borderEnabled = false,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
        },
        
        -- Absorb Bar (Phase 2) - Shows absorption shields on health bar
        absorbBar = {
            enabled = false,  -- Default to disabled
            style = "overlay",  -- "overlay" (on health bar) or "bar" (separate bar)
            height = 10,  -- Only used for "bar" style
            -- Direction and position settings
            fillDirection = "rightToLeft",  -- "leftToRight" or "rightToLeft"
            offsetX = 0,  -- Horizontal offset from health bar
            offsetY = 0,  -- Vertical offset from health bar
            -- Appearance
            color = { 0.8, 0.8, 0.2, 0.6 },  -- Yellow with transparency
            texture = "Blizzard",
            bgEnabled = true,
            bgColor = { 0.1, 0.1, 0.1, 0.6 },
            borderEnabled = false,
            borderColor = { 0.3, 0.3, 0.3, 1 },
            borderSize = 1,
            -- Label/Name
            showLabel = false,
            labelText = "Absorb",
            labelPosition = "LEFT",  -- LEFT, RIGHT, TOP, BOTTOM, CENTER
            labelOffsetX = 0,
            labelOffsetY = 0,
            labelFontSize = 10,
            labelColor = { 1, 1, 1, 1 },
            -- Value Text
            showText = false,  -- Show absorb amount text
            textFormat = "current",  -- "current", "percent", "current_max"
            textOffsetX = 0,
            textOffsetY = 0,
            textFontSize = 10,
        },
        
        -- Alternate Power / Class Resource (Phase 2) - Shows secondary resources
        classPower = {
            enabled = isPlayer,  -- Only enabled for player by default
            height = 8,
            spacing = 2,
            position = "below",  -- "below", "above", "inside" (inside power bar)
            offsetY = 0,
            style = "segments",  -- "segments" (individual points) or "bar" (continuous)
            texture = "Blizzard",
            useResourceColor = true,
            customColor = { 1, 0.8, 0, 1 },
            bgColor = { 0.15, 0.15, 0.15, 0.8 },
            inactiveColor = { 0.2, 0.2, 0.2, 0.6 },
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
            -- Text options for discrete resources (combo points, etc.)
            showText = false,
            textFormat = "current",  -- "current", "current_max"
            -- Stagger-specific options (Brewmaster Monk)
            staggerTextFormat = "percent",  -- "amount", "percent", "both"
        },
        
        -- Cast Bar
        castBar = {
            enabled = false,
            height = isSmallFrame and 8 or 12,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",  -- "bottom" = below frame, "health" = inside health bar
            offsetY = 0,
            -- Appearance
            texture = "Blizzard",
            color = { 1.0, 0.7, 0, 1 },  -- Default cast color (orange/gold)
            interruptedColor = { 1, 0, 0, 1 },  -- Red when interrupted
            nonInterruptibleColor = { 0.7, 0.7, 0.7, 1 },  -- Gray for non-interruptible
            bgEnabled = true,
            bgColor = { 0.1, 0.1, 0.1, 0.8 },
            borderEnabled = false,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
        },
        
        -- Health Text
        healthText = {
            enabled = true,
            format = isSmallFrame and "percent" or "current_percent",
            abbreviate = true,
            font = "Friz Quadrata TT",
            fontSize = isSmallFrame and 9 or 11,
            fontOutline = "OUTLINE",
            anchor = "CENTER",
            offsetX = 0,
            offsetY = isSmallFrame and 0 or 2,
            color = { 1, 1, 1, 1 },
            colorByHealth = false,
            hAlign = "CENTER",  -- LEFT, CENTER, RIGHT
            vAlign = "MIDDLE",  -- TOP, MIDDLE, BOTTOM
        },
        
        -- Power Text
        powerText = {
            enabled = false,
            format = "current",
            abbreviate = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            anchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        
        -- Name Text
        nameText = {
            enabled = not isSmallFrame,  -- Disabled by default for small frames
            fontSize = isSmallFrame and 9 or 11,
            fontOutline = "OUTLINE",
            anchor = "BOTTOM",
            frameAnchor = "TOP",
            anchorToHealthBar = false,  -- If true, anchors inside health bar instead of frame edge
            offsetX = 0,
            offsetY = 2,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        
        -- Level Text
        levelText = {
            enabled = isTarget,  -- Only enabled by default for target
            fontSize = isSmallFrame and 9 or 11,
            fontOutline = "OUTLINE",
            anchor = "BOTTOMRIGHT",
            frameAnchor = "TOPRIGHT",
            offsetX = -2,
            offsetY = 2,
            showClassification = true,
            hideAtMaxLevel = false,
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        
        -- Portrait
        portrait = {
            enabled = false,
            mode = "2d",
            size = isSmallFrame and 28 or 44,
            position = "left",
            outside = false,  -- If true, portrait doesn't affect bar width
            offsetX = 0,
            offsetY = 0,
        },
        
        -- Raid Target Icon
        raidTarget = {
            enabled = true,
            size = isSmallFrame and 18 or (isParty and 18 or 24),
            anchor = "CENTER",
            frameAnchor = isParty and "TOP" or "TOP",
            offsetX = 0,
            offsetY = isParty and -2 or (isSmallFrame and 8 or 12),
        },
        
        -- Role Icon (Tank/Healer/DPS)
        roleIcon = {
            enabled = isParty,  -- On by default for party frames
            size = isSmallFrame and 14 or (isParty and 16 or 18),
            anchor = "CENTER",
            frameAnchor = isParty and "TOPLEFT" or "TOPLEFT",
            offsetX = isParty and 2 or (isSmallFrame and 2 or 4),
            offsetY = isParty and -2 or (isSmallFrame and -2 or -4),
        },
        
        -- Debuff Indicators (for dispellable debuffs)
        debuffIndicators = {
            enabled = isParty,  -- Enabled by default for party frames
            onlyPlayerDispellable = false,
            showMagic = true,
            showCurse = true,
            showDisease = true,
            showPoison = true,
            showBleed = false,
            size = isParty and 14 or 12,
            style = "squares",  -- "squares", "icons", or "both"
            position = "BOTTOMRIGHT",
            offsetX = -2,
            offsetY = 2,
            showBorder = true,
        },
        
        -- Status Indicators (Combat & Resting) - Player frame only
        statusIndicators = {
            enabled = isPlayer,  -- Only enabled for player frame by default
            size = 24,
            anchor = "CENTER",
            frameAnchor = "TOPLEFT",
            offsetX = 0,
            offsetY = 0,
            showCombat = true,
            showResting = true,
            combatTexture = "DEFAULT",  -- "DEFAULT" or custom path
            restingTexture = "DEFAULT",
        },
        
        -- Leader/Assistant Indicator
        leaderIndicator = {
            enabled = isPlayer or isParty,  -- Show on player and party frames
            size = 16,
            anchor = "CENTER",
            frameAnchor = "TOPRIGHT",
            offsetX = -2,
            offsetY = -2,
        },
        
        -- Summon Indicator (shows pending/accepted summon status)
        summonIndicator = {
            enabled = isParty,  -- Primarily useful for party/raid frames
            size = 20,
            anchor = "CENTER",
            frameAnchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            pendingColor = { 1, 0.8, 0, 1 },    -- Yellow/orange for pending
            acceptedColor = { 0, 1, 0, 1 },      -- Green for accepted
        },
        
        -- Target Highlight (shows when this unit is your current target)
        targetHighlight = {
            enabled = isParty,  -- Useful for party frames to see who you're targeting
            style = "border",  -- "border" or "glow"
            color = { 1, 1, 1, 1 },  -- White
            thickness = 2,  -- Border thickness (only for border style)
        },
        
        -- Visibility Settings (per-frame)
        visibility = {
            enabled = false,            -- Master toggle for this frame
            combat = false,             -- Show in combat
            mouseover = false,          -- Show on mouseover
            target = false,             -- Show when have target
            group = false,              -- Show in party/raid
            instance = false,           -- Show by instance type
            instanceTypes = {},         -- Which instance types: party, raid, arena, pvp, scenario
            fadeAlpha = 0,              -- Alpha when hidden (0-100)
        },
        
        -- ================================================================
        -- AURA DISPLAY (Phase 3) - Full buff/debuff icons
        -- ================================================================
        
        -- Buffs display
        buffs = {
            enabled = false,  -- Disabled by default
            maxAuras = 8,     -- Maximum buffs to show
            size = isSmallFrame and 16 or 20,
            spacing = 2,
            growDirection = "RIGHT",  -- RIGHT, LEFT, UP, DOWN
            wrapAfter = 4,    -- Wrap to new row/column after this many
            wrapDirection = "DOWN",  -- Secondary direction for wrapping
            anchor = "BOTTOMLEFT",
            frameAnchor = "TOPLEFT",
            offsetX = 0,
            offsetY = 2,
            -- Filtering (uses Blizzard filter strings)
            filter = "HELPFUL",  -- HELPFUL, HELPFUL|PLAYER, HELPFUL|RAID, etc.
            hidePermanent = false,  -- Hide auras with no duration (uses TruncateWhenZero)
            -- Sorting (uses Midnight Beta 4+ sort rules)
            sortRule = "Default",  -- Unsorted, Default, BigDefensive, Expiration, ExpirationOnly, Name, NameOnly
            sortDirection = "Normal",  -- Normal, Reverse
            -- Display options
            showDuration = true,        -- Show cooldown sweep
            sweepAlpha = 1.0,           -- Alpha of the cooldown sweep (0.0 to 1.0)
            showDurationText = true,    -- Show duration countdown text
            durationFontSize = 10,
            durationAnchor = "CENTER",  -- CENTER, TOP, BOTTOM, LEFT, RIGHT, TOPLEFT, etc.
            durationOffsetX = 0,
            durationOffsetY = 0,
            durationColor = { 1, 1, 0.6, 1 },  -- Yellow-ish by default
            durationFont = nil,  -- nil = use global/default font
            durationOutline = "OUTLINE",  -- "", "OUTLINE", "THICKOUTLINE"
            showStacks = true,
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            -- Stack display
            stackPosition = "BOTTOMRIGHT",
            stackFontSize = 10,
        },
        
        -- Debuffs display
        debuffs = {
            enabled = isParty or (unit == "target"),  -- Enabled for party and target
            maxAuras = isParty and 4 or 8,
            size = isSmallFrame and 18 or 22,
            spacing = 2,
            growDirection = "RIGHT",
            wrapAfter = 4,
            wrapDirection = "DOWN",
            anchor = "TOPLEFT",
            frameAnchor = "BOTTOMLEFT",
            offsetX = 0,
            offsetY = -2,
            -- Filtering
            filter = "HARMFUL",  -- HARMFUL, HARMFUL|PLAYER, HARMFUL|RAID, etc.
            hidePermanent = false,  -- Hide auras with no duration (uses TruncateWhenZero)
            -- Sorting
            sortRule = "Default",
            sortDirection = "Normal",
            -- Display options
            showDuration = true,        -- Show cooldown sweep
            sweepAlpha = 1.0,           -- Alpha of the cooldown sweep (0.0 to 1.0)
            showDurationText = true,    -- Show duration countdown text
            durationFontSize = 10,
            durationAnchor = "CENTER",
            durationOffsetX = 0,
            durationOffsetY = 0,
            durationColor = { 1, 1, 0.6, 1 },
            durationFont = nil,  -- nil = use global/default font
            durationOutline = "OUTLINE",  -- "", "OUTLINE", "THICKOUTLINE"
            showStacks = true,
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            -- Dispel type coloring (uses Midnight curves if available)
            colorByDispelType = true,
            dispelBorderOnly = true,  -- Only color border, not whole icon
            -- Stack display
            stackPosition = "BOTTOMRIGHT",
            stackFontSize = 10,
        },
        
        -- Heal Prediction (incoming heals bar)
        healPrediction = {
            enabled = true,
            showMyHeals = true,
            showOtherHeals = true,
            separateColors = false,
            myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
            otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
            allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
            showAbsorbs = true,
            absorbColor = { 0.8, 0.8, 0.2, 0.6 },
            absorbOverlay = not isSmallFrame,  -- Disabled for small frames
        },
    }
end

local DEFAULTS = {
    enabled = false,
    player = nil,
    target = nil,
    savedLayouts = {},  -- User's custom saved layouts
    
    -- General module settings (Midnight Beta 4+ features)
    general = {
        smoothBars = true,            -- Smooth bar animations
        auraSortRule = "Default",     -- How to sort auras
        auraSortDirection = "Normal", -- Aura sort direction
        dispelColors = true,          -- Color debuff indicators by dispel type
        auraDurationColors = false,   -- Color auras by time remaining
        
        -- Global font for all unit frame text
        font = "Friz Quadrata TT",
        
        -- Universal Mouseover Highlight (applies to all frames)
        mouseoverHighlight = {
            enabled = false,
            style = "overlay",  -- "overlay" or "border"
            color = { 1, 1, 1, 0.15 },
            borderThickness = 2,
        },
        
        -- Range fade for individual frames (target, focus, etc.)
        rangeFade = {
            enabled = true,
            outOfRangeAlpha = 0.4,
            perElementFade = false,
        },
    },
}

-- ============================================================================
-- PRESET LAYOUTS
-- ============================================================================

local PRESET_LAYOUTS = {
    simple = {
        name = "Simple",
        description = "Clean minimal look with centered text",
        frame = {
            width = 200,
            height = 40,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.05, 0.05, 0.05, 0.9 },
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
            padding = 2,
            barSpacing = 2,
            bgExtendTop = 0,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 24,
            texture = "Blizzard",
            colorMode = "class",
            customColor = { 0, 0.8, 0, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.8 },
        },
        powerBar = {
            enabled = true,
            height = 8,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.8 },
        },
        healthText = {
            enabled = true,
            format = "percent",
            abbreviate = true,
            fontSize = 11,
            fontOutline = "OUTLINE",
            offsetX = -4,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = false,
            hAlign = "RIGHT",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "current",
            abbreviate = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "LEFT",
            anchorToHealthBar = true,
            offsetX = 4,
            offsetY = 0,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "LEFT",
            vAlign = "MIDDLE",
        },
        levelText = {
            enabled = false,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 2,
            showClassification = false,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 40,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 20,
            anchor = "CENTER",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = 10,
        },
        castBar = {
            enabled = false,
            height = 12,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",
            offsetY = 0,
        },
    },
    
    robust = {
        name = "Robust",
        description = "Full featured with portrait and all elements",
        frame = {
            width = 280,
            height = 50,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.02, 0.02, 0.02, 0.95 },
            showBorder = true,
            borderColor = { 0.3, 0.3, 0.3, 1 },
            borderSize = 2,
            padding = 0,
            barSpacing = 2,
            bgExtendTop = 18,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 28,
            texture = "Blizzard Raid Bar",
            colorMode = "class",
            customColor = { 0, 0.8, 0, 1 },
            bgColor = { 0.15, 0.15, 0.15, 0.9 },
        },
        powerBar = {
            enabled = true,
            height = 14,
            texture = "Blizzard Raid Bar",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.9 },
        },
        healthText = {
            enabled = true,
            format = "current_percent",
            abbreviate = true,
            fontSize = 12,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = true,
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = true,
            format = "current",
            abbreviate = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 12,
            fontOutline = "OUTLINE",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = -14,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "CENTER",
        },
        levelText = {
            enabled = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = -4,
            offsetY = -14,
            showClassification = true,
            hideAtMaxLevel = false,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = true,
            mode = "2d",
            size = 50,
            position = "left",
            outside = true,
            offsetX = -52,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 24,
            anchor = "CENTER",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = 12,
        },
        castBar = {
            enabled = false,
            height = 12,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",
            offsetY = 0,
        },
    },
    
    fancy = {
        name = "Fancy",
        description = "Stylish with 3D portrait and gradient health",
        frame = {
            width = 250,
            height = 44,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.03, 0.03, 0.06, 0.92 },
            showBorder = true,
            borderColor = { 0.4, 0.35, 0.2, 1 },
            borderSize = 1,
            padding = 0,
            barSpacing = 1,
            bgExtendTop = 18,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 32,
            texture = "Blizzard Raid Bar",
            colorMode = "gradient",
            customColor = { 0, 0.8, 0, 1 },
            bgColor = { 0.08, 0.08, 0.12, 0.85 },
        },
        powerBar = {
            enabled = true,
            height = 10,
            texture = "Blizzard Raid Bar",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.06, 0.06, 0.1, 0.85 },
        },
        healthText = {
            enabled = true,
            format = "current_max",
            abbreviate = true,
            fontSize = 11,
            fontOutline = "OUTLINE",
            offsetX = 2,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = false,
            hAlign = "LEFT",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "percent",
            abbreviate = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 13,
            fontOutline = "THICKOUTLINE",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = -14,
            colorMode = "class",
            customColor = { 1, 0.85, 0, 1 },
            hAlign = "CENTER",
        },
        levelText = {
            enabled = true,
            fontSize = 11,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = -4,
            offsetY = -14,
            showClassification = true,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = true,
            mode = "2d",
            size = 54,
            position = "left",
            outside = true,
            offsetX = -56,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 28,
            anchor = "CENTER",
            frameAnchor = "RIGHT",
            offsetX = 14,
            offsetY = 0,
        },
        castBar = {
            enabled = false,
            height = 12,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",
            offsetY = 0,
        },
    },
    
    minimal = {
        name = "Minimal",
        description = "Ultra-clean floating bars only",
        frame = {
            width = 180,
            height = 24,
            scale = 1.0,
            autoSize = true,
            showBackground = false,
            bgColor = { 0, 0, 0, 0 },
            showBorder = false,
            borderColor = { 0, 0, 0, 0 },
            borderSize = 0,
            padding = 0,
            barSpacing = 1,
            bgExtendTop = 0,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 18,
            texture = "Blizzard",
            colorMode = "class",
            customColor = { 0, 0.8, 0, 1 },
            bgColor = { 0.15, 0.15, 0.15, 0.6 },
        },
        powerBar = {
            enabled = true,
            height = 4,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.5 },
        },
        healthText = {
            enabled = true,
            format = "percent",
            abbreviate = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            offsetX = -4,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = true,
            hAlign = "RIGHT",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "none",
            abbreviate = true,
            fontSize = 8,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "LEFT",
            anchorToHealthBar = true,
            offsetX = 4,
            offsetY = 0,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "LEFT",
            vAlign = "MIDDLE",
        },
        levelText = {
            enabled = false,
            fontSize = 9,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 0,
            showClassification = false,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 30,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 18,
            anchor = "CENTER",
            frameAnchor = "LEFT",
            offsetX = -10,
            offsetY = 0,
        },
        castBar = {
            enabled = false,
            height = 10,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",
            offsetY = 0,
        },
    },
    
    -- Party Style - Compact, class-colored, health-focused (healer-friendly)
    party = {
        name = "Party Style",
        description = "Compact layout ideal for party/group frames with icons inside",
        frame = {
            width = 170,
            height = 42,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.02, 0.02, 0.02, 0.92 },
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
            padding = 2,
            barSpacing = 1,
            bgExtendTop = 0,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 30,
            texture = "Blizzard",
            colorMode = "class",
            customColor = { 0, 0.8, 0, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.9 },
        },
        powerBar = {
            enabled = true,
            height = 6,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.9 },
        },
        healthText = {
            enabled = true,
            format = "percent",
            abbreviate = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            offsetX = -4,
            offsetY = 0,
            colorByHealth = false,
            hAlign = "RIGHT",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "none",
            abbreviate = true,
            fontSize = 8,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "LEFT",
            anchorToHealthBar = true,
            offsetX = 4,
            offsetY = 0,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "LEFT",
            vAlign = "MIDDLE",
        },
        levelText = {
            enabled = false,
            fontSize = 9,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 0,
            showClassification = false,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 28,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 18,
            anchor = "CENTER",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = -2,
        },
        roleIcon = {
            enabled = true,
            size = 16,
            anchor = "CENTER",
            frameAnchor = "TOPLEFT",
            offsetX = 2,
            offsetY = -2,
        },
        debuffIndicators = {
            enabled = true,
            showMagic = true,
            showCurse = true,
            showDisease = true,
            showPoison = true,
            showBleed = false,
            size = 14,
            style = "squares",  -- "squares", "icons", or "both"
            position = "BOTTOMRIGHT",
            offsetX = -2,
            offsetY = 2,
            showBorder = true,
        },
        castBar = {
            enabled = false,
            height = 8,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
        },
        defensiveIcon = {
            enabled = true,
            size = 28,
            scale = 1.0,
            anchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            showBorder = true,
            borderSize = 2,
            borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
            showCooldown = true,
            showSwipe = true,
            showDuration = true,
        showDurationText = false,
        },
        dispelOverlay = {
            enabled = true,
            fillAlpha = 0.5,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 3,
            glowAlpha = 0.25,
            showPulse = true,
            onlyPlayerDispellable = false,
            showBleed = false,
            showEnrage = false,
        },
        threatOverlay = {
            enabled = false,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 4,
            glowAlpha = 0.3,
            showPulse = true,
            
            onlyTanking = false,
            
        },
    },
    
    -- Modern Style - Clean contemporary look with subtle styling
    modern = {
        name = "Modern",
        description = "Clean contemporary design with subtle gradients",
        frame = {
            width = 220,
            height = 38,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.08, 0.08, 0.1, 0.88 },
            showBorder = true,
            borderColor = { 0.15, 0.15, 0.2, 1 },
            borderSize = 1,
            padding = 1,
            barSpacing = 1,
            bgExtendTop = 0,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 28,
            texture = "Blizzard Raid Bar",
            colorMode = "class",
            customColor = { 0.2, 0.8, 0.2, 1 },
            bgColor = { 0.12, 0.12, 0.15, 0.85 },
        },
        powerBar = {
            enabled = true,
            height = 6,
            texture = "Blizzard Raid Bar",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.1, 0.1, 0.12, 0.8 },
        },
        healthText = {
            enabled = true,
            format = "percent",
            abbreviate = true,
            fontSize = 11,
            fontOutline = "OUTLINE",
            offsetX = -4,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = false,
            hAlign = "RIGHT",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "percent",
            abbreviate = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 11,
            fontOutline = "OUTLINE",
            frameAnchor = "LEFT",
            anchorToHealthBar = true,
            offsetX = 4,
            offsetY = 0,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "LEFT",
            vAlign = "MIDDLE",
        },
        levelText = {
            enabled = false,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 0,
            showClassification = false,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 38,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 20,
            anchor = "CENTER",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = 10,
        },
        castBar = {
            enabled = false,
            height = 10,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",
            offsetY = 0,
        },
        defensiveIcon = {
            enabled = true,
            size = 28,
            scale = 1.0,
            anchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            showBorder = true,
            borderSize = 2,
            borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
            showCooldown = true,
            showSwipe = true,
            showDuration = true,
        showDurationText = false,
        },
        dispelOverlay = {
            enabled = true,
            fillAlpha = 0.5,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 3,
            glowAlpha = 0.25,
            showPulse = true,
            onlyPlayerDispellable = false,
            showBleed = false,
            showEnrage = false,
        },
        threatOverlay = {
            enabled = false,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 4,
            glowAlpha = 0.3,
            showPulse = true,
            
            onlyTanking = false,
            
        },
    },
    
    -- Classic Style - Traditional WoW look with portrait
    classic = {
        name = "Classic",
        description = "Traditional WoW-style frames with portrait",
        frame = {
            width = 240,
            height = 48,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0, 0, 0, 0.9 },
            showBorder = true,
            borderColor = { 0.6, 0.5, 0.3, 1 },
            borderSize = 2,
            padding = 2,
            barSpacing = 2,
            bgExtendTop = 16,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 30,
            texture = "Blizzard",
            colorMode = "green",
            customColor = { 0, 0.8, 0, 1 },
            bgColor = { 0.2, 0.2, 0.2, 0.9 },
        },
        powerBar = {
            enabled = true,
            height = 12,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.15, 0.15, 0.15, 0.9 },
        },
        healthText = {
            enabled = true,
            format = "current_max",
            abbreviate = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = false,
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = true,
            format = "current",
            abbreviate = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 12,
            fontOutline = "OUTLINE",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = -12,
            colorMode = "white",
            customColor = { 1, 0.82, 0, 1 },
            hAlign = "CENTER",
        },
        levelText = {
            enabled = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPLEFT",
            offsetX = 4,
            offsetY = -12,
            showClassification = true,
            hideAtMaxLevel = false,
            hAlign = "LEFT",
        },
        portrait = {
            enabled = true,
            mode = "2d",
            size = 48,
            position = "left",
            outside = true,
            offsetX = -50,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 24,
            anchor = "CENTER",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = 12,
        },
        castBar = {
            enabled = false,
            height = 12,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
            attachedTo = "bottom",
            offsetY = 0,
        },
        defensiveIcon = {
            enabled = true,
            size = 28,
            scale = 1.0,
            anchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            showBorder = true,
            borderSize = 2,
            borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
            showCooldown = true,
            showSwipe = true,
            showDuration = true,
        showDurationText = false,
        },
        dispelOverlay = {
            enabled = true,
            fillAlpha = 0.5,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 3,
            glowAlpha = 0.25,
            showPulse = true,
            onlyPlayerDispellable = false,
            showBleed = false,
            showEnrage = false,
        },
        threatOverlay = {
            enabled = false,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 4,
            glowAlpha = 0.3,
            showPulse = true,
            
            onlyTanking = false,
            
        },
    },
    
    -- Compact Style - Small and space-efficient
    compact = {
        name = "Compact",
        description = "Small space-efficient bars for minimal screen usage",
        frame = {
            width = 140,
            height = 22,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.05, 0.05, 0.05, 0.85 },
            showBorder = true,
            borderColor = { 0, 0, 0, 1 },
            borderSize = 1,
            padding = 1,
            barSpacing = 1,
            bgExtendTop = 0,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 16,
            texture = "Blizzard",
            colorMode = "class",
            customColor = { 0.2, 0.8, 0.2, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.7 },
        },
        powerBar = {
            enabled = true,
            height = 3,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.1, 0.1, 0.1, 0.6 },
        },
        healthText = {
            enabled = true,
            format = "percent",
            abbreviate = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            offsetX = -2,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = true,
            hAlign = "RIGHT",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "none",
            abbreviate = true,
            fontSize = 8,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            frameAnchor = "LEFT",
            anchorToHealthBar = true,
            offsetX = 2,
            offsetY = 0,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "LEFT",
            vAlign = "MIDDLE",
        },
        levelText = {
            enabled = false,
            fontSize = 8,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 0,
            showClassification = false,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 20,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 14,
            anchor = "CENTER",
            frameAnchor = "LEFT",
            offsetX = -8,
            offsetY = 0,
        },
        castBar = {
            enabled = false,
            height = 8,
            showIcon = true,
            showTimer = true,
            showSpellName = false,
            attachedTo = "bottom",
            offsetY = 0,
        },
        defensiveIcon = {
            enabled = true,
            size = 20,
            scale = 1.0,
            anchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            showBorder = true,
            borderSize = 1,
            borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
            showCooldown = true,
            showSwipe = true,
            showDuration = false,
        showDurationText = false,
        },
        dispelOverlay = {
            enabled = true,
            fillAlpha = 0.5,
            showBorder = true,
            borderSize = 1,
            borderAlpha = 0.9,
            showGlow = false,
            glowSize = 2,
            glowAlpha = 0.2,
            showPulse = true,
            onlyPlayerDispellable = false,
            showBleed = false,
            showEnrage = false,
        },
        threatOverlay = {
            enabled = false,
            showBorder = true,
            borderSize = 1,
            borderAlpha = 0.9,
            showGlow = false,
            glowSize = 2,
            glowAlpha = 0.2,
            showPulse = true,
            
            onlyTanking = false,
            
        },
    },
    
    -- Healer Style - Optimized for healing with prominent health bars
    healer = {
        name = "Healer",
        description = "Large health bars optimized for healing and health monitoring",
        frame = {
            width = 180,
            height = 50,
            scale = 1.0,
            autoSize = true,
            showBackground = true,
            bgColor = { 0.02, 0.02, 0.02, 0.92 },
            showBorder = true,
            borderColor = { 0.2, 0.2, 0.2, 1 },
            borderSize = 1,
            padding = 2,
            barSpacing = 1,
            bgExtendTop = 0,
            bgExtendBottom = 0,
        },
        healthBar = {
            enabled = true,
            height = 40,
            texture = "Blizzard Raid Bar",
            colorMode = "class",
            customColor = { 0.2, 0.8, 0.2, 1 },
            bgColor = { 0.08, 0.08, 0.08, 0.9 },
        },
        powerBar = {
            enabled = true,
            height = 5,
            texture = "Blizzard",
            colorMode = "power",
            customColor = { 0, 0.5, 1, 1 },
            bgColor = { 0.06, 0.06, 0.06, 0.8 },
        },
        healthText = {
            enabled = true,
            format = "deficit",
            abbreviate = true,
            fontSize = 12,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            colorByHealth = true,
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        powerText = {
            enabled = false,
            format = "none",
            abbreviate = true,
            fontSize = 8,
            fontOutline = "OUTLINE",
            offsetX = 0,
            offsetY = 0,
            color = { 1, 1, 1, 1 },
            hAlign = "CENTER",
            vAlign = "MIDDLE",
        },
        nameText = {
            enabled = true,
            fontSize = 10,
            fontOutline = "OUTLINE",
            frameAnchor = "TOP",
            anchorToHealthBar = true,
            offsetX = 0,
            offsetY = -2,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "CENTER",
        },
        levelText = {
            enabled = false,
            fontSize = 9,
            fontOutline = "OUTLINE",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 0,
            showClassification = false,
            hideAtMaxLevel = true,
            hAlign = "RIGHT",
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 40,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 18,
            anchor = "CENTER",
            frameAnchor = "TOPRIGHT",
            offsetX = 0,
            offsetY = 0,
        },
        debuffIndicators = {
            enabled = true,
            showMagic = true,
            showCurse = true,
            showDisease = true,
            showPoison = true,
            showBleed = false,
            size = 16,
            style = "squares",
            position = "BOTTOMRIGHT",
            offsetX = -2,
            offsetY = 2,
            showBorder = true,
        },
        castBar = {
            enabled = false,
            height = 8,
            showIcon = true,
            showTimer = true,
            showSpellName = false,
        },
        defensiveIcon = {
            enabled = true,
            size = 32,
            scale = 1.0,
            anchor = "CENTER",
            offsetX = 0,
            offsetY = 0,
            showBorder = true,
            borderSize = 2,
            borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
            showCooldown = true,
            showSwipe = true,
            showDuration = true,
        showDurationText = false,
        },
        dispelOverlay = {
            enabled = true,
            fillAlpha = 0.5,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 4,
            glowAlpha = 0.3,
            showPulse = true,
            onlyPlayerDispellable = false,
            showBleed = false,
            showEnrage = false,
        },
        threatOverlay = {
            enabled = false,
            showBorder = true,
            borderSize = 2,
            borderAlpha = 0.9,
            showGlow = true,
            glowSize = 5,
            glowAlpha = 0.35,
            showPulse = true,
            
            onlyTanking = false,
            
        },
    },
}

-- Shared raid frame visual defaults (used by both small and large)
local RAID_FRAME_VISUAL_DEFAULTS = {
    frame = {
        width = 72,
        height = 36,
        showBackground = true,
        showBorder = true,
        borderSize = 1,
        bgColor = { 0.05, 0.05, 0.05, 0.9 },
        borderColor = { 0, 0, 0, 1 },
    },
    healthBar = {
        height = 24,
        texture = "Blizzard",
        colorMode = "class",
        customColor = { 0.2, 0.8, 0.2, 1 },
        showAbsorbBar = false,
    },
    powerBar = {
        enabled = true,
        height = 6,
        texture = "Blizzard",
    },
    healthText = {
        enabled = false,
        format = "percent",
        fontSize = 9,
        fontOutline = "OUTLINE",
        position = "CENTER",
        offsetX = 0,
        offsetY = 0,
    },
    powerText = {
        enabled = false,
        format = "none",
        fontSize = 8,
        fontOutline = "OUTLINE",
    },
    nameText = {
        enabled = true,
        fontSize = 10,
        fontOutline = "OUTLINE",
        frameAnchor = "LEFT",
        anchorToHealthBar = true,
        offsetX = 2,
        offsetY = 0,
        colorMode = "class",
        customColor = { 1, 1, 1, 1 },
        hAlign = "LEFT",
        vAlign = "MIDDLE",
        maxLength = 8,
    },
    portrait = {
        enabled = false,
        mode = "none",
        size = 20,
        position = "left",
        outside = false,
        offsetX = 0,
        offsetY = 0,
    },
    raidTarget = {
        enabled = true,
        size = 14,
        anchor = "CENTER",
        frameAnchor = "TOP",
        offsetX = 0,
        offsetY = -2,
    },
    roleIcon = {
        enabled = true,
        size = 12,
        anchor = "CENTER",
        frameAnchor = "TOPLEFT",
        offsetX = 1,
        offsetY = -1,
    },
    debuffIndicators = {
        enabled = true,
        showMagic = true,
        showCurse = true,
        showDisease = true,
        showPoison = true,
        showBleed = false,
        size = 10,
        style = "squares",  -- "squares", "icons", or "both"
        position = "BOTTOMRIGHT",
        offsetX = -1,
        offsetY = 1,
        showBorder = true,
    },
    castBar = {
        enabled = false,
        height = 6,
        showIcon = true,
        showTimer = true,
        showSpellName = true,
    },
    defensiveIcon = {
        enabled = true,
        size = 20,
        scale = 1.0,
        anchor = "CENTER",
        offsetX = 0,
        offsetY = 0,
        showBorder = true,
        borderSize = 1,
        borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
        showCooldown = true,
        showSwipe = true,
        showDuration = false,
        showDurationText = false,
    },
    dispelOverlay = {
        enabled = true,
            fillAlpha = 0.5,
        showBorder = true,
        borderSize = 1,
        borderAlpha = 0.9,
        showGlow = false,
        glowSize = 2,
        glowAlpha = 0.2,
        showPulse = true,
        onlyPlayerDispellable = false,
        showBleed = false,
        showEnrage = false,
    },
    threatOverlay = {
        enabled = false,
        showBorder = true,
        borderSize = 1,
        borderAlpha = 0.9,
        showGlow = false,
        glowSize = 2,
        glowAlpha = 0.2,
        showPulse = true,
        
        onlyTanking = false,
        
    },
    -- Aura display (buffs/debuffs icons)
    buffs = {
        enabled = false,  -- Disabled by default for raid frames (too many players)
        maxAuras = 4,
        size = 14,
        spacing = 1,
        growDirection = "RIGHT",
        anchor = "BOTTOMLEFT",
        frameAnchor = "TOPLEFT",
        offsetX = 0,
        offsetY = 1,
        filter = "HELPFUL|PLAYER",  -- Only player-cast buffs by default
        hidePermanent = true,
        sortRule = "Default",
        sortDirection = "Normal",
        showDuration = true,
        showDurationText = false,
        sweepAlpha = 1.0,
        showDurationText = true,
        durationFontSize = 10,
        durationAnchor = "CENTER",
        durationOffsetX = 0,
        durationOffsetY = 0,
        durationColor = { 1, 1, 0.6, 1 },
        durationFont = nil,  -- nil = use global/default font
        durationOutline = "OUTLINE",  -- "", "OUTLINE", "THICKOUTLINE"
        showStacks = true,
        stackFontSize = 10,
        showBorder = true,
    },
    debuffs = {
        enabled = false,  -- Disabled by default
        maxAuras = 3,
        size = 16,
        spacing = 1,
        growDirection = "RIGHT",
        anchor = "TOPLEFT",
        frameAnchor = "BOTTOMLEFT",
        offsetX = 0,
        offsetY = -1,
        filter = "HARMFUL",
        hidePermanent = true,
        sortRule = "Default",
        sortDirection = "Normal",
        showDuration = true,
        showDurationText = false,
        sweepAlpha = 1.0,
        showDurationText = true,
        durationFontSize = 10,
        durationAnchor = "CENTER",
        durationOffsetX = 0,
        durationOffsetY = 0,
        durationColor = { 1, 1, 0.6, 1 },
        durationFont = nil,  -- nil = use global/default font
        durationOutline = "OUTLINE",  -- "", "OUTLINE", "THICKOUTLINE"
        showStacks = true,
        stackFontSize = 10,
        showBorder = true,
        colorByDispelType = true,
    },
    rangeCheck = {
        enabled = true,
        outOfRangeAlpha = 0.4,
        updateInterval = 0.2,   -- How often to check range (seconds)
        useSmoothFade = true,   -- Smooth alpha transition
        fadeSpeed = 0.3,        -- Speed of fade transition
    },
    summonIndicator = {
        enabled = true,
        size = 16,
        anchor = "CENTER",
        frameAnchor = "CENTER",
        offsetX = 0,
        offsetY = 0,
        pendingColor = { 1, 0.8, 0, 1 },    -- Yellow/orange for pending
        acceptedColor = { 0, 1, 0, 1 },      -- Green for accepted
    },
    highlightDispellable = true,
    showOffline = true,
    showDead = true,
}

-- Raid frames master settings
local RAID_DEFAULTS = {
    enabled = false,
    sizeThreshold = 20,  -- Use small layout for <= this many players, large for more
    
    -- Small raid layout (10-20 players)
    small = {
        container = {
            x = -300,
            y = 100,
            anchor = "CENTER",
            scale = 1.0,
        },
        layout = {
            mode = "GRID",  -- GRID, GROUP_ROWS, or GROUP_COLUMNS
            -- GRID mode: arrange all players in a simple grid (ignores group boundaries)
            columns = 5,    -- Number of columns
            spacing = 2,
            growthDirection = "DOWN",  -- How to fill: DOWN, UP, RIGHT, LEFT
            
            -- GROUP modes: arrange by party group
            groupsPerRow = 4,     -- For GROUP_ROWS: groups per row before wrapping down
            groupsPerColumn = 2,  -- For GROUP_COLUMNS: groups per column before wrapping right
            groupSpacing = 8,     -- Space between groups
            
            -- Within each group
            membersPerRow = 5,    -- Members per row within a group (1 = vertical column)
            memberGrowth = "DOWN", -- How members fill within group: DOWN, RIGHT
        },
        sorting = {
            enabled = true,
            sortByRole = true,
            separateMeleeRanged = false,
            sortByClass = false,
            sortAlphabetically = true,
            sortByGroup = true,  -- Keep group order for raids
            selfPosition = "NORMAL",
        },
        rangeFade = {
            enabled = true,
            checkInterval = 0.2,
            outOfRangeAlpha = 0.4,
            perElementFade = true,
        },
        healPrediction = {
            enabled = true,
            showMyHeals = true,
            showOtherHeals = true,
            separateColors = false,
            myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
            otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
            allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
            showAbsorbs = true,
            absorbColor = { 0.8, 0.8, 0.2, 0.6 },
            absorbOverlay = true,
        },
        -- Visual settings (copied from shared defaults)
        frame = nil,  -- Will be filled from RAID_FRAME_VISUAL_DEFAULTS
        healthBar = nil,
        powerBar = nil,
        healthText = nil,
        powerText = nil,
        nameText = nil,
        portrait = nil,
        raidTarget = nil,
        roleIcon = nil,
        debuffIndicators = nil,
        rangeCheck = nil,
        highlightDispellable = true,
        showOffline = true,
        showDead = true,
    },
    
    -- Large raid layout (21-40 players)
    large = {
        container = {
            x = -300,
            y = -100,
            anchor = "CENTER",
            scale = 0.9,
        },
        layout = {
            mode = "GROUP_ROWS",  -- Default to group rows for large raids
            columns = 8,
            spacing = 1,
            growthDirection = "DOWN",
            
            groupsPerRow = 8,
            groupsPerColumn = 4,
            groupSpacing = 4,
            
            membersPerRow = 5,
            memberGrowth = "DOWN",
        },
        sorting = {
            enabled = true,
            sortByRole = true,
            separateMeleeRanged = false,
            sortByClass = false,
            sortAlphabetically = true,
            sortByGroup = true,  -- Keep group order for raids
            selfPosition = "NORMAL",
        },
        rangeFade = {
            enabled = true,
            checkInterval = 0.2,
            outOfRangeAlpha = 0.4,
            perElementFade = false,  -- Simpler fade for large raids
        },
        healPrediction = {
            enabled = true,
            showMyHeals = true,
            showOtherHeals = true,
            separateColors = false,
            myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
            otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
            allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
            showAbsorbs = true,
            absorbColor = { 0.8, 0.8, 0.2, 0.6 },
            absorbOverlay = false,  -- Disabled by default for large raids (performance)
        },
        -- Visual settings - slightly smaller for large raids
        frame = {
            width = 60,
            height = 30,
            showBackground = true,
            showBorder = true,
            borderSize = 1,
            bgColor = { 0.05, 0.05, 0.05, 0.9 },
            borderColor = { 0, 0, 0, 1 },
        },
        healthBar = {
            height = 20,
            texture = "Blizzard",
            colorMode = "class",
            customColor = { 0.2, 0.8, 0.2, 1 },
            showAbsorbBar = false,
        },
        powerBar = {
            enabled = true,
            height = 4,
            texture = "Blizzard",
        },
        healthText = {
            enabled = false,
            format = "percent",
            fontSize = 8,
            fontOutline = "OUTLINE",
            position = "CENTER",
            offsetX = 0,
            offsetY = 0,
        },
        powerText = {
            enabled = false,
            format = "none",
            fontSize = 7,
            fontOutline = "OUTLINE",
        },
        nameText = {
            enabled = true,
            fontSize = 9,
            fontOutline = "OUTLINE",
            frameAnchor = "LEFT",
            anchorToHealthBar = true,
            offsetX = 2,
            offsetY = 0,
            colorMode = "class",
            customColor = { 1, 1, 1, 1 },
            hAlign = "LEFT",
            vAlign = "MIDDLE",
            maxLength = 6,  -- Shorter names for compact display
        },
        portrait = {
            enabled = false,
            mode = "none",
            size = 16,
            position = "left",
            outside = false,
            offsetX = 0,
            offsetY = 0,
        },
        raidTarget = {
            enabled = true,
            size = 12,
            anchor = "CENTER",
            frameAnchor = "TOP",
            offsetX = 0,
            offsetY = -1,
        },
        roleIcon = {
            enabled = true,
            size = 10,
            anchor = "CENTER",
            frameAnchor = "TOPLEFT",
            offsetX = 1,
            offsetY = -1,
        },
        debuffIndicators = {
            enabled = true,
            onlyPlayerDispellable = false,
            showMagic = true,
            showCurse = true,
            showDisease = true,
            showPoison = true,
            showBleed = false,
            size = 8,
            position = "BOTTOMRIGHT",
            offsetX = -1,
            offsetY = 1,
            showBorder = true,
        },
        rangeCheck = {
            enabled = true,
            outOfRangeAlpha = 0.4,
        },
        highlightDispellable = true,
        showOffline = true,
        showDead = true,
    },
}

-- Tank frames settings (separate container for tanks only)
local TANK_DEFAULTS = {
    enabled = false,
    showMainTank = true,      -- Show players marked as Main Tank
    showMainAssist = true,    -- Show players marked as Main Assist
    showRoleTanks = true,     -- Show players with Tank role assigned
    maxTanks = 4,             -- Maximum tanks to show
    
    container = {
        x = -400,
        y = 200,
        anchor = "CENTER",
        scale = 1.0,
    },
    layout = {
        direction = "DOWN",   -- DOWN, UP, RIGHT, LEFT
        spacing = 2,
    },
    frame = {
        width = 120,
        height = 40,
        showBackground = true,
        showBorder = true,
        borderSize = 1,
        bgColor = { 0.05, 0.05, 0.05, 0.9 },
        borderColor = { 0.3, 0.3, 0.3, 1 },
    },
    healthBar = {
        height = 28,
        colorMode = "class",  -- "class", "health", "custom"
        customColor = { 0.2, 0.8, 0.2, 1 },
        bgColor = { 0.1, 0.1, 0.1, 0.8 },
    },
    powerBar = {
        enabled = true,
        height = 6,
    },
    nameText = {
        enabled = true,
        fontSize = 11,
        fontOutline = "OUTLINE",
        colorMode = "class",
        maxLength = 12,
    },
    healthText = {
        enabled = true,
        fontSize = 10,
        format = "percent",  -- "percent", "current", "deficit"
    },
    roleIcon = {
        enabled = true,
        size = 14,
        position = "TOPLEFT",
        offsetX = 1,
        offsetY = -1,
    },
    raidTarget = {
        enabled = true,
        size = 16,
        position = "RIGHT",
        offsetX = -2,
        offsetY = 0,
    },
    debuffIndicators = {
        enabled = true,
        onlyPlayerDispellable = false,
        size = 8,
        style = "squares",  -- "squares", "icons", or "both"
        position = "BOTTOMRIGHT",
        offsetX = -1,
        offsetY = 1,
        showMagic = true,
        showCurse = true,
        showDisease = true,
        showPoison = true,
    },
    rangeCheck = {
        enabled = true,
        outOfRangeAlpha = 0.4,
        updateInterval = 0.2,
        useSmoothFade = true,
        fadeSpeed = 0.3,
    },
    castBar = {
        enabled = false,
        height = 8,
        showIcon = true,
        showTimer = true,
        showSpellName = true,
    },
    -- Visibility settings (per-frame)
    visibility = {
        enabled = false,
        combat = false,
        mouseover = false,
        target = false,
        group = false,
        instance = false,
        instanceTypes = {},
        fadeAlpha = 0,
    },
}

-- Boss frame defaults
local BOSS_DEFAULTS = {
    enabled = false,
    maxBosses = 5,            -- Maximum boss frames to show (boss1-boss5)
    
    container = {
        x = 400,
        y = 200,
        anchor = "CENTER",
        scale = 1.0,
    },
    layout = {
        direction = "DOWN",   -- DOWN, UP, RIGHT, LEFT
        spacing = 2,
    },
    frame = {
        width = 180,
        height = 50,
        showBackground = true,
        showBorder = true,
        borderSize = 1,
        bgColor = { 0.05, 0.05, 0.05, 0.9 },
        borderColor = { 0.5, 0.1, 0.1, 1 },  -- Reddish border for bosses
    },
    healthBar = {
        height = 36,
        colorMode = "custom",  -- "class", "health", "custom"
        customColor = { 0.8, 0.2, 0.2, 1 },  -- Red for bosses
        bgColor = { 0.1, 0.1, 0.1, 0.8 },
    },
    powerBar = {
        enabled = true,
        height = 8,
    },
    nameText = {
        enabled = true,
        fontSize = 12,
        fontOutline = "OUTLINE",
        colorMode = "custom",
        customColor = { 1, 0.8, 0.2, 1 },  -- Gold color
        maxLength = 20,
    },
    healthText = {
        enabled = true,
        fontSize = 11,
        format = "percent",  -- "percent", "current", "deficit"
    },
    raidTarget = {
        enabled = true,
        size = 20,
        position = "LEFT",
        offsetX = 2,
        offsetY = 0,
    },
    castBar = {
        enabled = true,
        height = 10,
        showIcon = true,
        showTimer = true,
    },
    -- Visibility settings (per-frame)
    visibility = {
        enabled = false,
        combat = false,
        mouseover = false,
        target = false,
        group = false,
        instance = false,
        instanceTypes = {},
        fadeAlpha = 0,
    },
}

-- ============================================================================
-- MODULE STATE
-- ============================================================================

-- settings, partyMemberFrames, raidSmallMemberFrames, raidLargeMemberFrames, tankMemberFrames
-- are forward-declared earlier in RANGE CHECKING SYSTEM section

local unitFramesHub = nil
local settingsPanels = {}
customFrames = {}  -- Forward declared at top of file
local pendingLayoutUpdates = {}  -- Units that need layout update after combat
local LibSharedMedia = nil
-- LibEditMode is now managed by TweaksUI.EditMode (Core/EditModeManager.lua)
local LibEditMode = nil  -- Keep for backward compatibility with any remaining references
local eventFrame = nil

-- Blizzard frame state tracking (consolidated to reduce local count)
-- Module-level state table (converted from local to avoid 200 local variable limit)
UnitFrames.BlizzState = {
    framesMasked = {},           -- Tracks which Blizzard frames are masked
    castBarHidden = false,       -- Whether Blizzard cast bars are hidden
    partyHooked = false,         -- Whether party frame hooks are set
    partySelectionHooked = false, -- Whether party selection hooks are set
}

-- Helper function for getting spell texture (modern API)
local function GetSpellTextureByID(spellID)
    if not spellID then return nil end
    -- Modern API (Dragonflight+)
    if C_Spell and C_Spell.GetSpellTexture then
        return C_Spell.GetSpellTexture(spellID)
    end
    -- Fallback for older API
    local _, _, texture = GetSpellInfo(spellID)
    return texture
end

-- Party container state
local partyContainer = nil
-- partyMemberFrames declared earlier

-- Raid container state - two sets for small/large raids
local raidSmallContainer = nil
local raidLargeContainer = nil
-- raidSmallMemberFrames, raidLargeMemberFrames declared earlier
local activeRaidSize = "small"  -- Which layout is currently active

-- Tank container state
local tankContainer = nil
-- tankMemberFrames declared earlier

-- Boss container state
local bossContainer = nil
local bossMemberFrames = {}  -- { [index] = frame } for bosses (1-5)
local pendingBossUnitWatchUpdate = false  -- Flag to update unit watches after combat

-- Currently open settings panel (for preview mode)
local currentOpenPanel = nil

-- Preview/Simulation modes - separate for each frame type
local previewPlayer = false  -- Preview player frame (for auras in test mode)
local previewTarget = false  -- Preview target frame
local previewFocus = false   -- Preview focus frame
local previewToT = false     -- Preview target of target frame
local previewPet = false     -- Preview pet frame
local previewParty = false   -- Preview party frames
local simulateRaidSmall = false  -- Simulate small raid layout
local simulateRaidLarge = false  -- Simulate large raid layout
local simulateTanks = false  -- Simulate tank frames
local simulateBoss = false   -- Simulate boss frames

-- Reusable caches to avoid table allocations in hot paths (PERFORMANCE)
local raidAuraCache = {}
local debuffsFoundCache = {}      -- For GetUnitData
local debuffsFoundCache2 = {}     -- For UpdatePartyMemberFrame
local debuffsFoundCache3 = {}     -- For UpdateRaidMemberFrame
local unitAurasCache = {}
local partyAurasCache = {}        -- For party frame aura collection
local sortedDebuffsCache = {}

-- Individual unit types (non-group frames)
local INDIVIDUAL_UNITS = {"player", "target", "focus", "targettarget", "pet"}

-- Helper function to check if preview is enabled for a specific unit
local function IsPreviewEnabled(unit)
    if unit == "player" then return previewPlayer
    elseif unit == "target" then return previewTarget
    elseif unit == "focus" then return previewFocus
    elseif unit == "targettarget" then return previewToT
    elseif unit == "pet" then return previewPet
    end
    return false
end

-- TUIFrame wrappers for Layout integration
local unitFrameWrappers = {}  -- { [unit] = TUIFrame instance }
-- containerWrappers is a module property to avoid 200 local variable limit
UnitFrames.containerWrappers = {}  -- { [containerType] = TUIFrame instance }
local containerWrappers = UnitFrames.containerWrappers  -- Local shortcut
local layoutIntegrationEnabled = false

-- Panel constants
local HUB_WIDTH = 220
local PANEL_WIDTH = 420
local BUTTON_HEIGHT = 28
local BUTTON_SPACING = 4

-- Dark backdrop template
local darkBackdrop = {
    bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background-Dark",
    edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
    tile = true, tileSize = 32, edgeSize = 32,
    insets = { left = 8, right = 8, top = 8, bottom = 8 }
}

-- Simple flat backdrop for custom frames
local frameBackdrop = {
    bgFile = "Interface\\Buttons\\WHITE8X8",
    edgeFile = "Interface\\Buttons\\WHITE8X8",
    edgeSize = 1,
    insets = { left = 0, right = 0, top = 0, bottom = 0 }
}

-- ============================================================================
-- BLIZZARD FRAME REFERENCES
-- ============================================================================

local BLIZZARD_FRAMES = {
    player = function() return PlayerFrame end,
    target = function() return TargetFrame end,
    focus = function() return FocusFrame end,
    targettarget = function() return TargetFrameToT end,
    focustarget = function() return FocusFrameToT end,
    pet = function() return PetFrame end,
    party1 = function() return PartyFrame and PartyFrame.MemberFrame1 end,
    party2 = function() return PartyFrame and PartyFrame.MemberFrame2 end,
    party3 = function() return PartyFrame and PartyFrame.MemberFrame3 end,
    party4 = function() return PartyFrame and PartyFrame.MemberFrame4 end,
}

-- Simulated data for unit frames
local SIMULATED_UNITS = {
    player = { name = "Simulated Player", class = "WARRIOR", health = 85000, maxHealth = 100000, power = 80, maxPower = 100, powerType = 1, level = 80, role = "TANK", debuffType = "Magic", absorb = 20000 },
    target = { name = "Target Dummy", class = "MAGE", health = 45000, maxHealth = 100000, power = 12000, maxPower = 20000, powerType = 0, level = 80, role = "DAMAGER", debuffType = "Poison", absorb = 15000 },
    focus = { name = "Focus Target", class = "PRIEST", health = 72000, maxHealth = 90000, power = 45000, maxPower = 60000, powerType = 0, level = 80, role = "HEALER", debuffType = "Curse", absorb = 10000 },
    targettarget = { name = "ToT Unit", class = "ROGUE", health = 30000, maxHealth = 50000, power = 100, maxPower = 100, powerType = 3, level = 79, role = "DAMAGER", debuffType = "Disease", absorb = 5000 },
    pet = { name = "Pet", class = "HUNTER", health = 25000, maxHealth = 40000, power = 100, maxPower = 100, powerType = 2, level = 80, role = "NONE", debuffType = "Magic", absorb = 0 },
    party1 = { name = "Party Tank", class = "PALADIN", health = 95000, maxHealth = 100000, power = 30000, maxPower = 50000, powerType = 0, level = 80, role = "TANK", debuffType = nil, absorb = 25000 },
    party2 = { name = "Party Healer", class = "DRUID", health = 60000, maxHealth = 85000, power = 70000, maxPower = 80000, powerType = 0, level = 80, role = "HEALER", debuffType = "Magic", absorb = 12000 },
    party3 = { name = "Party DPS", class = "SHAMAN", health = 40000, maxHealth = 75000, power = 35000, maxPower = 60000, powerType = 0, level = 80, role = "DAMAGER", debuffType = "Poison", absorb = 8000 },
    party4 = { name = "Party Rogue", class = "ROGUE", health = 88000, maxHealth = 110000, power = 100, maxPower = 100, powerType = 3, level = 80, role = "DAMAGER", debuffType = "Curse", absorb = 0 },
}

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

local function AbbreviateNumber(value)
    -- Use Blizzard's AbbreviateLargeNumbers if available (handles secret values)
    if AbbreviateLargeNumbers then
        return AbbreviateLargeNumbers(value) or "0"
    end
    
    -- Fallback with pcall
    local success, result = pcall(function()
        local v = value + 0
        if v >= 1000000000 then
            return string.format("%.1fB", v / 1000000000)
        elseif v >= 1000000 then
            return string.format("%.1fM", v / 1000000)
        elseif v >= 10000 then
            return string.format("%.1fK", v / 1000)
        else
            return tostring(math.floor(v))
        end
    end)
    return success and result or "0"
end

local function FormatNumber(value)
    -- Use Blizzard's BreakUpLargeNumbers if available (handles secret values)
    if BreakUpLargeNumbers then
        return BreakUpLargeNumbers(value) or "0"
    end
    
    -- Fallback with pcall
    local success, result = pcall(function()
        local v = value + 0
        local formatted = tostring(math.floor(v))
        while true do
            formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
            if k == 0 then break end
        end
        return formatted
    end)
    return success and result or "0"
end

-- Helper function to apply duration font size to Blizzard's cooldown countdown text
-- The CooldownFrameTemplate has a FontString for the countdown that we need to find and modify
-- Stored in API table to avoid exceeding 200 local variable limit
API.ApplyCooldownTextSettings = function(cooldown, fontSize, color, anchor, offsetX, offsetY)
    if not cooldown then return end
    
    pcall(function()
        -- Find the countdown text FontString inside the cooldown frame
        local cdText = cooldown.Text or cooldown.text
        if not cdText then
            -- Search regions for FontString
            for i = 1, cooldown:GetNumRegions() do
                local region = select(i, cooldown:GetRegions())
                if region and region:GetObjectType() == "FontString" then
                    cdText = region
                    -- Cache it for future use
                    cooldown.Text = cdText
                    break
                end
            end
        end
        
        if cdText then
            -- Apply font size
            if cdText.GetFont and cdText.SetFont then
                local fontPath, _, fontFlags = cdText:GetFont()
                if fontPath then
                    cdText:SetFont(fontPath, fontSize or 10, fontFlags or "OUTLINE")
                end
            end
            
            -- Apply color if provided
            if color and cdText.SetTextColor then
                cdText:SetTextColor(color[1] or 1, color[2] or 1, color[3] or 1, color[4] or 1)
            end
            
            -- Apply anchor/offset if provided
            if anchor and cdText.ClearAllPoints then
                cdText:ClearAllPoints()
                cdText:SetPoint(anchor, cooldown, anchor, offsetX or 0, offsetY or 0)
            end
        end
    end)
end

local function GetClassColor(unit)
    if not UnitExists(unit) then return 0.5, 0.5, 0.5 end
    
    -- For pets, use owner's class color
    if unit == "pet" or unit == "playerpet" then
        local _, playerClass = UnitClass("player")
        if type(playerClass) == "string" and playerClass ~= "" then
            local color = RAID_CLASS_COLORS[playerClass]
            if color then return color.r, color.g, color.b end
        end
    end
    
    local isPlayer = UnitIsPlayer(unit)
    if type(isPlayer) == "boolean" and isPlayer then
        local _, class = UnitClass(unit)
        if type(class) == "string" and class ~= "" then
            local color = RAID_CLASS_COLORS[class]
            if color then return color.r, color.g, color.b end
        end
    end
    
    return 0.5, 0.5, 0.5
end

local function GetReactionColor(unit)
    if not UnitExists(unit) then return 0.5, 0.5, 0.5 end
    
    local isPlayer = UnitIsPlayer(unit)
    if type(isPlayer) == "boolean" and isPlayer then
        return GetClassColor(unit)
    end
    
    local reaction = UnitReaction(unit, "player")
    if type(reaction) ~= "number" then return 0.5, 0.5, 0.5 end
    
    if reaction <= 2 then
        return 1, 0, 0
    elseif reaction == 3 then
        return 1, 0.5, 0
    elseif reaction == 4 then
        return 1, 1, 0
    else
        return 0, 1, 0
    end
end

local function GetHealthGradientColor(percent)
    -- Ensure percent is a valid number
    if type(percent) ~= "number" then percent = 0 end
    
    if percent > 0.5 then
        local factor = (percent - 0.5) * 2
        return 1 - factor, 1, 0
    else
        local factor = percent * 2
        return 1, factor, 0
    end
end

local function GetPowerColor(unit)
    if not UnitExists(unit) then return 0.5, 0.5, 0.5 end
    
    local powerType = UnitPowerType(unit)
    if type(powerType) == "number" and Constants.POWER_COLORS[powerType] then
        return unpack(Constants.POWER_COLORS[powerType])
    end
    
    return 0, 0.5, 1
end

local function FormatHealthText(current, max, percent, format, abbreviate)
    if format == "none" then return "" end
    
    -- Use pre-calculated percent if provided, otherwise try to calculate
    if type(percent) ~= "number" then percent = 0 end
    
    -- For formats that need raw values, pass them through AbbreviateNumber/FormatNumber
    -- Those functions use pcall internally to handle secret values
    local formatNum = abbreviate and AbbreviateNumber or FormatNumber
    
    if format == "current" then
        return formatNum(current)
    elseif format == "max" then
        return formatNum(max)
    elseif format == "percent" then
        return string.format("%.0f%%", percent)
    elseif format == "current_max" then
        return string.format("%s / %s", formatNum(current), formatNum(max))
    elseif format == "current_percent" then
        return string.format("%s - %.0f%%", formatNum(current), percent)
    elseif format == "percent_current" then
        return string.format("%.0f%% - %s", percent, formatNum(current))
    elseif format == "deficit" then
        -- Deficit requires arithmetic, use pcall
        local success, result = pcall(function()
            local deficit = max - current
            if deficit > 0 then
                return string.format("-%s", formatNum(deficit))
            end
            return ""
        end)
        return success and result or ""
    elseif format == "deficit_percent" then
        -- Deficit percent requires arithmetic, use pcall
        local success, result = pcall(function()
            local deficitPct = 100 - percent
            if deficitPct > 0 then
                return string.format("-%.0f%%", deficitPct)
            end
            return ""
        end)
        return success and result or ""
    end
    
    return formatNum(current)
end

local function GetClassificationString(unit)
    if not UnitExists(unit) then return "" end
    
    local classification = UnitClassification(unit)
    if type(classification) ~= "string" then return "" end
    
    if classification == "worldboss" then
        return "|cffFF0000Boss|r "
    elseif classification == "rareelite" then
        return "|cffFF66FFRare+|r "
    elseif classification == "elite" then
        return "|cffFFCC00+|r"
    elseif classification == "rare" then
        return "|cffFF66FFRare|r "
    end
    
    return ""
end

-- ============================================================================
-- BLIZZARD FRAME MASKING
-- ============================================================================

-- ============================================================================
-- OFF-SCREEN POSITIONING HELPERS
-- Instead of calling EnableMouse (which is protected and causes ADDON_ACTION_BLOCKED),
-- we move Blizzard frames off-screen to prevent mouse interaction
-- ============================================================================

-- Store original positions for frames we've moved off-screen (module-level to avoid local count)
UnitFrames.offScreenFrames = {}

-- Move a frame off-screen to prevent mouse interaction
-- This is safe because SetPoint is NOT a protected function
function UnitFrames.MoveFrameOffScreen(frame, frameKey)
    if not frame then return end
    if UnitFrames.offScreenFrames[frameKey] then return end  -- Already moved
    
    -- Store original position data
    local numPoints = frame:GetNumPoints()
    if numPoints == 0 then return end  -- Frame has no anchors, skip it
    
    local originalPoints = {}
    for i = 1, numPoints do
        local point, relativeTo, relativePoint, xOfs, yOfs = frame:GetPoint(i)
        table.insert(originalPoints, {
            point = point,
            relativeTo = relativeTo,
            relativePoint = relativePoint,
            x = xOfs,
            y = yOfs,
        })
    end
    
    UnitFrames.offScreenFrames[frameKey] = {
        frame = frame,
        originalPoints = originalPoints,
        originalAlpha = frame:GetAlpha(),
    }
    
    -- Move way off-screen (visual backup with alpha=0)
    pcall(function()
        frame:ClearAllPoints()
        frame:SetPoint("TOPLEFT", UIParent, "TOPLEFT", -10000, 10000)
        frame:SetAlpha(0)
    end)
end

-- Restore a frame from off-screen to its original position
function UnitFrames.RestoreFrameFromOffScreen(frameKey)
    local data = UnitFrames.offScreenFrames[frameKey]
    if not data then return end
    
    local frame = data.frame
    if not frame then
        UnitFrames.offScreenFrames[frameKey] = nil
        return
    end
    
    pcall(function()
        frame:ClearAllPoints()
        for _, pt in ipairs(data.originalPoints) do
            frame:SetPoint(pt.point, pt.relativeTo, pt.relativePoint, pt.x, pt.y)
        end
        frame:SetAlpha(data.originalAlpha or 1)
    end)
    
    UnitFrames.offScreenFrames[frameKey] = nil
end

-- Check if a frame is currently moved off-screen by us
function UnitFrames.IsFrameOffScreen(frameKey)
    return UnitFrames.offScreenFrames[frameKey] ~= nil
end

-- Local shortcuts for internal use
local MoveFrameOffScreen = function(frame, key) UnitFrames.MoveFrameOffScreen(frame, key) end
local RestoreFrameFromOffScreen = function(key) UnitFrames.RestoreFrameFromOffScreen(key) end
local IsFrameOffScreen = function(key) return UnitFrames.IsFrameOffScreen(key) end

-- Forward declarations removed - all calls now use UnitFrames.FunctionName() directly

-- DEPRECATED: DisableMouseRecursively - now a no-op since we use off-screen positioning
-- Kept for compatibility with any existing calls
local function DisableMouseRecursively(frame, maskedChildFrames)
    -- No longer needed - we use off-screen positioning instead
end

-- Helper function to restore mouse on all stored child frames
-- MUST be called outside combat to avoid taint
-- DEPRECATED: RestoreMouseRecursively - now a no-op since we use off-screen positioning
local function RestoreMouseRecursively(maskedChildFrames)
    -- No longer needed - we use off-screen positioning instead
end

local function MaskBlizzardFrame(unit)
    local frameFunc = BLIZZARD_FRAMES[unit]
    if not frameFunc then return end
    
    local frame = frameFunc()
    if not frame then return end
    if UnitFrames.BlizzState.framesMasked[unit] then return end
    
    UnitFrames.BlizzState.framesMasked[unit] = {
        originalAlpha = frame:GetAlpha(),
        maskedChildFrames = {},  -- Kept for compatibility but unused now
    }
    
    -- Use off-screen positioning instead of EnableMouse (avoids ADDON_ACTION_BLOCKED)
    MoveFrameOffScreen(frame, "mask_" .. unit)
    
    -- Hide Edit Mode selection if it exists
    if frame.Selection then
        pcall(function() 
            frame.Selection:SetAlpha(0)
            frame.Selection:Hide() 
        end)
    end
    
    -- Hide HighlightTexture (mouseover highlight)
    if frame.HighlightTexture then
        pcall(function()
            frame.HighlightTexture:SetAlpha(0)
            frame.HighlightTexture:Hide()
        end)
    end
    
    -- Hide MouseoverHighlight if present
    if frame.MouseoverHighlight then
        pcall(function()
            frame.MouseoverHighlight:SetAlpha(0)
            frame.MouseoverHighlight:Hide()
        end)
    end
    
    -- Hook to maintain alpha ONLY - do NOT call EnableMouse or other protected functions
    -- from within hooksecurefunc because it runs in Blizzard's secure execution chain
    if not frame._tweaksUIAlphaHook then
        hooksecurefunc(frame, "Show", function(self)
            if UnitFrames.BlizzState.framesMasked[unit] then
                -- SetAlpha is NOT protected, so this is safe
                self:SetAlpha(0)
                -- Also keep Selection and Highlights hidden
                if self.Selection then
                    pcall(function() self.Selection:SetAlpha(0) end)
                end
                if self.HighlightTexture then
                    pcall(function() self.HighlightTexture:SetAlpha(0) end)
                end
                if self.MouseoverHighlight then
                    pcall(function() self.MouseoverHighlight:SetAlpha(0) end)
                end
            end
        end)
        frame._tweaksUIAlphaHook = true
    end
    
    -- For party frames, also hook Selection and HighlightTexture directly
    if isPartyUnit then
        if frame.Selection and not frame.Selection._tuiMaskHook then
            hooksecurefunc(frame.Selection, "Show", function(self)
                if UnitFrames.BlizzState.framesMasked[unit] then
                    self:SetAlpha(0)
                end
            end)
            if frame.Selection.SetAlpha then
                local origSetAlpha = frame.Selection.SetAlpha
                hooksecurefunc(frame.Selection, "SetAlpha", function(self, alpha)
                    -- Use pcall to safely compare alpha (may be secret in Midnight)
            local isPositive = true
            pcall(function() isPositive = alpha > 0 end)
            if isPositive and UnitFrames.BlizzState.framesMasked[unit] then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                origSetAlpha(self, 0)
                            end
                        end)
                    end
                end)
            end
            frame.Selection._tuiMaskHook = true
        end
        
        if frame.HighlightTexture and not frame.HighlightTexture._tuiMaskHook then
            hooksecurefunc(frame.HighlightTexture, "Show", function(self)
                if UnitFrames.BlizzState.framesMasked[unit] then
                    self:SetAlpha(0)
                end
            end)
            if frame.HighlightTexture.SetAlpha then
                local origSetAlpha = frame.HighlightTexture.SetAlpha
                hooksecurefunc(frame.HighlightTexture, "SetAlpha", function(self, alpha)
                    -- Use pcall to safely compare alpha (may be secret in Midnight)
            local isPositive = true
            pcall(function() isPositive = alpha > 0 end)
            if isPositive and UnitFrames.BlizzState.framesMasked[unit] then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                origSetAlpha(self, 0)
                            end
                        end)
                    end
                end)
            end
            frame.HighlightTexture._tuiMaskHook = true
        end
    end
end

local function UnmaskBlizzardFrame(unit)
    local frameFunc = BLIZZARD_FRAMES[unit]
    if not frameFunc then return end
    
    local frame = frameFunc()
    if not frame then return end
    if not UnitFrames.BlizzState.framesMasked[unit] then return end
    
    -- Restore from off-screen positioning
    RestoreFrameFromOffScreen("mask_" .. unit)
    
    UnitFrames.BlizzState.framesMasked[unit] = nil
end

-- DEPRECATED: ReapplyMaskedFrameMouseState - no longer needed with off-screen positioning
local function ReapplyMaskedFrameMouseState()
    -- No longer needed - off-screen positioning doesn't require reapplication after combat
end

-- Register for PLAYER_REGEN_ENABLED to fix mouse state after combat
local maskedFrameEventFrame = CreateFrame("Frame")
maskedFrameEventFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
maskedFrameEventFrame:SetScript("OnEvent", function(self, event)
    if event == "PLAYER_REGEN_ENABLED" then
        -- Use C_Timer to defer slightly so combat is fully over
        C_Timer.After(0.1, ReapplyMaskedFrameMouseState)
    end
end)

-- Hidden frame for reparenting Edit Mode elements
local hiddenFrame = nil
local function GetHiddenFrame()
    if not hiddenFrame then
        hiddenFrame = CreateFrame("Frame")
        hiddenFrame:Hide()
    end
    return hiddenFrame
end

-- Hide Blizzard's cast bars when custom cast bars are enabled
local function HideBlizzardCastBars()
    if UnitFrames.BlizzState.castBarHidden then return end
    
    -- Player cast bar
    if PlayerCastingBarFrame then
        PlayerCastingBarFrame:SetAlpha(0)
        if not PlayerCastingBarFrame._tweaksUICastHook then
            hooksecurefunc(PlayerCastingBarFrame, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            PlayerCastingBarFrame._tweaksUICastHook = true
        end
    end
    
    -- Pet cast bar
    if PetCastingBarFrame then
        PetCastingBarFrame:SetAlpha(0)
        if not PetCastingBarFrame._tweaksUICastHook then
            hooksecurefunc(PetCastingBarFrame, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            PetCastingBarFrame._tweaksUICastHook = true
        end
    end
    
    -- Target spell bar
    if TargetFrameSpellBar then
        TargetFrameSpellBar:SetAlpha(0)
        if not TargetFrameSpellBar._tweaksUICastHook then
            hooksecurefunc(TargetFrameSpellBar, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            TargetFrameSpellBar._tweaksUICastHook = true
        end
    end
    
    -- Target-of-Target spell bar (prevents overlap with custom cast bars)
    local totSpellBar = TargetFrameToT and TargetFrameToT.SpellBar
    if totSpellBar then
        totSpellBar:SetAlpha(0)
        if not totSpellBar._tweaksUICastHook then
            hooksecurefunc(totSpellBar, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            totSpellBar._tweaksUICastHook = true
        end
    end
    if TargetFrameToTSpellBar then
        TargetFrameToTSpellBar:SetAlpha(0)
        if not TargetFrameToTSpellBar._tweaksUICastHook then
            hooksecurefunc(TargetFrameToTSpellBar, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            TargetFrameToTSpellBar._tweaksUICastHook = true
        end
    end
    
    -- Focus spell bar
    if FocusFrameSpellBar then
        FocusFrameSpellBar:SetAlpha(0)
        if not FocusFrameSpellBar._tweaksUICastHook then
            hooksecurefunc(FocusFrameSpellBar, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            FocusFrameSpellBar._tweaksUICastHook = true
        end
    end
    
    -- Focus-of-Target spell bar
    local fotSpellBar = FocusFrameToT and FocusFrameToT.SpellBar
    if fotSpellBar then
        fotSpellBar:SetAlpha(0)
        if not fotSpellBar._tweaksUICastHook then
            hooksecurefunc(fotSpellBar, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            fotSpellBar._tweaksUICastHook = true
        end
    end
    if FocusFrameToTSpellBar then
        FocusFrameToTSpellBar:SetAlpha(0)
        if not FocusFrameToTSpellBar._tweaksUICastHook then
            hooksecurefunc(FocusFrameToTSpellBar, "Show", function(self)
                if UnitFrames.BlizzState.castBarHidden then
                    self:SetAlpha(0)
                end
            end)
            FocusFrameToTSpellBar._tweaksUICastHook = true
        end
    end
    
    UnitFrames.BlizzState.castBarHidden = true
end

local function ShowBlizzardCastBars()
    if not UnitFrames.BlizzState.castBarHidden then return end
    
    if PlayerCastingBarFrame then
        PlayerCastingBarFrame:SetAlpha(1)
    end
    if PetCastingBarFrame then
        PetCastingBarFrame:SetAlpha(1)
    end
    if TargetFrameSpellBar then
        TargetFrameSpellBar:SetAlpha(1)
    end
    if FocusFrameSpellBar then
        FocusFrameSpellBar:SetAlpha(1)
    end
    
    -- Restore ToT and FoT spell bars
    local totSpellBar = TargetFrameToT and TargetFrameToT.SpellBar
    if totSpellBar then totSpellBar:SetAlpha(1) end
    if TargetFrameToTSpellBar then TargetFrameToTSpellBar:SetAlpha(1) end
    
    local fotSpellBar = FocusFrameToT and FocusFrameToT.SpellBar
    if fotSpellBar then fotSpellBar:SetAlpha(1) end
    if FocusFrameToTSpellBar then FocusFrameToTSpellBar:SetAlpha(1) end
    
    UnitFrames.BlizzState.castBarHidden = false
end

-- Check if any custom cast bar is enabled and update Blizzard cast bar visibility
local function UpdateBlizzardCastBarVisibility()
    local anyEnabled = false
    
    -- Check individual frames
    for _, unit in ipairs({"player", "target", "focus", "pet", "targettarget"}) do
        if settings[unit] and settings[unit].enabled and 
           settings[unit].castBar and settings[unit].castBar.enabled then
            anyEnabled = true
            break
        end
    end
    
    if anyEnabled then
        HideBlizzardCastBars()
    else
        ShowBlizzardCastBars()
    end
end

-- Map unit to Blizzard frame names and Edit Mode system enums
local UNIT_FRAME_INFO = {
    player = {
        frameName = "PlayerFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.PlayerFrame,
    },
    target = {
        frameName = "TargetFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.TargetFrame,
    },
    focus = {
        frameName = "FocusFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.FocusFrame,
    },
    pet = {
        frameName = "PetFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.PetFrame,
    },
    targettarget = {
        frameName = "TargetFrameToT",
        system = nil, -- ToT doesn't have its own system enum
    },
    party1 = {
        frameName = "PartyFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.PartyFrame,
    },
    party2 = {
        frameName = "PartyFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.PartyFrame,
    },
    party3 = {
        frameName = "PartyFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.PartyFrame,
    },
    party4 = {
        frameName = "PartyFrame",
        system = Enum.EditModeSystem and Enum.EditModeSystem.PartyFrame,
    },
}

local editModeHooked = false
local editModeHiddenUnits = {}

local function HideUnitFrameFromEditMode(unit)
    local hidden = GetHiddenFrame()
    local info = UNIT_FRAME_INFO[unit]
    if not info then return end
    
    -- Method 1: Hide the Selection overlay directly on the Blizzard frame
    local blizzFrame = _G[info.frameName]
    if blizzFrame then
        if blizzFrame.Selection and type(blizzFrame.Selection) == "table" then
            blizzFrame.Selection:Hide()
            blizzFrame.Selection:SetParent(hidden)
        end
        -- Also check for HighlightSystem (used in some Edit Mode implementations)
        -- Must verify it's a table/frame, not a function
        if blizzFrame.HighlightSystem and type(blizzFrame.HighlightSystem) == "table" and blizzFrame.HighlightSystem.Hide then
            blizzFrame.HighlightSystem:Hide()
        end
    end
    
    -- Method 2: Search through EditModeManagerFrame's registered systems
    if EditModeManagerFrame and EditModeManagerFrame.registeredSystemFrames then
        for _, frame in ipairs(EditModeManagerFrame.registeredSystemFrames) do
            if frame and type(frame) == "table" then
                local shouldHide = false
                
                -- Check by system enum
                if info.system and frame.system == info.system then
                    shouldHide = true
                end
                
                -- Check by frame name
                if frame.GetName then
                    local name = frame:GetName() or ""
                    if name == info.frameName or name:find(info.frameName) then
                        shouldHide = true
                    end
                end
                
                -- Check if frame matches directly
                if frame == blizzFrame then
                    shouldHide = true
                end
                
                if shouldHide then
                    -- Hide the selection overlay
                    if frame.Selection and type(frame.Selection) == "table" then
                        frame.Selection:Hide()
                        frame.Selection:SetParent(hidden)
                    end
                    -- Hide highlight (verify it's a table/frame first)
                    if frame.HighlightSystem and type(frame.HighlightSystem) == "table" and frame.HighlightSystem.Hide then
                        frame.HighlightSystem:Hide()
                    end
                end
            end
        end
    end
    
    editModeHiddenUnits[unit] = true
end

local function HideAllCustomUnitFramesFromEditMode()
    for unit, _ in pairs(customFrames) do
        if settings[unit] and settings[unit].enabled then
            HideUnitFrameFromEditMode(unit)
        end
    end
end

-- Edit Mode callbacks removed - Layout system now handles positioning
-- SetupEditModeCallbacks is no longer needed

-- Show party/raid containers during Edit Mode for positioning
-- This shows them regardless of enabled state so you can position before enabling
function UnitFrames:ShowContainersForEditMode()
    if InCombatLockdown() then return end
    
    TweaksUI:PrintDebug("ShowContainersForEditMode called")
    
    -- Enable simulation only for tanks and boss (they need it for Edit Mode positioning)
    -- Individual frames, party and raid only show when units exist or preview is checked
    simulateTanks = true
    simulateBoss = true
    
    -- Party container - only show if actually in a group
    if settings.party and IsInGroup() then
        if not partyContainer then
            self:CreatePartyContainer()
        end
        if partyContainer then
            partyContainer:Show()
            self:UpdatePartyFrames()
            self:RegisterContainerWithEditMode("party")
        end
    end
    
    -- Raid containers - only show if actually in a raid
    if settings.raid and IsInRaid() then
        -- Determine which size to show based on raid size
        local raidSize = GetNumGroupMembers()
        local threshold = settings.raid.sizeThreshold or 20
        
        if raidSize <= threshold then
            if not raidSmallContainer then
                self:CreateRaidContainer("small")
            end
            if raidSmallContainer then
                raidSmallContainer:Show()
                self:RegisterContainerWithEditMode("raid_small")
            end
        else
            if not raidLargeContainer then
                self:CreateRaidContainer("large")
            end
            if raidLargeContainer then
                raidLargeContainer:Show()
                self:RegisterContainerWithEditMode("raid_large")
            end
        end
        
        self:UpdateRaidFrames()
    end
    
    -- Tank container
    if settings.tanks then
        if not tankContainer then
            self:CreateTankContainer()
        end
        if tankContainer then
            tankContainer:Show()
            self:UpdateTankFrames()
            self:RegisterContainerWithEditMode("tanks")
        end
    end
    
    -- Boss container
    if settings.boss then
        if not bossContainer and not InCombatLockdown() then
            self:CreateBossContainer()
        end
        if bossContainer and not InCombatLockdown() then
            bossContainer:Show()
            self:UpdateBossFrames()
            self:RegisterContainerWithEditMode("boss")
        end
    end
end

-- Hide containers after Edit Mode if not actually in a group
function UnitFrames:HideContainersAfterEditMode()
    if InCombatLockdown() then return end
    
    -- Turn off all preview/simulation modes
    previewPlayer = false
    previewTarget = false
    previewFocus = false
    previewToT = false
    previewPet = false
    previewParty = false
    simulateRaidSmall = false
    simulateRaidLarge = false
    simulateTanks = false
    simulateBoss = false
    
    -- Restore state drivers for individual frames
    local stateConditions = {
        target = "[@target,exists] show; hide",
        focus = "[@focus,exists] show; hide",
        targettarget = "[@targettarget,exists] show; hide",
        pet = "[@pet,exists] show; hide",
    }
    for unit, stateCondition in pairs(stateConditions) do
        local frame = customFrames[unit]
        if frame then
            RegisterStateDriver(frame, "visibility", stateCondition)
        end
    end
    
    -- Party container - hide if not in a party
    if partyContainer and not IsInGroup() then
        partyContainer:Hide()
    elseif partyContainer then
        self:UpdatePartyFrames()
    end
    
    -- Raid containers - hide if not in a raid
    if not IsInRaid() then
        if raidSmallContainer then raidSmallContainer:Hide() end
        if raidLargeContainer then raidLargeContainer:Hide() end
    else
        self:UpdateRaidFrames()
    end
    
    -- Tank container - hide if no real tanks
    if tankContainer then
        local hasTanks = false
        if IsInGroup() then
            for i = 1, GetNumGroupMembers() do
                local unit = IsInRaid() and "raid"..i or "party"..i
                if UnitExists(unit) then
                    local role = UnitGroupRolesAssigned(unit)
                    if role == "TANK" then
                        hasTanks = true
                        break
                    end
                end
            end
        end
        if not hasTanks then
            tankContainer:Hide()
        else
            self:UpdateTankFrames()
        end
    end
    
    -- Boss container - hide if no real bosses
    if bossContainer then
        local hasBoss = false
        for i = 1, 5 do
            if UnitExists("boss" .. i) then
                hasBoss = true
                break
            end
        end
        -- Don't hide container - keep it always visible
        -- Individual frames will be hidden via RegisterUnitWatch if no bosses exist
        if hasBoss then
            self:UpdateBossFrames()
        end
    end
    
    -- Update individual frames with real data (deferred to ensure method is available)
    local module = self
    C_Timer.After(0.1, function()
        for _, unit in ipairs(INDIVIDUAL_UNITS) do
            if customFrames[unit] and module.RefreshFrame then
                pcall(function() module:RefreshFrame(unit) end)
            end
        end
    end)
end

-- RegisterContainerWithEditMode is deprecated - Layout system now handles positioning
-- This function is stubbed out for backwards compatibility
function UnitFrames:RegisterContainerWithEditMode(containerType)
    -- No-op: Layout system handles container positioning now
end

-- ============================================================================
-- CUSTOM FRAME CREATION
-- ============================================================================

local function CreateCustomUnitFrame(unit)
    if customFrames[unit] then return customFrames[unit] end
    
    local unitSettings = settings[unit]
    if not unitSettings then return nil end
    
    local frameName = "TweaksUI_UF_" .. unit
    
    -- Main container frame (secure for click-through)
    local frame = CreateFrame("Button", frameName, UIParent, "SecureUnitButtonTemplate,BackdropTemplate")
    frame.unit = unit
    frame:SetAttribute("unit", unit)
    frame:SetAttribute("*type1", "target")
    frame:SetAttribute("*type2", "togglemenu")
    frame:RegisterForClicks("AnyUp")
    
    frame:SetBackdrop(frameBackdrop)
    frame:SetFrameStrata("LOW")
    frame:SetFrameLevel(10)
    
    -- Health Bar
    frame.healthBar = CreateFrame("StatusBar", frameName .. "_Health", frame)
    frame.healthBar:SetStatusBarTexture(GetTexturePath())
    frame.healthBar:SetMinMaxValues(0, 1)
    frame.healthBar:SetValue(1)
    frame.healthBar:SetFrameLevel(frame:GetFrameLevel() + 1)
    
    frame.healthBar.bg = frame.healthBar:CreateTexture(nil, "BACKGROUND")
    frame.healthBar.bg:SetAllPoints()
    frame.healthBar.bg:SetTexture("Interface\\Buttons\\WHITE8X8")
    
    -- Health bar border
    frame.healthBar.borderFrame = CreateFrame("Frame", nil, frame.healthBar, "BackdropTemplate")
    frame.healthBar.borderFrame:SetPoint("TOPLEFT", -1, 1)
    frame.healthBar.borderFrame:SetPoint("BOTTOMRIGHT", 1, -1)
    frame.healthBar.borderFrame:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 1,
    })
    frame.healthBar.borderFrame:SetBackdropBorderColor(0, 0, 0, 1)
    frame.healthBar.borderFrame:Hide()
    
    -- Power Bar
    frame.powerBar = CreateFrame("StatusBar", frameName .. "_Power", frame)
    frame.powerBar:SetStatusBarTexture(GetTexturePath())
    frame.powerBar:SetMinMaxValues(0, 1)
    frame.powerBar:SetValue(1)
    frame.powerBar:SetFrameLevel(frame:GetFrameLevel() + 1)
    
    frame.powerBar.bg = frame.powerBar:CreateTexture(nil, "BACKGROUND")
    frame.powerBar.bg:SetAllPoints()
    frame.powerBar.bg:SetTexture("Interface\\Buttons\\WHITE8X8")
    
    -- Power bar border
    frame.powerBar.borderFrame = CreateFrame("Frame", nil, frame.powerBar, "BackdropTemplate")
    frame.powerBar.borderFrame:SetPoint("TOPLEFT", -1, 1)
    frame.powerBar.borderFrame:SetPoint("BOTTOMRIGHT", 1, -1)
    frame.powerBar.borderFrame:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 1,
    })
    frame.powerBar.borderFrame:SetBackdropBorderColor(0, 0, 0, 1)
    frame.powerBar.borderFrame:Hide()
    
    -- ========================================================================
    -- ABSORB BAR (Phase 2) - Shows absorption shields on health bar
    -- ========================================================================
    
    -- Absorb overlay (sits on top of health bar, shows absorb as extension)
    frame.absorbBar = CreateFrame("StatusBar", frameName .. "_Absorb", frame)
    frame.absorbBar:SetStatusBarTexture("Interface\\RaidFrame\\Shield-Fill")
    frame.absorbBar:SetMinMaxValues(0, 1)
    frame.absorbBar:SetValue(0)
    frame.absorbBar:SetFrameLevel(frame.healthBar:GetFrameLevel() + 1)
    frame.absorbBar:Hide()
    
    -- Absorb glow/spark at the edge (Blizzard style)
    frame.absorbBar.overGlow = frame.absorbBar:CreateTexture(nil, "OVERLAY")
    frame.absorbBar.overGlow:SetTexture("Interface\\RaidFrame\\Shield-Overshield")
    frame.absorbBar.overGlow:SetBlendMode("ADD")
    frame.absorbBar.overGlow:SetSize(8, 16)
    frame.absorbBar.overGlow:Hide()
    
    -- Absorb bar background
    frame.absorbBar.bg = frame.absorbBar:CreateTexture(nil, "BACKGROUND")
    frame.absorbBar.bg:SetAllPoints()
    frame.absorbBar.bg:SetTexture("Interface\\Buttons\\WHITE8X8")
    frame.absorbBar.bg:SetVertexColor(0.1, 0.1, 0.1, 0.6)
    frame.absorbBar.bg:Hide()
    
    -- Absorb bar border (using backdrop)
    frame.absorbBar.borderFrame = CreateFrame("Frame", nil, frame.absorbBar, "BackdropTemplate")
    frame.absorbBar.borderFrame:SetPoint("TOPLEFT", -1, 1)
    frame.absorbBar.borderFrame:SetPoint("BOTTOMRIGHT", 1, -1)
    frame.absorbBar.borderFrame:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 1,
    })
    frame.absorbBar.borderFrame:SetBackdropBorderColor(0.3, 0.3, 0.3, 1)
    frame.absorbBar.borderFrame:Hide()
    
    -- Absorb text (for displaying absorb amount)
    frame.absorbBar.text = frame.absorbBar:CreateFontString(nil, "OVERLAY")
    frame.absorbBar.text:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
    frame.absorbBar.text:SetPoint("CENTER", frame.absorbBar, "CENTER", 0, 0)
    frame.absorbBar.text:SetTextColor(1, 1, 1, 1)
    frame.absorbBar.text:Hide()
    
    -- Absorb label (name/title)
    frame.absorbBar.label = frame.absorbBar:CreateFontString(nil, "OVERLAY")
    frame.absorbBar.label:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
    frame.absorbBar.label:SetPoint("LEFT", frame.absorbBar, "LEFT", 4, 0)
    frame.absorbBar.label:SetTextColor(1, 1, 1, 1)
    frame.absorbBar.label:SetText("Absorb")
    frame.absorbBar.label:Hide()
    
    -- ========================================================================
    -- CLASS POWER BAR (Phase 2) - Shows secondary resources (combo points, etc.)
    -- ========================================================================
    
    -- Class power container (holds segments)
    frame.classPower = CreateFrame("Frame", frameName .. "_ClassPower", frame)
    frame.classPower:SetFrameLevel(frame:GetFrameLevel() + 2)
    frame.classPower.segments = {}
    frame.classPower:Hide()
    
    -- Create up to 10 segments for class power (covers all cases: 5 combo, 6 runes, 7 arcane, etc.)
    for i = 1, 10 do
        local segment = CreateFrame("Frame", nil, frame.classPower, "BackdropTemplate")
        segment:SetFrameLevel(frame.classPower:GetFrameLevel() + 1)
        
        -- Background
        segment.bg = segment:CreateTexture(nil, "BACKGROUND")
        segment.bg:SetAllPoints()
        segment.bg:SetColorTexture(0.15, 0.15, 0.15, 0.8)
        
        -- Fill
        segment.fill = segment:CreateTexture(nil, "ARTWORK")
        segment.fill:SetAllPoints()
        segment.fill:SetColorTexture(1, 0.8, 0, 1)  -- Default gold color
        segment.fill:Hide()
        
        -- Border
        segment.border = CreateFrame("Frame", nil, segment, "BackdropTemplate")
        segment.border:SetPoint("TOPLEFT", -1, 1)
        segment.border:SetPoint("BOTTOMRIGHT", 1, -1)
        segment.border:SetBackdrop({ edgeFile = "Interface\\Buttons\\WHITE8X8", edgeSize = 1 })
        segment.border:SetBackdropBorderColor(0, 0, 0, 1)
        
        segment:Hide()
        frame.classPower.segments[i] = segment
    end
    
    -- Status bar for continuous resources (Stagger, etc.)
    frame.classPower.statusBar = CreateFrame("StatusBar", nil, frame.classPower)
    frame.classPower.statusBar:SetAllPoints()
    frame.classPower.statusBar:SetMinMaxValues(0, 100)
    frame.classPower.statusBar:SetValue(0)
    frame.classPower.statusBar:SetStatusBarTexture("Interface\\TargetingFrame\\UI-StatusBar")
    frame.classPower.statusBar:SetStatusBarColor(0.52, 1, 0.52, 1)  -- Default green (stagger light)
    frame.classPower.statusBar:Hide()
    
    -- Background for status bar
    frame.classPower.statusBarBg = frame.classPower.statusBar:CreateTexture(nil, "BACKGROUND")
    frame.classPower.statusBarBg:SetAllPoints()
    frame.classPower.statusBarBg:SetColorTexture(0.1, 0.1, 0.1, 0.8)
    
    -- Border for status bar
    frame.classPower.statusBarBorder = CreateFrame("Frame", nil, frame.classPower.statusBar, "BackdropTemplate")
    frame.classPower.statusBarBorder:SetPoint("TOPLEFT", -1, 1)
    frame.classPower.statusBarBorder:SetPoint("BOTTOMRIGHT", 1, -1)
    frame.classPower.statusBarBorder:SetBackdrop({ edgeFile = "Interface\\Buttons\\WHITE8X8", edgeSize = 1 })
    frame.classPower.statusBarBorder:SetBackdropBorderColor(0, 0, 0, 1)
    frame.classPower.statusBarBorder:Hide()
    
    -- Text overlay for status bar (ensures text is above the bar fill)
    frame.classPower.textOverlay = CreateFrame("Frame", nil, frame.classPower)
    frame.classPower.textOverlay:SetAllPoints()
    frame.classPower.textOverlay:SetFrameLevel(frame.classPower:GetFrameLevel() + 5)
    
    -- Text for status bar (stagger percentage) - on overlay for proper layering
    frame.classPower.statusBarText = frame.classPower.textOverlay:CreateFontString(nil, "OVERLAY")
    frame.classPower.statusBarText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
    frame.classPower.statusBarText:SetPoint("CENTER", frame.classPower, "CENTER", 0, 0)
    frame.classPower.statusBarText:SetTextColor(1, 1, 1, 1)
    frame.classPower.statusBarText:Hide()
    
    -- Text overlay frame (ensures all text is above bars and portrait)
    frame.textOverlay = CreateFrame("Frame", frameName .. "_TextOverlay", frame)
    frame.textOverlay:SetAllPoints()
    frame.textOverlay:SetFrameLevel(frame:GetFrameLevel() + 10)
    
    -- Health Text (on overlay, positioned relative to health bar)
    frame.healthText = frame.textOverlay:CreateFontString(nil, "OVERLAY")
    frame.healthText:SetFont(GetFontPath(DEFAULT_FONT), 11, GetFontOutline())
    
    -- Power Text (on overlay, positioned relative to power bar)
    frame.powerText = frame.textOverlay:CreateFontString(nil, "OVERLAY")
    frame.powerText:SetFont(GetFontPath(DEFAULT_FONT), 9, GetFontOutline())
    
    -- Name Text (on overlay)
    frame.nameText = frame.textOverlay:CreateFontString(nil, "OVERLAY")
    frame.nameText:SetFont(GetFontPath(DEFAULT_FONT), 11, GetFontOutline())
    
    -- Level Text (on overlay)
    frame.levelText = frame.textOverlay:CreateFontString(nil, "OVERLAY")
    frame.levelText:SetFont(GetFontPath(DEFAULT_FONT), 11, GetFontOutline())
    
    -- Portrait container
    frame.portraitFrame = CreateFrame("Frame", frameName .. "_Portrait", frame)
    frame.portraitFrame:SetFrameLevel(frame:GetFrameLevel() + 2)
    
    -- 3D Portrait
    frame.portrait3D = CreateFrame("PlayerModel", frameName .. "_Portrait3D", frame.portraitFrame)
    frame.portrait3D:SetAllPoints()
    
    -- 2D Portrait
    frame.portrait2D = frame.portraitFrame:CreateTexture(nil, "ARTWORK")
    frame.portrait2D:SetAllPoints()
    
    -- Class Icon
    frame.classIcon = frame.portraitFrame:CreateTexture(nil, "ARTWORK")
    frame.classIcon:SetAllPoints()
    
    -- Portrait backdrop
    frame.portraitFrame.bg = frame.portraitFrame:CreateTexture(nil, "BACKGROUND")
    frame.portraitFrame.bg:SetAllPoints()
    frame.portraitFrame.bg:SetColorTexture(0, 0, 0, 0.8)
    
    -- Raid Target Icon
    frame.raidTarget = frame:CreateTexture(nil, "OVERLAY")
    frame.raidTarget:SetTexture("Interface\\TargetingFrame\\UI-RaidTargetingIcons")
    
    -- Role Icon Container (elevated frame level to appear above bars)
    frame.roleIconFrame = CreateFrame("Frame", frameName .. "_RoleIcon", frame)
    frame.roleIconFrame:SetFrameLevel(frame:GetFrameLevel() + 20)
    frame.roleIconFrame:SetSize(18, 18)
    
    -- Role Icon (Tank/Healer/DPS)
    frame.roleIcon = frame.roleIconFrame:CreateTexture(nil, "OVERLAY")
    frame.roleIcon:SetAllPoints()
    frame.roleIcon:Hide()
    
    -- Debuff Indicators container
    frame.debuffIndicators = CreateFrame("Frame", frameName .. "_DebuffIndicators", frame)
    frame.debuffIndicators:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.debuffIndicators:SetSize(60, 14)
    
    -- Create individual debuff type indicators with style support
    frame.debuffIndicators.indicators = {}
    local debuffTypes = { "Magic", "Curse", "Disease", "Poison", "Bleed" }
    for i, debuffType in ipairs(debuffTypes) do
        local indicator = CreateFrame("Frame", nil, frame.debuffIndicators, "BackdropTemplate")
        indicator:SetSize(12, 12)
        indicator:SetFrameLevel(frame.debuffIndicators:GetFrameLevel() + 1)
        
        indicator.debuffType = debuffType
        indicator.color = DEBUFF_TYPE_COLORS[debuffType]
        
        -- Create colored square (for "squares" and fallback mode)
        indicator.square = indicator:CreateTexture(nil, "BACKGROUND")
        indicator.square:SetAllPoints()
        indicator.square:SetColorTexture(unpack(indicator.color))
        
        -- Create Blizzard-style icon (for "icons" and "both" modes)
        indicator.icon = indicator:CreateTexture(nil, "ARTWORK")
        indicator.icon:SetAllPoints()
        indicator.icon:SetTexCoord(0.08, 0.92, 0.08, 0.92)
        
        -- Try to set atlas first (Bleed doesn't have a standard atlas)
        local atlasSet = false
        if Constants.DEBUFF_TYPE_ATLASES and Constants.DEBUFF_TYPE_ATLASES[debuffType] then
            local success = pcall(function()
                indicator.icon:SetAtlas(Constants.DEBUFF_TYPE_ATLASES[debuffType])
            end)
            if success then atlasSet = true end
        end
        if not atlasSet and Constants.DEBUFF_TYPE_TEXTURES and Constants.DEBUFF_TYPE_TEXTURES[debuffType] then
            indicator.icon:SetTexture(Constants.DEBUFF_TYPE_TEXTURES[debuffType])
        elseif not atlasSet then
            -- Fallback: use colored texture for types without icons (Bleed)
            indicator.icon:SetTexture("Interface\\Buttons\\WHITE8X8")
            indicator.icon:SetVertexColor(unpack(indicator.color))
        end
        
        indicator:Hide()
        frame.debuffIndicators.indicators[debuffType] = indicator
    end
    
    -- ========================================================================
    -- AURA DISPLAY (Phase 3) - Full buff/debuff icons
    -- ========================================================================
    
    -- Helper function to create a single aura icon frame
    local function CreateAuraIcon(parent, index)
        -- Use Button for right-click cancel support on player buffs
        local icon = CreateFrame("Button", nil, parent, "BackdropTemplate")
        icon:SetFrameLevel(parent:GetFrameLevel() + 1)
        icon:EnableMouse(true)
        icon:RegisterForClicks("AnyUp")
        
        -- Icon texture (will receive secret texture values)
        icon.texture = icon:CreateTexture(nil, "ARTWORK")
        icon.texture:SetAllPoints()
        icon.texture:SetTexCoord(0.08, 0.92, 0.08, 0.92)  -- Trim icon edges
        
        -- Cooldown frame for duration spiral
        icon.cooldown = CreateFrame("Cooldown", nil, icon, "CooldownFrameTemplate")
        icon.cooldown:SetAllPoints()
        icon.cooldown:SetDrawEdge(false)
        icon.cooldown:SetDrawBling(false)
        icon.cooldown:SetDrawSwipe(true)
        icon.cooldown:SetReverse(true)  -- Fill up as time passes
        icon.cooldown:SetHideCountdownNumbers(false)  -- Use Blizzard's built-in text (works with secret values)
        icon.cooldown:EnableMouse(false)  -- Allow clicks to pass through
        
        -- Border frame (for dispel type coloring)
        icon.border = icon:CreateTexture(nil, "OVERLAY")
        icon.border:SetPoint("TOPLEFT", -1, 1)
        icon.border:SetPoint("BOTTOMRIGHT", 1, -1)
        icon.border:SetTexture("Interface\\Buttons\\UI-Debuff-Overlays")
        icon.border:SetTexCoord(0.296875, 0.5703125, 0, 0.515625)  -- Border overlay
        icon.border:Hide()
        
        -- Text overlay frame - sits above cooldown so text is always visible
        icon.textOverlay = CreateFrame("Frame", nil, icon)
        icon.textOverlay:SetAllPoints()
        icon.textOverlay:SetFrameLevel(icon:GetFrameLevel() + 10)
        icon.textOverlay:EnableMouse(false)  -- Allow clicks to pass through
        
        -- Stack count text (on overlay so it's above sweep)
        icon.stackText = icon.textOverlay:CreateFontString(nil, "OVERLAY")
        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
        icon.stackText:SetPoint("BOTTOMRIGHT", 0, 0)
        icon.stackText:SetTextColor(1, 1, 1, 1)
        icon.stackText:SetJustifyH("RIGHT")
        
        -- Duration text (no longer used - Blizzard's CooldownFrameTemplate handles it)
        icon.durationText = icon.textOverlay:CreateFontString(nil, "OVERLAY")
        icon.durationText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
        icon.durationText:SetPoint("CENTER", 0, 0)
        icon.durationText:SetTextColor(1, 1, 0.6, 1)
        icon.durationText:SetJustifyH("CENTER")
        icon.durationText:Hide()  -- Blizzard's cooldown handles duration text now
        
        -- Store index for reference
        icon.index = index
        icon.auraInstanceID = nil
        icon.spellName = nil
        
        -- Right-click handler for buff cancellation (player buffs only)
        icon:SetScript("OnClick", function(self, button)
            if button == "RightButton" and parent.isBuff and parent.unit == "player" and not InCombatLockdown() then
                pcall(function()
                    if self.spellName and CancelSpellByName then
                        CancelSpellByName(self.spellName)
                    end
                end)
            end
        end)
        
        -- Tooltip support
        icon:SetScript("OnEnter", function(self)
            if self.auraInstanceID and parent.unit then
                GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
                -- Use the correct tooltip API based on buff/debuff
                local success = false
                pcall(function()
                    if parent.isBuff then
                        if GameTooltip.SetUnitBuffByAuraInstanceID then
                            GameTooltip:SetUnitBuffByAuraInstanceID(parent.unit, self.auraInstanceID)
                            success = true
                        else
                            GameTooltip:SetUnitAura(parent.unit, self.auraInstanceID)
                            success = true
                        end
                    else
                        if GameTooltip.SetUnitDebuffByAuraInstanceID then
                            GameTooltip:SetUnitDebuffByAuraInstanceID(parent.unit, self.auraInstanceID)
                            success = true
                        else
                            GameTooltip:SetUnitAura(parent.unit, self.auraInstanceID)
                            success = true
                        end
                    end
                end)
                if success then
                    GameTooltip:Show()
                else
                    GameTooltip:Hide()
                end
            end
        end)
        icon:SetScript("OnLeave", function()
            GameTooltip:Hide()
        end)
        
        icon:Hide()
        return icon
    end
    
    -- Buffs container
    frame.buffsContainer = CreateFrame("Frame", frameName .. "_Buffs", frame)
    frame.buffsContainer:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.buffsContainer:SetSize(100, 20)  -- Will be resized in layout
    frame.buffsContainer.unit = unit
    frame.buffsContainer.icons = {}
    frame.buffsContainer.isBuff = true
    
    -- Create buff icon pool (max 16 icons)
    for i = 1, 16 do
        frame.buffsContainer.icons[i] = CreateAuraIcon(frame.buffsContainer, i)
    end
    
    -- Debuffs container
    frame.debuffsContainer = CreateFrame("Frame", frameName .. "_Debuffs", frame)
    frame.debuffsContainer:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.debuffsContainer:SetSize(100, 20)
    frame.debuffsContainer.unit = unit
    frame.debuffsContainer.icons = {}
    frame.debuffsContainer.isBuff = false
    
    -- Create debuff icon pool (max 16 icons)
    for i = 1, 16 do
        frame.debuffsContainer.icons[i] = CreateAuraIcon(frame.debuffsContainer, i)
    end
    
    -- ========================================================================
    -- STATUS INDICATORS (Combat & Resting) - Quick Win Feature
    -- Uses HIGH strata frame to always appear on top
    -- ========================================================================
    
    -- Combat Indicator Container (HIGH strata for visibility)
    frame.combatFrame = CreateFrame("Frame", frameName .. "_CombatIndicator", frame)
    frame.combatFrame:SetFrameStrata("HIGH")
    frame.combatFrame:SetFrameLevel(100)
    frame.combatFrame:SetSize(24, 24)
    frame.combatFrame:Hide()
    
    frame.combatIndicator = frame.combatFrame:CreateTexture(nil, "OVERLAY")
    frame.combatIndicator:SetAllPoints()
    frame.combatIndicator:SetTexture("Interface\\CharacterFrame\\UI-StateIcon")
    frame.combatIndicator:SetTexCoord(0.5, 1, 0, 0.49)  -- Combat swords icon
    
    -- Resting Indicator Container (HIGH strata, shares position with combat)
    frame.restingFrame = CreateFrame("Frame", frameName .. "_RestingIndicator", frame)
    frame.restingFrame:SetFrameStrata("HIGH")
    frame.restingFrame:SetFrameLevel(100)
    frame.restingFrame:SetSize(24, 24)
    frame.restingFrame:Hide()
    
    frame.restingIndicator = frame.restingFrame:CreateTexture(nil, "OVERLAY")
    frame.restingIndicator:SetAllPoints()
    frame.restingIndicator:SetTexture("Interface\\CharacterFrame\\UI-StateIcon")
    frame.restingIndicator:SetTexCoord(0, 0.5, 0, 0.421875)  -- Zzz resting icon
    
    -- ========================================================================
    -- LEADER INDICATOR - Quick Win Feature
    -- ========================================================================
    
    -- Leader Indicator Container (elevated frame level to appear above bars)
    frame.leaderFrame = CreateFrame("Frame", frameName .. "_LeaderIcon", frame)
    frame.leaderFrame:SetFrameLevel(frame:GetFrameLevel() + 20)
    frame.leaderFrame:SetSize(16, 16)
    
    frame.leaderIndicator = frame.leaderFrame:CreateTexture(nil, "OVERLAY")
    frame.leaderIndicator:SetAllPoints()
    frame.leaderIndicator:SetTexture("Interface\\GroupFrame\\UI-Group-LeaderIcon")
    frame.leaderIndicator:Hide()
    
    -- ========================================================================
    -- SUMMON INDICATOR - Quick Win Feature
    -- Shows pending/accepted summon status (warlock summons, meeting stones)
    -- ========================================================================
    
    -- Summon indicator container (HIGH strata for visibility)
    frame.summonFrame = CreateFrame("Frame", frameName .. "_SummonIndicator", frame)
    frame.summonFrame:SetFrameStrata("HIGH")
    frame.summonFrame:SetFrameLevel(100)
    frame.summonFrame:SetSize(20, 20)
    frame.summonFrame:Hide()
    
    frame.summonIndicator = frame.summonFrame:CreateTexture(nil, "OVERLAY")
    frame.summonIndicator:SetAllPoints()
    frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonPending")  -- Portal icon
    
    -- ========================================================================
    -- MOUSEOVER HIGHLIGHT - Quick Win Feature (Universal setting)
    -- Two styles: overlay, border
    -- ========================================================================
    
    -- Overlay style (HIGH strata frame with color fill)
    frame.mouseoverOverlayFrame = CreateFrame("Frame", frameName .. "_MouseoverOverlay", frame)
    frame.mouseoverOverlayFrame:SetFrameStrata("HIGH")
    frame.mouseoverOverlayFrame:SetFrameLevel(100)
    frame.mouseoverOverlayFrame:SetAllPoints()
    frame.mouseoverOverlay = frame.mouseoverOverlayFrame:CreateTexture(nil, "OVERLAY")
    frame.mouseoverOverlay:SetAllPoints()
    frame.mouseoverOverlay:SetColorTexture(1, 1, 1, 0.15)
    frame.mouseoverOverlayFrame:Hide()
    
    -- Border style (solid border)
    frame.mouseoverBorder = CreateFrame("Frame", frameName .. "_MouseoverBorder", frame, "BackdropTemplate")
    frame.mouseoverBorder:SetFrameLevel(frame:GetFrameLevel() + 2)
    frame.mouseoverBorder:SetPoint("TOPLEFT", frame, "TOPLEFT", -2, 2)
    frame.mouseoverBorder:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", 2, -2)
    frame.mouseoverBorder:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 2,
    })
    frame.mouseoverBorder:SetBackdropBorderColor(1, 1, 1, 1)
    frame.mouseoverBorder:Hide()
    
    -- ========================================================================
    -- TARGET HIGHLIGHT - Quick Win Feature (Border style)
    -- ========================================================================
    
    frame.targetHighlight = CreateFrame("Frame", frameName .. "_TargetHighlight", frame, "BackdropTemplate")
    frame.targetHighlight:SetFrameLevel(frame:GetFrameLevel() + 3)
    frame.targetHighlight:SetPoint("TOPLEFT", frame, "TOPLEFT", -2, 2)
    frame.targetHighlight:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", 2, -2)
    frame.targetHighlight:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 2,
    })
    frame.targetHighlight:SetBackdropBorderColor(1, 1, 1, 1)
    frame.targetHighlight:Hide()
    
    -- Target Highlight Glow (alternative style)
    frame.targetHighlightGlow = frame:CreateTexture(nil, "BACKGROUND", nil, -8)
    frame.targetHighlightGlow:SetPoint("TOPLEFT", frame, "TOPLEFT", -4, 4)
    frame.targetHighlightGlow:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", 4, -4)
    frame.targetHighlightGlow:SetTexture("Interface\\Buttons\\UI-ActionButton-Border")
    frame.targetHighlightGlow:SetBlendMode("ADD")
    frame.targetHighlightGlow:SetVertexColor(1, 1, 1, 0.6)
    frame.targetHighlightGlow:Hide()
    
    -- Cast Bar
    local castBar = CreateFrame("StatusBar", frameName .. "_CastBar", frame)
    castBar:SetStatusBarTexture(GetTexturePath())
    castBar:SetStatusBarColor(1, 0.7, 0, 1)
    castBar:SetMinMaxValues(0, 1)
    castBar:SetValue(0)
    castBar:SetFrameLevel(frame:GetFrameLevel() + 5)
    castBar:Hide()
    frame.castBar = castBar
    
    local castBg = castBar:CreateTexture(nil, "BACKGROUND")
    castBg:SetAllPoints()
    castBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
    castBar.bg = castBg
    
    -- Cast bar border
    castBar.borderFrame = CreateFrame("Frame", nil, castBar, "BackdropTemplate")
    castBar.borderFrame:SetPoint("TOPLEFT", -1, 1)
    castBar.borderFrame:SetPoint("BOTTOMRIGHT", 1, -1)
    castBar.borderFrame:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 1,
    })
    castBar.borderFrame:SetBackdropBorderColor(0, 0, 0, 1)
    castBar.borderFrame:Hide()
    
    -- Cast icon (left side)
    local castIcon = castBar:CreateTexture(nil, "OVERLAY")
    castIcon:SetSize(12, 12)
    castIcon:SetPoint("LEFT", castBar, "LEFT", 1, 0)
    frame.castIcon = castIcon
    
    -- Cast text (to the right of icon)
    local castText = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    castText:SetPoint("LEFT", castBar, "LEFT", 15, 0)  -- Position after icon
    castText:SetTextColor(1, 1, 1, 1)  -- Ensure white text
    castText:SetJustifyH("LEFT")
    frame.castText = castText
    
    -- Cast timer (right side)
    local castTimer = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    castTimer:SetPoint("RIGHT", castBar, "RIGHT", -2, 0)
    castTimer:SetTextColor(1, 1, 1, 1)  -- Ensure white text
    castTimer:SetJustifyH("RIGHT")
    frame.castTimer = castTimer
    
    -- Cast bar state
    frame.castBarUseTimerBar = false
    frame.castBarDurationObject = nil
    frame.castBarCasting = false
    frame.castBarChanneling = false
    frame.castBarStartTime = nil
    frame.castBarEndTime = nil
    frame.castBarMaxValue = nil
    
    -- OnUpdate for smooth cast bar animation (v2.1.3 - SetTimerDuration for non-player units)
    castBar:SetScript("OnUpdate", function(self, elapsed)
        if not self:IsShown() then return end
        if not frame.unit then return end
        
        local unitSettings = settings[frame.unit]
        if not unitSettings or not unitSettings.castBar or not unitSettings.castBar.enabled then
            self:Hide()
            return
        end
        
        local isPlayerCast = (frame.unit == "player" or frame.unit == "pet" or frame.unit == "vehicle")
        
        -- Check for active cast/channel
        local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(frame.unit)
        local isChannel = false
        local isEmpowered = false
        local numEmpowerStages = nil
        
        if not castName then
            -- Check for empowered spell using event-driven flag (reliable like CastBars.lua)
            if frame.isEmpoweredCast and frame.empowerSpellID then
                if C_Spell and C_Spell.GetSpellInfo then
                    local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                    if success and spellInfo and spellInfo.name then
                        local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(frame.unit)
                        if chStart and chEnd then
                            castName = spellInfo.name
                            startTime = chStart
                            endTime = chEnd
                            spellID = frame.empowerSpellID
                            notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                            isEmpowered = true
                            isChannel = false  -- Empowered spells fill like casts
                            -- Get numEmpowerStages using helper (more reliable)
                            numEmpowerStages = GetEmpowerNumStages(frame.unit) or 3
                        end
                    end
                end
            end
            
            if not isEmpowered then
                -- Check for regular channel
                castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(frame.unit)
                isChannel = true
                
                -- Clear empowered flags if we're in a regular channel
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
        else
            -- Regular cast - clear empowered flags
            frame.empowerSpellID = nil
            frame.isEmpoweredCast = false
        end
        
        -- No cast? Hide and reset state
        local hasCast = castName ~= nil
        if not hasCast then
            if not (currentOpenPanel == frame.unit) then
                self:Hide()
            end
            frame.castBarUseTimerBar = false
            frame.castBarDurationObject = nil
            frame.castBarCasting = false
            frame.castBarChanneling = false
            HideEmpowerDividers(self)  -- Hide stage dividers when cast ends
            return
        end
        
        -- Detect new cast (cast started or changed)
        local newCast = false
        if isChannel then
            if not frame.castBarChanneling then newCast = true end
        else
            if not frame.castBarCasting then newCast = true end
        end
        
        -- Setup new cast
        if newCast then
            frame.castBarCasting = not isChannel
            frame.castBarChanneling = isChannel
            frame.castBarUseTimerBar = false
            frame.castBarDurationObject = nil
            
            -- Clear dividers setup flag for new cast
            self.empowerDividersSetup = false
            
            -- For empowered casts (player or not), use UnitEmpoweredChannelDuration for accurate timing
            -- This includes hold-at-max time which is critical for correct bar duration
            if isEmpowered and HAS_TIMER_BARS and UnitEmpoweredChannelDuration then
                local ok, obj = pcall(UnitEmpoweredChannelDuration, frame.unit, true)  -- true = include hold-at-max
                if ok and obj then
                    frame.castBarDurationObject = obj
                    self:SetMinMaxValues(0, 1)
                    local timerOk = pcall(self.SetTimerDuration, self, obj, BAR_INTERPOLATION)
                    if timerOk then
                        frame.castBarUseTimerBar = true
                    end
                end
            -- For non-player non-empowered casts, try to use SetTimerDuration (handles secrets)
            elseif not isPlayerCast and HAS_TIMER_BARS then
                local durationObj = nil
                if isChannel and UnitChannelDuration then
                    local ok, obj = pcall(UnitChannelDuration, frame.unit)
                    if ok and obj then durationObj = obj end
                elseif not isChannel and UnitCastingDuration then
                    local ok, obj = pcall(UnitCastingDuration, frame.unit)
                    if ok and obj then durationObj = obj end
                end
                
                if durationObj then
                    frame.castBarDurationObject = durationObj
                    self:SetMinMaxValues(0, 1)
                    local ok = pcall(self.SetTimerDuration, self, durationObj, BAR_INTERPOLATION)
                    if ok then
                        frame.castBarUseTimerBar = true
                    end
                end
            end
            
            -- If timer bar didn't work, try traditional timing
            if not frame.castBarUseTimerBar then
                local safeStartTime = SafeNumber(startTime)
                local safeEndTime = SafeNumber(endTime)
                
                if safeStartTime and safeEndTime then
                    frame.castBarStartTime = safeStartTime / 1000
                    frame.castBarEndTime = safeEndTime / 1000
                    frame.castBarMaxValue = frame.castBarEndTime - frame.castBarStartTime
                    self:SetMinMaxValues(0, frame.castBarMaxValue)
                    if isChannel then
                        self:SetValue(frame.castBarMaxValue)
                    else
                        self:SetValue(0)
                    end
                end
            end
            
            -- Set spell name (v2.1.6)
            local cbs = unitSettings.castBar
            local cbHeight = cbs.height or 12
            
            -- Set icon first (left side)
            if frame.castIcon then
                if cbs.showIcon then
                    local safeSpellID = SafeNumber(spellID)
                    local spellTexture = nil
                    if safeSpellID then
                        spellTexture = GetSpellTextureByID(safeSpellID)
                    elseif spellID then
                        pcall(function()
                            spellTexture = GetSpellTextureByID(spellID)
                        end)
                    end
                    if spellTexture then
                        frame.castIcon:SetTexture(spellTexture)
                    end
                    frame.castIcon:SetSize(cbHeight, cbHeight)
                    frame.castIcon:ClearAllPoints()
                    frame.castIcon:SetPoint("LEFT", frame.castBar, "LEFT", 1, 0)
                    frame.castIcon:Show()
                else
                    frame.castIcon:Hide()
                end
            end
            
            -- Set spell name (positioned after icon)
            if frame.castText then
                if cbs.showSpellName then
                    local displayName = SafeValue(castName)
                    if displayName then
                        frame.castText:SetText(displayName)
                    elseif castName then
                        -- Try string.format for secret values
                        local ok, text = pcall(string.format, "%s", castName)
                        if ok and text then
                            frame.castText:SetText(text)
                        end
                    end
                    -- Position text after icon
                    local leftOffset = cbs.showIcon and (cbHeight + 3) or 2
                    frame.castText:ClearAllPoints()
                    frame.castText:SetPoint("LEFT", frame.castBar, "LEFT", leftOffset, 0)
                    frame.castText:SetTextColor(1, 1, 1, 1)
                    frame.castText:Show()
                else
                    frame.castText:Hide()
                end
            end
            
            -- Set color (v2.1.6 - handles secret notInterruptible, empowered, and important)
            local baseR, baseG, baseB = 1, 0.7, 0  -- Default cast color (orange)
            local safeSpellID = SafeNumber(spellID)
            local isImportant = false
            
            -- Check if spell is important (using SpellAPI if available)
            if TweaksUI.SpellAPI and safeSpellID then
                isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
            end
            
            -- Determine base color
            if isImportant then
                -- Important spells get a distinct color (red-orange for casts, purple for channels)
                if isChannel or isEmpowered then
                    baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                else
                    baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                end
            elseif isChannel or isEmpowered then
                baseR, baseG, baseB = 0, 0.7, 1  -- Channel/Empowered color (blue)
            end
            
            ApplyCastBarColor(self, notInterruptible, baseR, baseG, baseB, isPlayerCast)
            
            -- Setup empowered stage dividers if this is an empowered cast
            if isEmpowered and numEmpowerStages and numEmpowerStages >= 2 then
                SetupEmpowerDividers(self, frame.unit, numEmpowerStages)
            else
                HideEmpowerDividers(self)
            end
            
            self:Show()
        end
        
        -- Update cast bar
        if frame.castBarUseTimerBar then
            -- Timer bar mode: bar updates itself, we track progress for timer text
            local safeRemaining = nil
            if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                if ok and r then safeRemaining = r end
            end
            
            if frame.castTimer and unitSettings.castBar.showTimer then
                if safeRemaining then
                    local ok, text = pcall(string.format, "%.1f", safeRemaining)
                    if ok and text then
                        frame.castTimer:SetText(text)
                    else
                        frame.castTimer:SetText("")
                    end
                else
                    frame.castTimer:SetText("")
                end
            end
            
            -- Check completion
            if frame.castBarDurationObject and frame.castBarDurationObject.EvaluateElapsedProgress then
                local ok, progress = pcall(frame.castBarDurationObject.EvaluateElapsedProgress, frame.castBarDurationObject)
                if ok and progress then
                    local isComplete = false
                    pcall(function()
                        if progress >= 1 then isComplete = true end
                    end)
                    if isComplete then
                        self:Hide()
                        frame.castBarUseTimerBar = false
                        frame.castBarDurationObject = nil
                        frame.castBarCasting = false
                        frame.castBarChanneling = false
                        return
                    end
                end
            end
        else
            -- Traditional mode
            if frame.castBarStartTime and frame.castBarEndTime and frame.castBarMaxValue then
                local currentTime = GetTime()
                local value, remaining
                
                if frame.castBarChanneling then
                    value = frame.castBarEndTime - currentTime
                    remaining = value
                else
                    value = currentTime - frame.castBarStartTime
                    remaining = frame.castBarMaxValue - value
                end
                
                -- Check completion
                if frame.castBarCasting and value >= frame.castBarMaxValue then
                    self:Hide()
                    frame.castBarCasting = false
                    return
                end
                if frame.castBarChanneling and value <= 0 then
                    self:Hide()
                    frame.castBarChanneling = false
                    return
                end
                
                self:SetValue(value)
                
                if frame.castTimer and unitSettings.castBar.showTimer then
                    frame.castTimer:SetText(string.format("%.1f", remaining > 0 and remaining or 0))
                end
            else
                -- No timing data available, hide unless in preview
                if not (currentOpenPanel == frame.unit) then
                    self:Hide()
                end
            end
        end
    end)
    
    -- Highlight
    frame.highlight = frame:CreateTexture(nil, "HIGHLIGHT")
    frame.highlight:SetAllPoints()
    frame.highlight:SetTexture("Interface\\Buttons\\WHITE8X8")
    frame.highlight:SetVertexColor(1, 1, 1, 0.08)
    frame.highlight:SetBlendMode("ADD")
    
    -- Custom tooltip to avoid secret value errors with SetUnit
    frame:SetScript("OnEnter", function(self)
        if not UnitExists(self.unit) then return end
        
        GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT")
        
        -- Get basic unit info safely
        local name = UnitName(self.unit) or "Unknown"
        local _, class = UnitClass(self.unit)
        local level = UnitLevel(self.unit) or "??"
        local isPlayer = UnitIsPlayer(self.unit)
        
        -- Name with class color for players
        if isPlayer and class then
            local classColor = RAID_CLASS_COLORS[class]
            if classColor then
                GameTooltip:AddLine(name, classColor.r, classColor.g, classColor.b)
            else
                GameTooltip:AddLine(name, 1, 1, 1)
            end
        else
            -- For NPCs, color by reaction
            local r, g, b = 1, 1, 1
            if UnitIsEnemy("player", self.unit) then
                r, g, b = 1, 0.2, 0.2
            elseif UnitIsFriend("player", self.unit) then
                r, g, b = 0.2, 1, 0.2
            else
                r, g, b = 1, 1, 0
            end
            GameTooltip:AddLine(name, r, g, b)
        end
        
        -- Level and class/type info
        if isPlayer then
            local classDisplayName = class and UnitClass(self.unit) or "Unknown"
            GameTooltip:AddLine("Level " .. level .. " " .. classDisplayName, 0.7, 0.7, 0.7)
            
            -- Role for group members
            local role = UnitGroupRolesAssigned(self.unit)
            if role and role ~= "NONE" then
                local roleNames = {TANK = "Tank", HEALER = "Healer", DAMAGER = "Damage"}
                GameTooltip:AddLine(roleNames[role] or role, 0.5, 0.5, 0.5)
            end
        else
            -- For NPCs, show creature type
            local creatureType = UnitCreatureType(self.unit) or ""
            if level == -1 then
                GameTooltip:AddLine("Boss " .. creatureType, 0.7, 0.7, 0.7)
            else
                GameTooltip:AddLine("Level " .. level .. " " .. creatureType, 0.7, 0.7, 0.7)
            end
        end
        
        GameTooltip:Show()
        
        -- Handle mouseover highlight for overlay and border styles
        local mhSettings = settings and settings.general and settings.general.mouseoverHighlight
        if mhSettings and mhSettings.enabled then
            if mhSettings.style == "overlay" and self.mouseoverOverlayFrame then
                self.mouseoverOverlayFrame:Show()
            elseif mhSettings.style == "border" and self.mouseoverBorder then
                self.mouseoverBorder:Show()
            end
        end
    end)
    
    frame:SetScript("OnLeave", function(self)
        GameTooltip:Hide()
        -- Hide mouseover highlights
        if self.mouseoverOverlayFrame then self.mouseoverOverlayFrame:Hide() end
        if self.mouseoverBorder then self.mouseoverBorder:Hide() end
    end)
    
    -- Register state driver for combat-safe visibility based on unit existence
    -- This allows the frame to show/hide during combat without taint
    local stateCondition
    if unit == "player" then
        -- Player frame should always show when enabled
        stateCondition = "show"
    elseif unit == "target" then
        stateCondition = "[@target,exists] show; hide"
    elseif unit == "focus" then
        stateCondition = "[@focus,exists] show; hide"
    elseif unit == "targettarget" then
        stateCondition = "[@targettarget,exists] show; hide"
    elseif unit == "pet" then
        stateCondition = "[@pet,exists] show; hide"
    else
        -- Default: just show
        stateCondition = "show"
    end
    
    RegisterStateDriver(frame, "visibility", stateCondition)
    frame._stateDriverRegistered = true
    
    customFrames[unit] = frame
    
    return frame
end

-- ============================================================================
-- UPDATE FRAME LAYOUT
-- ============================================================================

-- Calculate frame dimensions based on enabled elements
local function CalculateFrameSize(unit)
    local unitSettings = settings[unit]
    if not unitSettings then return 220, 46 end
    
    local fs = unitSettings.frame
    local hbs = unitSettings.healthBar
    local pbs = unitSettings.powerBar
    local ps = unitSettings.portrait
    
    local padding = fs.padding or 1
    local barSpacing = fs.barSpacing or 1
    local bgExtendTop = fs.bgExtendTop or 0
    local bgExtendBottom = fs.bgExtendBottom or 0
    
    -- Calculate height based on enabled bars
    local barsHeight = 0
    
    if hbs.enabled then
        barsHeight = barsHeight + hbs.height
    end
    
    if pbs.enabled then
        if barsHeight > 0 then
            barsHeight = barsHeight + barSpacing
        end
        barsHeight = barsHeight + pbs.height
    end
    
    -- Height is bars + padding + background extensions
    local height = barsHeight + (padding * 2) + bgExtendTop + bgExtendBottom
    
    -- If portrait is enabled and taller than content, use portrait height
    if ps.mode ~= "none" then
        local portraitHeight = ps.size + (padding * 2) + bgExtendTop + bgExtendBottom
        height = math.max(height, portraitHeight)
    end
    
    -- Calculate width (use user-set width)
    local width = fs.width or 220
    
    -- Minimum sizes
    height = math.max(height, 10)
    width = math.max(width, 50)
    
    return width, height
end

local function UpdateFrameLayout(unit)
    local frame = customFrames[unit]
    if not frame then return end
    
    -- Defer layout changes during combat (secure frame restrictions)
    if InCombatLockdown() then
        pendingLayoutUpdates[unit] = true
        return
    end
    
    local unitSettings = settings[unit]
    if not unitSettings then return end
    
    local fs = unitSettings.frame
    local hbs = unitSettings.healthBar
    local pbs = unitSettings.powerBar
    local ps = unitSettings.portrait
    
    local padding = fs.padding or 1
    local barSpacing = fs.barSpacing or 1
    
    -- Calculate frame size if autoSize is enabled
    local frameWidth, frameHeight
    if fs.autoSize then
        frameWidth, frameHeight = CalculateFrameSize(unit)
    else
        frameWidth = fs.width
        frameHeight = fs.height
    end
    
    -- Frame size
    frame:SetSize(frameWidth, frameHeight)
    
    -- Check if using Layout system
    local wrapper = unitFrameWrappers[unit]
    if wrapper then
        -- Frame is child of wrapper - position relative to wrapper
        frame:ClearAllPoints()
        frame:SetPoint("TOPLEFT", wrapper.frame, "TOPLEFT", 0, 0)
        frame:SetPoint("BOTTOMRIGHT", wrapper.frame, "BOTTOMRIGHT", 0, 0)
        
        -- Update wrapper size to match frame
        wrapper:SetSize(frameWidth, frameHeight)
        
        -- Scale applied to wrapper
        wrapper.frame:SetScale(fs.scale or 1.0)
    else
        -- Legacy positioning (not using Layout)
        frame:ClearAllPoints()
        frame:SetPoint(fs.anchor, UIParent, fs.anchor, fs.x, fs.y)
        frame:SetScale(fs.scale or 1.0)
    end
    
    -- Frame backdrop appearance
    if fs.showBackground or fs.showBorder then
        local backdrop = {
            bgFile = fs.showBackground and "Interface\\Buttons\\WHITE8X8" or nil,
            edgeFile = fs.showBorder and "Interface\\Buttons\\WHITE8X8" or nil,
            edgeSize = fs.showBorder and (fs.borderSize or 1) or 0,
            insets = { left = 0, right = 0, top = 0, bottom = 0 },
        }
        frame:SetBackdrop(backdrop)
        
        if fs.showBackground then
            frame:SetBackdropColor(unpack(fs.bgColor))
        end
        if fs.showBorder then
            frame:SetBackdropBorderColor(unpack(fs.borderColor))
        end
    else
        -- No background or border - invisible frame
        frame:SetBackdrop(nil)
    end
    
    -- Calculate portrait offset (only if portrait is inside the frame)
    local portraitWidth = 0
    local portraitOffsetLeft = 0
    local portraitOffsetRight = 0
    local bgExtendTop = fs.bgExtendTop or 0
    
    if ps.mode ~= "none" and not ps.outside then
        -- Portrait is inside the frame, reserve space for it
        portraitWidth = ps.size
        if ps.position == "left" then
            portraitOffsetLeft = portraitWidth + barSpacing
        else
            portraitOffsetRight = portraitWidth + barSpacing
        end
    end
    
    -- Health Bar layout (offset by bgExtendTop)
    if hbs.enabled then
        frame.healthBar:Show()
        frame.healthBar:ClearAllPoints()
        frame.healthBar:SetPoint("TOPLEFT", frame, "TOPLEFT", padding + portraitOffsetLeft, -padding - bgExtendTop)
        frame.healthBar:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -padding - portraitOffsetRight, -padding - bgExtendTop)
        frame.healthBar:SetHeight(hbs.height)
        
        local texturePath = GetTexturePath(hbs.texture)
        frame.healthBar:SetStatusBarTexture(texturePath)
        
        -- Apply bar masking
        if TweaksUI.BarMasking and hbs.maskShape then
            TweaksUI.BarMasking:ApplyToStatusBar(frame.healthBar, hbs.maskShape)
        end
        
        -- Background
        if frame.healthBar.bg then
            if hbs.bgEnabled ~= false then  -- Default to true for backwards compat
                local bgColor = hbs.bgColor or { 0.12, 0.12, 0.12, 0.85 }
                frame.healthBar.bg:SetVertexColor(unpack(bgColor))
                frame.healthBar.bg:Show()
            else
                frame.healthBar.bg:Hide()
            end
        end
        
        -- Border
        if frame.healthBar.borderFrame then
            if hbs.borderEnabled then
                local borderSize = hbs.borderSize or 1
                frame.healthBar.borderFrame:ClearAllPoints()
                frame.healthBar.borderFrame:SetPoint("TOPLEFT", -borderSize, borderSize)
                frame.healthBar.borderFrame:SetPoint("BOTTOMRIGHT", borderSize, -borderSize)
                frame.healthBar.borderFrame:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = borderSize,
                })
                local borderColor = hbs.borderColor or { 0, 0, 0, 1 }
                frame.healthBar.borderFrame:SetBackdropBorderColor(unpack(borderColor))
                frame.healthBar.borderFrame:Show()
            else
                frame.healthBar.borderFrame:Hide()
            end
        end
    else
        frame.healthBar:Hide()
        if frame.healthBar.borderFrame then frame.healthBar.borderFrame:Hide() end
    end
    
    -- Power Bar layout
    if pbs.enabled then
        frame.powerBar:Show()
        frame.powerBar:ClearAllPoints()
        frame.powerBar:SetPoint("TOPLEFT", frame.healthBar, "BOTTOMLEFT", 0, -barSpacing)
        frame.powerBar:SetPoint("TOPRIGHT", frame.healthBar, "BOTTOMRIGHT", 0, -barSpacing)
        frame.powerBar:SetHeight(pbs.height)
        
        local texturePath = GetTexturePath(pbs.texture)
        frame.powerBar:SetStatusBarTexture(texturePath)
        
        -- Apply bar masking
        if TweaksUI.BarMasking and pbs.maskShape then
            TweaksUI.BarMasking:ApplyToStatusBar(frame.powerBar, pbs.maskShape)
        end
        
        -- Background
        if frame.powerBar.bg then
            if pbs.bgEnabled ~= false then  -- Default to true for backwards compat
                local bgColor = pbs.bgColor or { 0.08, 0.08, 0.08, 0.85 }
                frame.powerBar.bg:SetVertexColor(unpack(bgColor))
                frame.powerBar.bg:Show()
            else
                frame.powerBar.bg:Hide()
            end
        end
        
        -- Border
        if frame.powerBar.borderFrame then
            if pbs.borderEnabled then
                local borderSize = pbs.borderSize or 1
                frame.powerBar.borderFrame:ClearAllPoints()
                frame.powerBar.borderFrame:SetPoint("TOPLEFT", -borderSize, borderSize)
                frame.powerBar.borderFrame:SetPoint("BOTTOMRIGHT", borderSize, -borderSize)
                frame.powerBar.borderFrame:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = borderSize,
                })
                local borderColor = pbs.borderColor or { 0, 0, 0, 1 }
                frame.powerBar.borderFrame:SetBackdropBorderColor(unpack(borderColor))
                frame.powerBar.borderFrame:Show()
            else
                frame.powerBar.borderFrame:Hide()
            end
        end
    else
        frame.powerBar:Hide()
        if frame.powerBar.borderFrame then frame.powerBar.borderFrame:Hide() end
    end
    
    -- ========================================================================
    -- ABSORB BAR LAYOUT (Phase 2)
    -- ========================================================================
    local abs = unitSettings.absorbBar
    if abs and abs.enabled and frame.absorbBar then
        frame.absorbBar:ClearAllPoints()
        
        local textOffsetX = abs.textOffsetX or 0
        local textOffsetY = abs.textOffsetY or 0
        local textFontSize = abs.textFontSize or 10
        local fillDirection = abs.fillDirection or "rightToLeft"
        local offsetX = abs.offsetX or 0
        local offsetY = abs.offsetY or 0
        
        -- Apply texture
        local absTexturePath = "Interface\\RaidFrame\\Shield-Fill"
        if LibSharedMedia and abs.texture then
            absTexturePath = LibSharedMedia:Fetch("statusbar", abs.texture) or absTexturePath
        end
        frame.absorbBar:SetStatusBarTexture(absTexturePath)
        
        -- Set fill style based on direction
        local useReverse = (fillDirection == "rightToLeft")
        
        if useReverse then
            frame.absorbBar:SetFillStyle(Enum.StatusBarFillStyle and Enum.StatusBarFillStyle.Reverse or "REVERSE")
        else
            frame.absorbBar:SetFillStyle(Enum.StatusBarFillStyle and Enum.StatusBarFillStyle.Standard or "STANDARD")
        end
        
        if abs.style == "overlay" then
            -- Overlay on health bar with offset support
            frame.absorbBar:SetPoint("TOPLEFT", frame.healthBar, "TOPLEFT", offsetX, offsetY)
            frame.absorbBar:SetPoint("BOTTOMRIGHT", frame.healthBar, "BOTTOMRIGHT", offsetX, offsetY)
            
            -- Position absorb text based on fill direction
            if frame.absorbBar.text then
                frame.absorbBar.text:ClearAllPoints()
                if fillDirection == "rightToLeft" then
                    frame.absorbBar.text:SetPoint("RIGHT", frame.healthBar, "RIGHT", -4 + textOffsetX, textOffsetY)
                else
                    frame.absorbBar.text:SetPoint("LEFT", frame.healthBar, "LEFT", 4 + textOffsetX, textOffsetY)
                end
                frame.absorbBar.text:SetFont(GetFontPath(DEFAULT_FONT), textFontSize, GetFontOutline())
            end
        else
            -- Separate bar below power bar (or health bar if power disabled)
            local barAnchor = pbs.enabled and frame.powerBar or frame.healthBar
            frame.absorbBar:SetPoint("TOPLEFT", barAnchor, "BOTTOMLEFT", offsetX, -barSpacing + offsetY)
            frame.absorbBar:SetPoint("TOPRIGHT", barAnchor, "BOTTOMRIGHT", offsetX, -barSpacing + offsetY)
            frame.absorbBar:SetHeight(abs.height or 10)
            
            -- Position absorb text centered for bar mode
            if frame.absorbBar.text then
                frame.absorbBar.text:ClearAllPoints()
                frame.absorbBar.text:SetPoint("CENTER", frame.absorbBar, "CENTER", textOffsetX, textOffsetY)
                frame.absorbBar.text:SetFont(GetFontPath(DEFAULT_FONT), textFontSize, GetFontOutline())
            end
        end
        
        -- Bar color
        local r, g, b, a = unpack(abs.color or { 0.8, 0.8, 0.2, 0.6 })
        frame.absorbBar:SetStatusBarColor(r, g, b, a)
        
        -- Background
        if frame.absorbBar.bg then
            if abs.bgEnabled then
                local bgR, bgG, bgB, bgA = unpack(abs.bgColor or { 0.1, 0.1, 0.1, 0.6 })
                frame.absorbBar.bg:SetVertexColor(bgR, bgG, bgB, bgA)
                frame.absorbBar.bg:Show()
            else
                frame.absorbBar.bg:Hide()
            end
        end
        
        -- Border
        if frame.absorbBar.borderFrame then
            if abs.borderEnabled then
                local borderSize = abs.borderSize or 1
                frame.absorbBar.borderFrame:SetPoint("TOPLEFT", -borderSize, borderSize)
                frame.absorbBar.borderFrame:SetPoint("BOTTOMRIGHT", borderSize, -borderSize)
                frame.absorbBar.borderFrame:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = borderSize,
                })
                local brR, brG, brB, brA = unpack(abs.borderColor or { 0.3, 0.3, 0.3, 1 })
                frame.absorbBar.borderFrame:SetBackdropBorderColor(brR, brG, brB, brA)
                frame.absorbBar.borderFrame:Show()
            else
                frame.absorbBar.borderFrame:Hide()
            end
        end
        
        -- Label
        if frame.absorbBar.label then
            if abs.showLabel then
                frame.absorbBar.label:SetText(abs.labelText or "Absorb")
                frame.absorbBar.label:SetFont(GetFontPath(DEFAULT_FONT), abs.labelFontSize or 10, GetFontOutline())
                local lblR, lblG, lblB, lblA = unpack(abs.labelColor or { 1, 1, 1, 1 })
                frame.absorbBar.label:SetTextColor(lblR, lblG, lblB, lblA)
                
                frame.absorbBar.label:ClearAllPoints()
                local lblPos = abs.labelPosition or "LEFT"
                local lblOffX = abs.labelOffsetX or 0
                local lblOffY = abs.labelOffsetY or 0
                
                if lblPos == "LEFT" then
                    frame.absorbBar.label:SetPoint("LEFT", frame.absorbBar, "LEFT", 4 + lblOffX, lblOffY)
                elseif lblPos == "RIGHT" then
                    frame.absorbBar.label:SetPoint("RIGHT", frame.absorbBar, "RIGHT", -4 + lblOffX, lblOffY)
                elseif lblPos == "TOP" then
                    frame.absorbBar.label:SetPoint("BOTTOM", frame.absorbBar, "TOP", lblOffX, 2 + lblOffY)
                elseif lblPos == "BOTTOM" then
                    frame.absorbBar.label:SetPoint("TOP", frame.absorbBar, "BOTTOM", lblOffX, -2 + lblOffY)
                else  -- CENTER
                    frame.absorbBar.label:SetPoint("CENTER", frame.absorbBar, "CENTER", lblOffX, lblOffY)
                end
                
                frame.absorbBar.label:Show()
            else
                frame.absorbBar.label:Hide()
            end
        end
        
        frame.absorbBar:Show()
    elseif frame.absorbBar then
        frame.absorbBar:Hide()
        if frame.absorbBar.bg then frame.absorbBar.bg:Hide() end
        if frame.absorbBar.borderFrame then frame.absorbBar.borderFrame:Hide() end
        if frame.absorbBar.label then frame.absorbBar.label:Hide() end
    end
    
    -- ========================================================================
    -- CLASS POWER LAYOUT (Phase 2)
    -- ========================================================================
    local cps = unitSettings.classPower
    if cps and cps.enabled and frame.classPower and unit == "player" then
        local current, max, resourceType = GetSecondaryResourceValues(unit)
        
        if resourceType and max and max > 0 then
            frame.classPower:Show()
            frame.classPower:ClearAllPoints()
            
            -- Position based on setting
            local totalWidth = frame.healthBar:GetWidth()
            local spacing = cps.spacing or 2
            
            if cps.position == "below" then
                local anchor = pbs.enabled and frame.powerBar or frame.healthBar
                frame.classPower:SetPoint("TOPLEFT", anchor, "BOTTOMLEFT", 0, -(cps.offsetY or 0) - barSpacing)
                frame.classPower:SetPoint("TOPRIGHT", anchor, "BOTTOMRIGHT", 0, -(cps.offsetY or 0) - barSpacing)
            elseif cps.position == "above" then
                frame.classPower:SetPoint("BOTTOMLEFT", frame.healthBar, "TOPLEFT", 0, (cps.offsetY or 0) + barSpacing)
                frame.classPower:SetPoint("BOTTOMRIGHT", frame.healthBar, "TOPRIGHT", 0, (cps.offsetY or 0) + barSpacing)
            else  -- inside power bar
                frame.classPower:SetPoint("TOPLEFT", frame.powerBar, "TOPLEFT", 0, 0)
                frame.classPower:SetPoint("TOPRIGHT", frame.powerBar, "TOPRIGHT", 0, 0)
            end
            
            frame.classPower:SetHeight(cps.height or 8)
            
            -- Safety cap: discrete resources never exceed 10 segments
            -- max could be incorrectly large if Stagger (which uses maxHealth) leaks in
            local safeMax = max
            if safeMax > 10 then safeMax = 10 end
            
            -- Layout segments
            local segWidth = (totalWidth - (spacing * (safeMax - 1))) / safeMax
            local r, g, b = 1, 0.8, 0  -- Default gold
            if cps.useResourceColor and resourceType then
                r, g, b = GetResourceColor(resourceType)
            elseif cps.customColor then
                r, g, b = cps.customColor[1], cps.customColor[2], cps.customColor[3]
            end
            
            for i = 1, safeMax do
                local seg = frame.classPower.segments[i]
                if seg then
                    seg:ClearAllPoints()
                    seg:SetPoint("LEFT", frame.classPower, "LEFT", (i - 1) * (segWidth + spacing), 0)
                    seg:SetSize(segWidth, cps.height or 8)
                    
                    -- Set colors
                    seg.bg:SetColorTexture(unpack(cps.bgColor or { 0.15, 0.15, 0.15, 0.8 }))
                    seg.fill:SetColorTexture(r, g, b, 1)
                    seg.fill:Hide()  -- Ensure fill starts hidden, UpdateFrameData will show as needed
                    
                    -- Border
                    if cps.showBorder then
                        seg.border:Show()
                        seg.border:SetBackdropBorderColor(unpack(cps.borderColor or { 0, 0, 0, 1 }))
                    else
                        seg.border:Hide()
                    end
                    
                    seg:Show()
                end
            end
            
            -- Hide extra segments
            for i = safeMax + 1, 10 do
                if frame.classPower.segments[i] then
                    frame.classPower.segments[i]:Hide()
                end
            end
        else
            frame.classPower:Hide()
        end
    elseif frame.classPower then
        frame.classPower:Hide()
    end
    
    -- Helper function to convert hAlign + vAlign to anchor point
    local function GetAnchorFromAlign(hAlign, vAlign)
        hAlign = hAlign or "CENTER"
        vAlign = vAlign or "MIDDLE"
        
        if vAlign == "TOP" then
            if hAlign == "LEFT" then return "TOPLEFT"
            elseif hAlign == "RIGHT" then return "TOPRIGHT"
            else return "TOP" end
        elseif vAlign == "BOTTOM" then
            if hAlign == "LEFT" then return "BOTTOMLEFT"
            elseif hAlign == "RIGHT" then return "BOTTOMRIGHT"
            else return "BOTTOM" end
        else -- MIDDLE
            if hAlign == "LEFT" then return "LEFT"
            elseif hAlign == "RIGHT" then return "RIGHT"
            else return "CENTER" end
        end
    end
    
    -- Health Text layout
    local hts = unitSettings.healthText
    if hts.enabled and hts.format ~= "none" then
        frame.healthText:Show()
        frame.healthText:ClearAllPoints()
        local anchor = GetAnchorFromAlign(hts.hAlign, hts.vAlign)
        frame.healthText:SetPoint(anchor, frame.healthBar, anchor, hts.offsetX, hts.offsetY)
        frame.healthText:SetFont(GetFontPath(DEFAULT_FONT), hts.fontSize, GetFontOutline(hts.fontOutline))
        frame.healthText:SetTextColor(unpack(hts.color))
        frame.healthText:SetJustifyH(hts.hAlign or "CENTER")
        frame.healthText:SetJustifyV(hts.vAlign or "MIDDLE")
    else
        frame.healthText:Hide()
    end
    
    -- Power Text layout
    local pts = unitSettings.powerText
    if pts.enabled and pbs.enabled and pts.format ~= "none" then
        frame.powerText:Show()
        frame.powerText:ClearAllPoints()
        local anchor = GetAnchorFromAlign(pts.hAlign, pts.vAlign)
        frame.powerText:SetPoint(anchor, frame.powerBar, anchor, pts.offsetX, pts.offsetY)
        frame.powerText:SetFont(GetFontPath(DEFAULT_FONT), pts.fontSize, GetFontOutline(pts.fontOutline))
        frame.powerText:SetTextColor(unpack(pts.color))
        frame.powerText:SetJustifyH(pts.hAlign or "CENTER")
        frame.powerText:SetJustifyV(pts.vAlign or "MIDDLE")
    else
        frame.powerText:Hide()
    end
    
    -- Name Text layout
    local nts = unitSettings.nameText
    if nts.enabled then
        frame.nameText:Show()
        frame.nameText:ClearAllPoints()
        
        -- Use simplified anchor-based positioning
        -- anchor field determines where on the frame the text appears
        local anchor = nts.anchor or nts.frameAnchor or "TOP"
        
        -- Derive horizontal alignment from anchor point
        local hAlign = "CENTER"
        if anchor == "LEFT" or anchor == "TOPLEFT" or anchor == "BOTTOMLEFT" then
            hAlign = "LEFT"
        elseif anchor == "RIGHT" or anchor == "TOPRIGHT" or anchor == "BOTTOMRIGHT" then
            hAlign = "RIGHT"
        end
        
        -- Check if we should anchor to health bar (for inside-frame positioning)
        if nts.anchorToHealthBar then
            frame.nameText:SetPoint(anchor, frame.healthBar, anchor, nts.offsetX, nts.offsetY)
        else
            frame.nameText:SetPoint(anchor, frame, anchor, nts.offsetX, nts.offsetY)
        end
        
        frame.nameText:SetFont(GetFontPath(DEFAULT_FONT), nts.fontSize, GetFontOutline(nts.fontOutline))
        frame.nameText:SetJustifyH(hAlign)
        frame.nameText:SetJustifyV(nts.vAlign or "MIDDLE")
    else
        frame.nameText:Hide()
    end
    
    -- Level Text layout
    local lts = unitSettings.levelText
    if lts.enabled then
        frame.levelText:Show()
        frame.levelText:ClearAllPoints()
        
        -- Use simplified anchor-based positioning
        local anchor = lts.anchor or lts.frameAnchor or "TOPRIGHT"
        
        -- Derive horizontal alignment from anchor point
        local hAlign = "CENTER"
        if anchor == "LEFT" or anchor == "TOPLEFT" or anchor == "BOTTOMLEFT" then
            hAlign = "LEFT"
        elseif anchor == "RIGHT" or anchor == "TOPRIGHT" or anchor == "BOTTOMRIGHT" then
            hAlign = "RIGHT"
        end
        
        frame.levelText:SetPoint(anchor, frame, anchor, lts.offsetX, lts.offsetY)
        frame.levelText:SetFont(GetFontPath(DEFAULT_FONT), lts.fontSize, GetFontOutline(lts.fontOutline))
        frame.levelText:SetJustifyH(hAlign)
        frame.levelText:SetJustifyV(lts.vAlign or "MIDDLE")
    else
        frame.levelText:Hide()
    end
    
    -- Portrait layout
    if ps.mode ~= "none" then
        frame.portraitFrame:Show()
        frame.portraitFrame:SetSize(ps.size, ps.size)
        frame.portraitFrame:ClearAllPoints()
        
        if ps.position == "left" then
            frame.portraitFrame:SetPoint("TOPLEFT", frame, "TOPLEFT", padding + ps.offsetX, -padding - bgExtendTop + ps.offsetY)
        else
            frame.portraitFrame:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -padding + ps.offsetX, -padding - bgExtendTop + ps.offsetY)
        end
        
        -- Show appropriate portrait type
        frame.portrait3D:Hide()
        frame.portrait2D:Hide()
        frame.classIcon:Hide()
        
        if ps.mode == "3d" then
            frame.portrait3D:Show()
        elseif ps.mode == "2d" then
            frame.portrait2D:Show()
        elseif ps.mode == "class" then
            frame.classIcon:Show()
        end
    else
        frame.portraitFrame:Hide()
    end
    
    -- Raid Target layout
    local rts = unitSettings.raidTarget
    if rts.enabled then
        frame.raidTarget:ClearAllPoints()
        frame.raidTarget:SetPoint(rts.anchor, frame, rts.frameAnchor, rts.offsetX, rts.offsetY)
        frame.raidTarget:SetSize(rts.size, rts.size)
    end
    
    -- Role Icon layout
    local ris = unitSettings.roleIcon
    if ris and ris.enabled then
        frame.roleIconFrame:ClearAllPoints()
        frame.roleIconFrame:SetPoint(ris.anchor, frame, ris.frameAnchor, ris.offsetX, ris.offsetY)
        frame.roleIconFrame:SetSize(ris.size, ris.size)
    end
    
    -- Debuff Indicators layout
    local dis = unitSettings.debuffIndicators
    -- Show during preview even if disabled (so user can see layout)
    local showDebuffIndicators = dis and (dis.enabled or IsPreviewEnabled(unit))
    if showDebuffIndicators then
        frame.debuffIndicators:Show()
        frame.debuffIndicators:ClearAllPoints()
        frame.debuffIndicators:SetPoint(dis.position, frame, dis.position, dis.offsetX, dis.offsetY)
        
        -- Size and position individual indicators
        local xOffset = 0
        for debuffType, indicator in pairs(frame.debuffIndicators.indicators) do
            indicator:SetSize(dis.size, dis.size)
            indicator:ClearAllPoints()
            indicator:SetPoint("LEFT", frame.debuffIndicators, "LEFT", xOffset, 0)
            
            xOffset = xOffset + dis.size + 2
        end
        
        frame.debuffIndicators:SetSize(xOffset, dis.size)
    else
        frame.debuffIndicators:Hide()
    end
    
    -- ========================================================================
    -- STATUS INDICATORS LAYOUT (Combat & Resting)
    -- Uses HIGH strata container frames
    -- ========================================================================
    local sis = unitSettings.statusIndicators
    if sis and frame.combatFrame and frame.restingFrame then
        if sis.enabled then
            -- Position container frames (they share the same position)
            frame.combatFrame:ClearAllPoints()
            frame.combatFrame:SetPoint(sis.anchor, frame, sis.frameAnchor, sis.offsetX, sis.offsetY)
            frame.combatFrame:SetSize(sis.size, sis.size)
            
            frame.restingFrame:ClearAllPoints()
            frame.restingFrame:SetPoint(sis.anchor, frame, sis.frameAnchor, sis.offsetX, sis.offsetY)
            frame.restingFrame:SetSize(sis.size, sis.size)
        else
            frame.combatFrame:Hide()
            frame.restingFrame:Hide()
        end
    end
    
    -- ========================================================================
    -- LEADER INDICATOR LAYOUT
    -- ========================================================================
    local lis = unitSettings.leaderIndicator
    if lis and frame.leaderFrame then
        if lis.enabled then
            frame.leaderFrame:ClearAllPoints()
            frame.leaderFrame:SetPoint(lis.anchor, frame, lis.frameAnchor, lis.offsetX, lis.offsetY)
            frame.leaderFrame:SetSize(lis.size, lis.size)
        else
            frame.leaderIndicator:Hide()
        end
    end
    
    -- ========================================================================
    -- SUMMON INDICATOR LAYOUT
    -- ========================================================================
    local sis2 = unitSettings.summonIndicator
    if sis2 and frame.summonFrame then
        if sis2.enabled then
            frame.summonFrame:ClearAllPoints()
            frame.summonFrame:SetPoint(sis2.anchor, frame, sis2.frameAnchor, sis2.offsetX, sis2.offsetY)
            frame.summonFrame:SetSize(sis2.size, sis2.size)
        else
            frame.summonFrame:Hide()
        end
    end
    
    -- ========================================================================
    -- MOUSEOVER HIGHLIGHT LAYOUT (Universal from general settings)
    -- Two styles: overlay, border
    -- ========================================================================
    local mhs = settings.general and settings.general.mouseoverHighlight
    if mhs and frame.mouseoverOverlayFrame and frame.mouseoverBorder then
        -- Hide all styles first
        frame.mouseoverOverlayFrame:Hide()
        frame.mouseoverBorder:Hide()
        
        if mhs.enabled then
            local r, g, b, a = unpack(mhs.color or { 1, 1, 1, 0.15 })
            local style = mhs.style or "overlay"
            
            -- Determine anchor - use healthBar if available, otherwise frame
            local anchor = frame.healthBar or frame
            
            if style == "overlay" then
                frame.mouseoverOverlayFrame:ClearAllPoints()
                frame.mouseoverOverlayFrame:SetAllPoints(anchor)
                frame.mouseoverOverlay:SetColorTexture(r, g, b, a)
                -- Visibility handled by OnEnter/OnLeave (HIGH strata, manual control)
            elseif style == "border" then
                local thickness = mhs.borderThickness or 2
                frame.mouseoverBorder:ClearAllPoints()
                frame.mouseoverBorder:SetPoint("TOPLEFT", anchor, "TOPLEFT", -thickness, thickness)
                frame.mouseoverBorder:SetPoint("BOTTOMRIGHT", anchor, "BOTTOMRIGHT", thickness, -thickness)
                frame.mouseoverBorder:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = thickness,
                })
                frame.mouseoverBorder:SetBackdropBorderColor(r, g, b, a)
                -- Visibility handled by OnEnter/OnLeave set up during frame creation
            end
        end
    end
    
    -- ========================================================================
    -- TARGET HIGHLIGHT LAYOUT
    -- ========================================================================
    local ths = unitSettings.targetHighlight
    if ths and frame.targetHighlight and frame.targetHighlightGlow then
        if ths.enabled then
            local r, g, b, a = unpack(ths.color or { 1, 1, 1, 1 })
            
            if ths.style == "glow" then
                -- Use glow style
                frame.targetHighlight:Hide()
                frame.targetHighlightGlow:SetVertexColor(r, g, b, a * 0.6)
                -- Visibility handled by UpdateTargetHighlight
            else
                -- Use border style (default)
                frame.targetHighlightGlow:Hide()
                local thickness = ths.thickness or 2
                frame.targetHighlight:ClearAllPoints()
                frame.targetHighlight:SetPoint("TOPLEFT", frame, "TOPLEFT", -thickness, thickness)
                frame.targetHighlight:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", thickness, -thickness)
                frame.targetHighlight:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = thickness,
                })
                frame.targetHighlight:SetBackdropBorderColor(r, g, b, a)
                -- Visibility handled by UpdateTargetHighlight
            end
        else
            frame.targetHighlight:Hide()
            frame.targetHighlightGlow:Hide()
        end
    end
    
    -- Cast Bar layout
    local cbs = unitSettings.castBar
    if cbs and cbs.enabled and frame.castBar then
        local cbHeight = cbs.height or 12
        frame.castBar:ClearAllPoints()
        frame.castBar:SetHeight(cbHeight)
        
        if cbs.attachedTo == "health" then
            -- Inside the health bar
            frame.castBar:SetPoint("TOPLEFT", frame.healthBar, "TOPLEFT", 0, 0)
            frame.castBar:SetPoint("BOTTOMRIGHT", frame.healthBar, "BOTTOMRIGHT", 0, 0)
        else
            -- Below the frame
            local offsetY = cbs.offsetY or 0
            frame.castBar:SetPoint("TOPLEFT", frame, "BOTTOMLEFT", padding, -1 + offsetY)
            frame.castBar:SetPoint("TOPRIGHT", frame, "BOTTOMRIGHT", -padding, -1 + offsetY)
        end
        
        -- Apply texture
        local cbTexturePath = "Interface\\RaidFrame\\Raid-Bar-Hp-Fill"
        if LibSharedMedia and cbs.texture then
            cbTexturePath = LibSharedMedia:Fetch("statusbar", cbs.texture) or cbTexturePath
        end
        frame.castBar:SetStatusBarTexture(cbTexturePath)
        
        -- Apply cast color
        local cbColor = cbs.color or { 1.0, 0.7, 0, 1 }
        frame.castBar:SetStatusBarColor(unpack(cbColor))
        
        -- Background
        if frame.castBar.bg then
            if cbs.bgEnabled ~= false then  -- Default to true
                local bgColor = cbs.bgColor or { 0.1, 0.1, 0.1, 0.8 }
                frame.castBar.bg:SetVertexColor(unpack(bgColor))
                frame.castBar.bg:Show()
            else
                frame.castBar.bg:Hide()
            end
        end
        
        -- Border
        if frame.castBar.borderFrame then
            if cbs.borderEnabled then
                local borderSize = cbs.borderSize or 1
                frame.castBar.borderFrame:ClearAllPoints()
                frame.castBar.borderFrame:SetPoint("TOPLEFT", -borderSize, borderSize)
                frame.castBar.borderFrame:SetPoint("BOTTOMRIGHT", borderSize, -borderSize)
                frame.castBar.borderFrame:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = borderSize,
                })
                local borderColor = cbs.borderColor or { 0, 0, 0, 1 }
                frame.castBar.borderFrame:SetBackdropBorderColor(unpack(borderColor))
                frame.castBar.borderFrame:Show()
            else
                frame.castBar.borderFrame:Hide()
            end
        end
        
        -- Update cast bar elements visibility/position based on settings
        if frame.castIcon then
            if cbs.showIcon then
                frame.castIcon:SetSize(cbHeight, cbHeight)
                frame.castIcon:ClearAllPoints()
                frame.castIcon:SetPoint("LEFT", frame.castBar, "LEFT", 1, 0)
                frame.castIcon:Show()
            else
                frame.castIcon:Hide()
            end
        end
        
        if frame.castText then
            if cbs.showSpellName then
                frame.castText:ClearAllPoints()
                local leftOffset = (cbs.showIcon and (cbHeight + 2)) or 2
                frame.castText:SetPoint("LEFT", frame.castBar, "LEFT", leftOffset, 0)
                frame.castText:Show()
            else
                frame.castText:Hide()
            end
        end
        
        if frame.castTimer then
            if cbs.showTimer then
                frame.castTimer:Show()
            else
                frame.castTimer:Hide()
            end
        end
    elseif frame.castBar then
        frame.castBar:Hide()
        if frame.castBar.borderFrame then frame.castBar.borderFrame:Hide() end
    end
    
    -- ========================================================================
    -- AURA DISPLAY LAYOUT (Phase 3)
    -- ========================================================================
    
    -- Helper to layout aura icons in a container
    local function LayoutAuraContainer(container, auraSettings, frameRef)
        if not container or not auraSettings then return end
        
        if not auraSettings.enabled then
            container:Hide()
            return
        end
        
        container:Show()
        container:ClearAllPoints()
        container:SetPoint(auraSettings.anchor, frameRef, auraSettings.frameAnchor, 
                          auraSettings.offsetX or 0, auraSettings.offsetY or 0)
        
        local size = auraSettings.size or 20
        local spacing = auraSettings.spacing or 2
        local maxAuras = auraSettings.maxAuras or 8
        local wrapAfter = auraSettings.wrapAfter or 4
        local growDir = auraSettings.growDirection or "RIGHT"
        local wrapDir = auraSettings.wrapDirection or "DOWN"
        
        -- Calculate container size based on max icons
        local cols = math.min(maxAuras, wrapAfter)
        local rows = math.ceil(maxAuras / wrapAfter)
        local containerWidth = (cols * size) + ((cols - 1) * spacing)
        local containerHeight = (rows * size) + ((rows - 1) * spacing)
        container:SetSize(containerWidth, containerHeight)
        
        -- Position each icon in the container
        for i, icon in ipairs(container.icons) do
            if i <= maxAuras then
                icon:SetSize(size, size)
                icon:ClearAllPoints()
                
                local row = math.floor((i - 1) / wrapAfter)
                local col = (i - 1) % wrapAfter
                
                -- Calculate position based on grow direction
                local xOffset, yOffset = 0, 0
                
                if growDir == "RIGHT" then
                    xOffset = col * (size + spacing)
                elseif growDir == "LEFT" then
                    xOffset = -col * (size + spacing)
                elseif growDir == "UP" then
                    yOffset = col * (size + spacing)
                elseif growDir == "DOWN" then
                    yOffset = -col * (size + spacing)
                end
                
                -- Apply wrap direction offset
                if wrapDir == "DOWN" then
                    yOffset = yOffset - (row * (size + spacing))
                elseif wrapDir == "UP" then
                    yOffset = yOffset + (row * (size + spacing))
                elseif wrapDir == "LEFT" then
                    xOffset = xOffset - (row * (size + spacing))
                elseif wrapDir == "RIGHT" then
                    xOffset = xOffset + (row * (size + spacing))
                end
                
                -- Anchor based on grow direction
                local anchor = "TOPLEFT"
                if growDir == "LEFT" then anchor = "TOPRIGHT"
                elseif growDir == "UP" then anchor = "BOTTOMLEFT"
                elseif growDir == "DOWN" then anchor = "TOPLEFT" end
                
                icon:SetPoint(anchor, container, anchor, xOffset, yOffset)
                
                -- Update icon sub-elements
                icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), auraSettings.stackFontSize or 10, GetFontOutline())
                icon.stackText:ClearAllPoints()
                icon.stackText:SetPoint(auraSettings.stackPosition or "BOTTOMRIGHT", 0, 0)
                
                -- Duration text is handled by Blizzard's CooldownFrameTemplate now
                if icon.durationText then
                    icon.durationText:Hide()
                end
                
                -- Border styling
                if auraSettings.showBorder then
                    icon.border:Show()
                    if auraSettings.borderColor then
                        icon.border:SetVertexColor(unpack(auraSettings.borderColor))
                    end
                else
                    icon.border:Hide()
                end
            end
        end
        
        -- Store settings reference for update function
        container.settings = auraSettings
    end
    
    -- Layout buffs container
    if unitSettings.buffs and frame.buffsContainer then
        LayoutAuraContainer(frame.buffsContainer, unitSettings.buffs, frame)
    end
    
    -- Layout debuffs container
    if unitSettings.debuffs and frame.debuffsContainer then
        LayoutAuraContainer(frame.debuffsContainer, unitSettings.debuffs, frame)
    end
end

-- ============================================================================
-- UPDATE FRAME DATA
-- ============================================================================

-- Helper function to get simulated or real unit data
local function GetUnitData(unit)
    if IsPreviewEnabled(unit) and SIMULATED_UNITS[unit] then
        return SIMULATED_UNITS[unit], true
    end
    return nil, false
end

-- UpdateFrameData updates individual unit frames with current data
-- Forward declared at top of file for ticker access
UpdateFrameData = function(unit)
    local frame = customFrames[unit]
    if not frame then return end
    
    local simData, isSimulated = GetUnitData(unit)
    
    -- Check if unit exists (or we're in simulation mode)
    -- Note: For frames with state drivers, visibility is handled by the driver,
    -- but we still need to return early if there's no unit data to display
    if not isSimulated and not UnitExists(unit) then
        -- For frames without state drivers, hide them (legacy behavior)
        if not frame._stateDriverRegistered and not InCombatLockdown() then
            frame:Hide()
        end
        return
    end
    
    local unitSettings = settings[unit]
    if not unitSettings or not unitSettings.enabled then
        if not InCombatLockdown() then
            frame:Hide()
        end
        return
    end
    
    -- For frames with state drivers, don't call Show() - the driver handles visibility
    -- For frames without state drivers (legacy), show the frame
    if not frame._stateDriverRegistered and not InCombatLockdown() then
        frame:Show()
    end
    
    -- Health bar - use percent-based approach for Midnight secret value compatibility
    -- Just pass the value straight through - StatusBar handles secrets natively
    if unitSettings.healthBar.enabled then
        frame.healthBar:SetMinMaxValues(0, 100)
        local healthPct
        if isSimulated then
            healthPct = (simData.maxHealth > 0) and ((simData.health / simData.maxHealth) * 100) or 100
        else
            -- Use SafeUnitHealthPercent for Midnight compatibility
            healthPct = SafeUnitHealthPercent(unit, true) or 100
        end
        -- Use smooth animation if available (Midnight Beta 3+)
        SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
        
        local hbs = unitSettings.healthBar
        local r, g, b
        
        if hbs.colorMode == "class" then
            if isSimulated then
                local classColor = RAID_CLASS_COLORS[simData.class]
                if classColor then
                    r, g, b = classColor.r, classColor.g, classColor.b
                else
                    r, g, b = 1, 1, 1
                end
            else
                r, g, b = GetClassColor(unit)
            end
        elseif hbs.colorMode == "reaction" then
            if isSimulated then
                r, g, b = 0, 1, 0  -- Friendly for simulated
            else
                r, g, b = GetReactionColor(unit)
            end
        elseif hbs.colorMode == "gradient" then
            -- Use Midnight color curve if available, otherwise fallback
            if isSimulated then
                local pct = (simData.maxHealth > 0) and (simData.health / simData.maxHealth) or 1
                r, g, b = GetHealthGradientColor(pct)
            else
                -- Try using Midnight UnitHealthPercent with curve
                local gr, gg, gb = GetHealthGradientColorMidnight(unit, nil)
                r, g, b = gr, gg, gb
            end
        else
            r, g, b = hbs.customColor[1], hbs.customColor[2], hbs.customColor[3]
        end
        
        frame.healthBar:SetStatusBarColor(r, g, b)
    end
    
    -- Health text - build text based on format
    -- In Midnight Beta, use curve-based APIs that handle secret values natively
    local hts = unitSettings.healthText
    if hts.enabled and hts.format ~= "none" then
        local text = ""
        local health, maxHealth
        
        if isSimulated then
            health = simData.health
            maxHealth = simData.maxHealth
            -- For simulated data, we can do direct calculation
            local pct = (maxHealth > 0) and (health / maxHealth * 100) or 0
            
            local function SimFormatNumber(value)
                if hts.abbreviate then
                    return AbbreviateNumber(value) or tostring(value)
                else
                    return BreakUpLargeNumbers(value) or tostring(value)
                end
            end
            
            if hts.format == "current" then
                text = SimFormatNumber(health)
            elseif hts.format == "max" then
                text = SimFormatNumber(maxHealth)
            elseif hts.format == "percent" then
                text = string.format("%.0f%%", pct)
            elseif hts.format == "current_max" then
                text = SimFormatNumber(health) .. " / " .. SimFormatNumber(maxHealth)
            elseif hts.format == "current_percent" then
                text = SimFormatNumber(health) .. " | " .. string.format("%.0f%%", pct)
            elseif hts.format == "percent_current" then
                text = string.format("%.0f%%", pct) .. " | " .. SimFormatNumber(health)
            elseif hts.format == "deficit" then
                local deficit = maxHealth - health
                if deficit > 0 then
                    text = "-" .. SimFormatNumber(deficit)
                end
            elseif hts.format == "deficit_percent" then
                if pct < 100 then
                    text = string.format("-%.0f%%", 100 - pct)
                end
            end
        else
            -- Real unit - use Midnight curve APIs for secret value handling
            health = UnitHealth(unit)
            maxHealth = UnitHealthMax(unit)
            
            -- Helper to format numbers (handles secrets via AbbreviateLargeNumbers)
            local function SafeFormatNumber(value)
                if value == nil then return "" end
                if hts.abbreviate and AbbreviateLargeNumbers then
                    return AbbreviateLargeNumbers(value) or ""
                elseif BreakUpLargeNumbers then
                    return BreakUpLargeNumbers(value) or ""
                end
                return tostring(value or 0)
            end
            
            if hts.format == "current" then
                text = SafeFormatNumber(health)
            elseif hts.format == "max" then
                text = SafeFormatNumber(maxHealth)
            elseif hts.format == "percent" then
                local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
                if pct then
                    text = string.format("%.0f%%", pct)
                else
                    text = "?%"
                end
            elseif hts.format == "current_max" then
                text = SafeFormatNumber(health) .. " / " .. SafeFormatNumber(maxHealth)
            elseif hts.format == "current_percent" then
                local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
                local pctStr = pct and string.format("%.0f%%", pct) or "?%"
                text = SafeFormatNumber(health) .. " | " .. pctStr
            elseif hts.format == "percent_current" then
                local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
                local pctStr = pct and string.format("%.0f%%", pct) or "?%"
                text = pctStr .. " | " .. SafeFormatNumber(health)
            elseif hts.format == "deficit" then
                if UnitHealthMissing then
                    local missing = UnitHealthMissing(unit)
                    local missingStr = SafeFormatNumber(missing)
                    if C_StringUtil and C_StringUtil.WrapString then
                        text = C_StringUtil.WrapString(missingStr, "-", "")
                    else
                        text = string.format("-%s", missingStr)
                    end
                else
                    text = SafeFormatNumber(health)
                end
            elseif hts.format == "deficit_percent" then
                local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
                if pct and pct < 100 then
                    text = string.format("-%.0f%%", 100 - pct)
                else
                    text = ""
                end
            end
        end
        
        frame.healthText:SetText(text)
        
        -- Color by health - use Midnight curve if available
        if hts.colorByHealth then
            if isSimulated then
                local pct = (simData.maxHealth > 0) and (simData.health / simData.maxHealth) or 1
                local r, g, b = GetHealthGradientColor(pct)
                frame.healthText:SetTextColor(r, g, b)
            else
                -- Try using Midnight health gradient curve
                local r, g, b = GetHealthGradientColorMidnight(unit, nil)
                frame.healthText:SetTextColor(r, g, b)
            end
        end
    end
    
    -- Power bar - pass values directly to StatusBar
    if unitSettings.powerBar.enabled then
        local power, maxPower
        if isSimulated then
            power = simData.power
            maxPower = simData.maxPower
        else
            power = UnitPower(unit)
            maxPower = UnitPowerMax(unit)
        end
        
        frame.powerBar:SetMinMaxValues(0, maxPower)
        -- Use smooth animation if available (Midnight Beta 3+)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
        
        local pbs = unitSettings.powerBar
        local r, g, b
        
        if pbs.colorMode == "power" then
            if isSimulated then
                -- Use power type colors for simulation
                local powerColors = {
                    [0] = { 0.0, 0.0, 1.0 },   -- Mana (blue)
                    [1] = { 1.0, 0.0, 0.0 },   -- Rage (red)
                    [2] = { 1.0, 0.5, 0.25 },  -- Focus (orange)
                    [3] = { 1.0, 1.0, 0.0 },   -- Energy (yellow)
                    [6] = { 0.0, 0.82, 1.0 },  -- Runic Power (light blue)
                }
                local powerType = simData.powerType or 0
                local pc = powerColors[powerType] or { 0.5, 0.5, 0.5 }
                r, g, b = pc[1], pc[2], pc[3]
            else
                r, g, b = GetPowerColor(unit)
            end
        else
            r, g, b = pbs.customColor[1], pbs.customColor[2], pbs.customColor[3]
        end
        
        frame.powerBar:SetStatusBarColor(r, g, b)
        frame.powerBar:Show()
    end
    
    -- Power text
    local pts = unitSettings.powerText
    if pts.enabled and unitSettings.powerBar.enabled then
        local text = ""
        local power, maxPower, pct
        
        if isSimulated then
            power = simData.power
            maxPower = simData.maxPower
            pct = (maxPower and maxPower > 0) and (power / maxPower * 100) or 0
        else
            power = UnitPower(unit)
            maxPower = UnitPowerMax(unit)
            -- Try to calculate percentage - may fail with secret values
            local success, result = pcall(function()
                return (power / maxPower) * 100
            end)
            pct = success and result or 0
        end
        
        -- Helper to safely format power values
        -- Respects the abbreviate setting
        local function SafeFormatNumber(value)
            if value == nil then return "" end
            local success, result = pcall(function()
                if pts.abbreviate then
                    return AbbreviateLargeNumbers(value) or ""
                else
                    return BreakUpLargeNumbers(value) or ""
                end
            end)
            return success and result or ""
        end
        
        if pts.format == "current" then
            text = SafeFormatNumber(power)
        elseif pts.format == "max" then
            text = SafeFormatNumber(maxPower)
        elseif pts.format == "percent" then
            text = string.format("%.0f%%", pct)
        elseif pts.format == "current_max" then
            text = SafeFormatNumber(power) .. " / " .. SafeFormatNumber(maxPower)
        end
        
        frame.powerText:SetText(text)
    end
    
    -- ========================================================================
    -- ABSORB BAR UPDATE (Phase 2)
    -- Note: In Midnight Beta, UnitGetTotalAbsorbs returns secret values
    -- StatusBars handle secret values natively via SetValue()
    -- ========================================================================
    local abs = unitSettings.absorbBar
    if abs and abs.enabled and frame.absorbBar then
        local absorb, maxHealth, health
        
        if isSimulated then
            -- Use simulated absorb value from preview data
            maxHealth = simData.maxHealth or 100000
            health = simData.health or 85000
            absorb = simData.absorb or 0
        else
            absorb = UnitGetTotalAbsorbs and UnitGetTotalAbsorbs(unit)
            maxHealth = UnitHealthMax(unit) or 1
            health = UnitHealth(unit)
        end
        
        -- For simulation, absorb is always a normal number
        -- For live, StatusBars handle secret values natively
        if isSimulated then
            -- Simulation mode - we can do normal math
            if absorb and absorb > 0 then
                frame.absorbBar:SetMinMaxValues(0, maxHealth)
                
                if abs.style == "overlay" then
                    frame.absorbBar:SetValue(absorb)
                else
                    frame.absorbBar:SetValue(absorb)
                end
                
                -- Update absorb text
                if abs.showText and frame.absorbBar.text then
                    local text = ""
                    if abs.textFormat == "current" then
                        text = AbbreviateNumber(absorb)
                    elseif abs.textFormat == "percent" then
                        local pct = (absorb / maxHealth) * 100
                        text = string.format("%.0f%%", pct)
                    elseif abs.textFormat == "current_max" then
                        text = AbbreviateNumber(absorb) .. " / " .. AbbreviateNumber(maxHealth)
                    end
                    frame.absorbBar.text:SetText(text)
                    frame.absorbBar.text:Show()
                elseif frame.absorbBar.text then
                    frame.absorbBar.text:Hide()
                end
                
                frame.absorbBar:Show()
            else
                frame.absorbBar:Hide()
                if frame.absorbBar.text then
                    frame.absorbBar.text:Hide()
                end
            end
        else
            -- Live mode - absorb might be a secret value
            if absorb ~= nil then
                frame.absorbBar:SetMinMaxValues(0, maxHealth)
                
                if abs.style == "overlay" then
                    frame.absorbBar:SetValue(absorb)
                else
                    frame.absorbBar:SetValue(absorb)
                end
                
                -- Update absorb text (use SetFormattedText for secret values)
                if abs.showText and frame.absorbBar.text then
                    if abs.textFormat == "current" then
                        -- Use AbbreviateLargeNumbers which handles secrets
                        local success, abbrev = pcall(function()
                            return AbbreviateLargeNumbers and AbbreviateLargeNumbers(absorb) or absorb
                        end)
                        if success then
                            frame.absorbBar.text:SetText(abbrev)
                        else
                            frame.absorbBar.text:SetFormattedText("%d", absorb)
                        end
                    elseif abs.textFormat == "percent" then
                        -- Can't calculate percent with secret values easily
                        frame.absorbBar.text:SetFormattedText("%d", absorb)
                    elseif abs.textFormat == "current_max" then
                        local success, abbrev = pcall(function()
                            return AbbreviateLargeNumbers and AbbreviateLargeNumbers(absorb) or absorb
                        end)
                        if success then
                            frame.absorbBar.text:SetText(abbrev)
                        else
                            frame.absorbBar.text:SetFormattedText("%d", absorb)
                        end
                    end
                    frame.absorbBar.text:Show()
                elseif frame.absorbBar.text then
                    frame.absorbBar.text:Hide()
                end
                
                frame.absorbBar:Show()
            else
                frame.absorbBar:Hide()
                if frame.absorbBar.text then
                    frame.absorbBar.text:Hide()
                end
            end
        end
        
        -- Hide overglow (can't compare values in Midnight)
        if frame.absorbBar.overGlow then
            frame.absorbBar.overGlow:Hide()
        end
    elseif frame.absorbBar then
        frame.absorbBar:Hide()
        if frame.absorbBar.text then
            frame.absorbBar.text:Hide()
        end
    end
    
    -- ========================================================================
    -- CLASS POWER UPDATE (Phase 2)
    -- ========================================================================
    local cps = unitSettings.classPower
    if cps and cps.enabled and frame.classPower and unit == "player" then
        local current, max, resourceType, rawValue
        
        if isSimulated then
            -- Simulate some class power for preview
            current = 3
            max = 5
            resourceType = Enum.PowerType.ComboPoints  -- Default for simulation
        else
            current, max, resourceType, rawValue = GetSecondaryResourceValues(unit)
        end
        
        if resourceType and max and max > 0 then
            -- Check if continuous resource (stagger) vs discrete (combo points)
            if IsContinuousResource(resourceType) then
                -- CONTINUOUS RESOURCE DISPLAY (Status Bar)
                -- Hide segments, show status bar
                for i = 1, #frame.classPower.segments do
                    if frame.classPower.segments[i] then
                        frame.classPower.segments[i]:Hide()
                    end
                end
                
                -- Update status bar (current is raw stagger, max is maxHealth for stagger)
                frame.classPower.statusBar:SetMinMaxValues(0, max)
                frame.classPower.statusBar:SetValue(current)
                
                -- Get stagger color based on level (safely handle secret values)
                local r, g, b = 0.52, 1, 0.52  -- Light green default
                if resourceType == SPECIAL_RESOURCES.STAGGER then
                    -- Calculate stagger percentage safely
                    local pctOk, staggerPct = pcall(function()
                        if max > 0 then return (current / max) * 100 end
                        return 0
                    end)
                    
                    if pctOk then
                        local heavyOk, isHeavy = pcall(function() return staggerPct >= 60 end)
                        local modOk, isModerate = pcall(function() return staggerPct >= 30 end)
                        
                        if heavyOk and isHeavy then
                            r, g, b = 1, 0.35, 0.35  -- Red (heavy)
                        elseif modOk and isModerate then
                            r, g, b = 1, 0.85, 0.35  -- Yellow (moderate)
                        end
                    end
                end
                frame.classPower.statusBar:SetStatusBarColor(r, g, b, 1)
                
                -- Show text based on format setting
                local textFormat = cps.staggerTextFormat or "percent"
                if resourceType == SPECIAL_RESOURCES.STAGGER then
                    -- Calculate stagger percent for text
                    local pctOk, staggerPct = pcall(function()
                        if max > 0 then return (current / max) * 100 end
                        return 0
                    end)
                    
                    if textFormat == "amount" then
                        -- Use AbbreviateLargeNumbers for secret-safe formatting
                        frame.classPower.statusBarText:SetText(AbbreviateLargeNumbers(current))
                    elseif textFormat == "percent" then
                        if pctOk then
                            frame.classPower.statusBarText:SetFormattedText("%.0f%%", staggerPct)
                        else
                            frame.classPower.statusBarText:SetText(AbbreviateLargeNumbers(current))
                        end
                    elseif textFormat == "both" then
                        local amountStr = AbbreviateLargeNumbers(current)
                        if pctOk then
                            frame.classPower.statusBarText:SetText(amountStr .. " (" .. string.format("%.0f%%", staggerPct) .. ")")
                        else
                            frame.classPower.statusBarText:SetText(amountStr)
                        end
                    end
                else
                    frame.classPower.statusBarText:SetFormattedText("%.0f%%", current)
                end
                frame.classPower.statusBarText:Show()
                
                frame.classPower.statusBar:Show()
                frame.classPower.statusBarBorder:Show()
            else
                -- DISCRETE RESOURCE DISPLAY (Segments)
                -- Hide status bar, show segments
                frame.classPower.statusBar:Hide()
                frame.classPower.statusBarBorder:Hide()
                
                -- Safety cap: discrete resources never exceed 10 segments
                local safeMax = max
                if safeMax > 10 then safeMax = 10 end
                
                -- Ensure current is a valid number (safety for edge cases)
                local safeCurrent = (type(current) == "number") and current or 0
                
                -- Update segment visibility
                for i = 1, safeMax do
                    local seg = frame.classPower.segments[i]
                    if seg then
                        if safeCurrent >= i then
                            seg.fill:Show()
                        else
                            seg.fill:Hide()
                        end
                    end
                end
                
                -- Show text for discrete resources if enabled
                if cps.showText and frame.classPower.statusBarText then
                    frame.classPower.statusBarText:ClearAllPoints()
                    frame.classPower.statusBarText:SetPoint("CENTER", frame.classPower, "CENTER", 0, 0)
                    local textFormat = cps.textFormat or "current"
                    if textFormat == "current_max" then
                        frame.classPower.statusBarText:SetFormattedText("%d/%d", current, max)
                    else
                        frame.classPower.statusBarText:SetFormattedText("%d", current)
                    end
                    frame.classPower.statusBarText:Show()
                else
                    frame.classPower.statusBarText:Hide()
                end
            end
            frame.classPower:Show()
        else
            frame.classPower:Hide()
        end
    elseif frame.classPower then
        frame.classPower:Hide()
    end
    
    -- Name
    local nts = unitSettings.nameText
    if nts.enabled then
        local name
        if isSimulated then
            name = simData.name
        else
            name = UnitName(unit)
        end
        
        if type(name) == "string" then
            frame.nameText:SetText(name)
        else
            -- Keep existing text if secret value
        end
        
        local r, g, b
        if nts.colorMode == "class" then
            if isSimulated then
                local classColor = RAID_CLASS_COLORS[simData.class]
                if classColor then
                    r, g, b = classColor.r, classColor.g, classColor.b
                else
                    r, g, b = 1, 1, 1
                end
            else
                r, g, b = GetClassColor(unit)
            end
        elseif nts.colorMode == "reaction" then
            if isSimulated then
                r, g, b = 0, 1, 0  -- Friendly
            else
                r, g, b = GetReactionColor(unit)
            end
        elseif nts.colorMode == "custom" then
            r, g, b = nts.customColor[1], nts.customColor[2], nts.customColor[3]
        else
            r, g, b = 1, 1, 1
        end
        frame.nameText:SetTextColor(r, g, b)
    end
    
    -- Level - wrap in pcall since type() returns "number" for secret values
    local lts = unitSettings.levelText
    if lts.enabled then
        if isSimulated then
            -- Use simulated level data
            local level = simData.level or 80
            local playerLevel = UnitLevel("player") or 80
            
            if lts.hideAtMaxLevel and level == 80 then
                frame.levelText:Hide()
            else
                frame.levelText:Show()
                local levelText = ""
                local color = "|cffFFFF00"  -- Yellow for same level range
                levelText = color .. level .. "|r"
                frame.levelText:SetText(levelText)
            end
        else
            local success = pcall(function()
            local level = UnitLevel(unit)
            local playerLevel = UnitLevel("player")
            
            -- Force arithmetic to trigger error on secret values
            local test = level + 0
            test = playerLevel + 0
            
            local maxLevel = 80
            if GetMaxPlayerLevel then
                local ml = GetMaxPlayerLevel()
                if type(ml) == "number" then maxLevel = ml end
            end
            
            if lts.hideAtMaxLevel and level == playerLevel and level == maxLevel then
                frame.levelText:Hide()
            else
                frame.levelText:Show()
                
                local levelText = ""
                if lts.showClassification then
                    levelText = GetClassificationString(unit)
                end
                
                if level == -1 then
                    levelText = levelText .. "|cffFF0000??|r"
                else
                    local diff = level - playerLevel
                    local color
                    if diff >= 5 then
                        color = "|cffFF0000"
                    elseif diff >= 3 then
                        color = "|cffFF6600"
                    elseif diff >= -2 then
                        color = "|cffFFFF00"
                    elseif playerLevel > 0 and diff >= -math.floor(playerLevel * 0.2) then
                        color = "|cff00FF00"
                    else
                        color = "|cff888888"
                    end
                    levelText = levelText .. color .. level .. "|r"
                end
                
                frame.levelText:SetText(levelText)
            end
        end)
        -- If pcall failed (secret values), keep existing text
        end  -- end of else (non-simulated)
    end
    
    -- Portrait
    local ps = unitSettings.portrait
    if ps.mode ~= "none" then
        if isSimulated then
            -- For simulation, show class icon
            if ps.mode == "class" or ps.mode == "2d" then
                local class = simData.class
                if class and CLASS_ICON_TCOORDS[class] then
                    local coords = CLASS_ICON_TCOORDS[class]
                    frame.classIcon:SetTexture("Interface\\GLUES\\CHARACTERCREATE\\UI-CHARACTERCREATE-CLASSES")
                    frame.classIcon:SetTexCoord(unpack(coords))
                    frame.classIcon:Show()
                    frame.portrait2D:Hide()
                    frame.portrait3D:Hide()
                end
            elseif ps.mode == "3d" then
                -- Can't show 3D model for simulated, fallback to class
                local class = simData.class
                if class and CLASS_ICON_TCOORDS[class] then
                    local coords = CLASS_ICON_TCOORDS[class]
                    frame.classIcon:SetTexture("Interface\\GLUES\\CHARACTERCREATE\\UI-CHARACTERCREATE-CLASSES")
                    frame.classIcon:SetTexCoord(unpack(coords))
                    frame.classIcon:Show()
                    frame.portrait2D:Hide()
                    frame.portrait3D:Hide()
                end
            end
        else
            if ps.mode == "3d" then
                frame.portrait3D:SetUnit(unit)
                frame.portrait3D:SetCamera(0)
            elseif ps.mode == "2d" then
                SetPortraitTexture(frame.portrait2D, unit)
            elseif ps.mode == "class" then
                local _, class = UnitClass(unit)
                if type(class) == "string" and class ~= "" then
                    local coords = CLASS_ICON_TCOORDS[class]
                    if coords then
                        frame.classIcon:SetTexture("Interface\\GLUES\\CHARACTERCREATE\\UI-CHARACTERCREATE-CLASSES")
                        frame.classIcon:SetTexCoord(unpack(coords))
                    end
                end
            end
        end  -- end of else (non-simulated portrait)
    end
    
    -- Raid Target
    local rts = unitSettings.raidTarget
    if rts.enabled then
        local index = GetRaidTargetIndex(unit)
        if index then
            -- SetRaidTargetIconTexture can accept secret values
            SetRaidTargetIconTexture(frame.raidTarget, index)
            frame.raidTarget:Show()
        else
            frame.raidTarget:Hide()
        end
    else
        frame.raidTarget:Hide()
    end
    
    -- Role Icon
    local ris = unitSettings.roleIcon
    if ris and ris.enabled then
        local role
        if isSimulated then
            role = simData.role or "NONE"
        else
            role = UnitGroupRolesAssigned(unit) or "NONE"
        end
        
        if role and role ~= "NONE" then
            -- Try multiple atlas names in order of preference
            local atlasOptions = {
                TANK = {
                    "groupfinder-icon-role-large-tank",
                    "roleicon-tank",
                },
                HEALER = {
                    "groupfinder-icon-role-large-heal",
                    "groupfinder-icon-role-large-healer",
                    "roleicon-healer",
                    "roleicon-heal",
                },
                DAMAGER = {
                    "groupfinder-icon-role-large-dps",
                    "groupfinder-icon-role-large-damage",
                    "roleicon-dps",
                },
            }
            
            local options = atlasOptions[role]
            local atlasSet = false
            
            if options then
                for _, atlasName in ipairs(options) do
                    local success = pcall(function()
                        frame.roleIcon:SetAtlas(atlasName, true)
                    end)
                    if success then
                        local currentAtlas = frame.roleIcon:GetAtlas()
                        if currentAtlas and currentAtlas ~= "" then
                            atlasSet = true
                            break
                        end
                    end
                end
            end
            
            if atlasSet then
                frame.roleIcon:Show()
            else
                frame.roleIcon:Hide()
            end
        else
            frame.roleIcon:Hide()
        end
    else
        frame.roleIcon:Hide()
    end
    
    -- Debuff Indicators
    local dis = unitSettings.debuffIndicators
    -- Show during simulation even if disabled (so user can preview layout)
    local showDebuffIndicators = dis and (dis.enabled or isSimulated) and frame.debuffIndicators
    if showDebuffIndicators then
        -- Hide all legacy indicators first
        for _, indicator in pairs(frame.debuffIndicators.indicators) do
            indicator:Hide()
        end
        
        if isSimulated and simData.debuffType then
            -- Simulation mode - show simulated type indicator
            local indicator = frame.debuffIndicators.indicators[simData.debuffType]
            if indicator then
                local diStyle = dis.style or "squares"
                UpdateDebuffIndicatorStyle(indicator, diStyle, dis.size)
                indicator:SetAlpha(1)
                indicator:ClearAllPoints()
                indicator:SetPoint("LEFT", frame.debuffIndicators, "LEFT", 0, 0)
                indicator:Show()
            end
        else
            -- Use helper function for colored boxes
            -- Need to set debuffContainer for the helper
            frame.debuffContainer = frame.debuffIndicators
            UpdateDispelBoxes(frame, unit, dis.size or 12, 5, dis.onlyPlayerDispellable)
        end
    end
    
    -- ========================================================================
    -- STATUS INDICATORS UPDATE (Combat & Resting) - Player frame only
    -- ========================================================================
    local sis = unitSettings.statusIndicators
    if sis and sis.enabled and frame.combatIndicator and frame.restingIndicator then
        -- Status indicators only apply to player frame
        if unit == "player" then
            local inCombat, isResting
            
            if isSimulated then
                -- Simulate combat state
                inCombat = true
                isResting = false
            else
                -- UnitAffectingCombat and IsResting return booleans, safe from secret values
                inCombat = UnitAffectingCombat("player")
                isResting = IsResting()
            end
            
            -- Combat indicator takes priority over resting
            if sis.showCombat and inCombat then
                frame.combatFrame:Show()
                frame.restingFrame:Hide()
            elseif sis.showResting and isResting and not inCombat then
                frame.combatFrame:Hide()
                frame.restingFrame:Show()
            else
                frame.combatFrame:Hide()
                frame.restingFrame:Hide()
            end
        else
            -- Not player frame, hide both
            frame.combatFrame:Hide()
            frame.restingFrame:Hide()
        end
    elseif frame.combatFrame and frame.restingFrame then
        frame.combatFrame:Hide()
        frame.restingFrame:Hide()
    end
    
    -- ========================================================================
    -- LEADER INDICATOR UPDATE
    -- ========================================================================
    local lis = unitSettings.leaderIndicator
    if lis and lis.enabled and frame.leaderIndicator then
        local isLeader, isAssistant
        
        if isSimulated then
            -- Simulate leader for player frame
            isLeader = (unit == "player")
            isAssistant = false
        else
            -- UnitIsGroupLeader and UnitIsGroupAssistant return booleans, safe
            isLeader = UnitIsGroupLeader(unit)
            isAssistant = UnitIsGroupAssistant(unit)
        end
        
        if isLeader then
            frame.leaderIndicator:SetTexture("Interface\\GroupFrame\\UI-Group-LeaderIcon")
            frame.leaderIndicator:Show()
        elseif isAssistant then
            frame.leaderIndicator:SetTexture("Interface\\GroupFrame\\UI-Group-AssistantIcon")
            frame.leaderIndicator:Show()
        else
            frame.leaderIndicator:Hide()
        end
    elseif frame.leaderIndicator then
        frame.leaderIndicator:Hide()
    end
    
    -- ========================================================================
    -- SUMMON INDICATOR UPDATE
    -- Shows pending/accepted summon status using C_IncomingSummon API
    -- ========================================================================
    local sumSettings = unitSettings.summonIndicator
    if sumSettings and sumSettings.enabled and frame.summonFrame and frame.summonIndicator then
        local summonStatus
        
        if isSimulated then
            -- Simulate pending summon for preview (on target frame)
            summonStatus = (unit == "target") and 1 or 0  -- Enum.SummonStatus.Pending = 1
        else
            -- C_IncomingSummon.IncomingSummonStatus returns enum, safe from secret values
            summonStatus = C_IncomingSummon and C_IncomingSummon.IncomingSummonStatus and C_IncomingSummon.IncomingSummonStatus(unit) or 0
        end
        
        -- Enum.SummonStatus: None=0, Pending=1, Accepted=2, Declined=3
        if summonStatus == 1 then  -- Pending
            local r, g, b, a = unpack(sumSettings.pendingColor or { 1, 0.8, 0, 1 })
            frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonPending")
            frame.summonIndicator:SetVertexColor(r, g, b, a)
            frame.summonFrame:Show()
        elseif summonStatus == 2 then  -- Accepted
            local r, g, b, a = unpack(sumSettings.acceptedColor or { 0, 1, 0, 1 })
            frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonAccepted")
            frame.summonIndicator:SetVertexColor(r, g, b, a)
            frame.summonFrame:Show()
        else
            frame.summonFrame:Hide()
        end
    elseif frame.summonFrame then
        frame.summonFrame:Hide()
    end
    
    -- ========================================================================
    -- TARGET HIGHLIGHT UPDATE
    -- ========================================================================
    local ths = unitSettings.targetHighlight
    if ths and ths.enabled and frame.targetHighlight and frame.targetHighlightGlow then
        local isTarget
        
        if isSimulated then
            -- Simulate: target frame is always "targeted" for preview
            isTarget = (unit == "target")
        else
            -- Check if this unit is the player's current target
            -- UnitIsUnit returns boolean, safe from secret values
            isTarget = UnitIsUnit(unit, "target")
        end
        
        if isTarget then
            if ths.style == "glow" then
                frame.targetHighlightGlow:Show()
                frame.targetHighlight:Hide()
            else
                frame.targetHighlight:Show()
                frame.targetHighlightGlow:Hide()
            end
        else
            frame.targetHighlight:Hide()
            frame.targetHighlightGlow:Hide()
        end
    elseif frame.targetHighlight and frame.targetHighlightGlow then
        frame.targetHighlight:Hide()
        frame.targetHighlightGlow:Hide()
    end
    
    -- Cast Bar
    local cbs = unitSettings.castBar
    local showCastBarPreview = isSimulated and cbs and frame.castBar
    if (cbs and cbs.enabled and frame.castBar) or showCastBarPreview then
        -- Handle simulation mode
        if isSimulated then
            -- Show a simulated cast bar
            local cbHeight = cbs and cbs.height or 12
            frame.castBar:SetMinMaxValues(0, 3)
            frame.castBar:SetValue(1.5)
            
            -- Icon first (left side)
            if frame.castIcon then
                if not cbs or cbs.showIcon then
                    frame.castIcon:SetTexture("Interface\\Icons\\Spell_Nature_Heal")
                    frame.castIcon:SetSize(cbHeight, cbHeight)
                    frame.castIcon:ClearAllPoints()
                    frame.castIcon:SetPoint("LEFT", frame.castBar, "LEFT", 1, 0)
                    frame.castIcon:Show()
                else
                    frame.castIcon:Hide()
                end
            end
            
            -- Text (positioned after icon)
            if frame.castText then 
                if not cbs or cbs.showSpellName then
                    frame.castText:SetText("Simulated Cast")
                    local leftOffset = (cbs and cbs.showIcon) and (cbHeight + 3) or 2
                    frame.castText:ClearAllPoints()
                    frame.castText:SetPoint("LEFT", frame.castBar, "LEFT", leftOffset, 0)
                    frame.castText:SetTextColor(1, 1, 1, 1)
                    frame.castText:Show()
                else
                    frame.castText:Hide()
                end
            end
            
            -- Timer (right side)
            if frame.castTimer then 
                if not cbs or cbs.showTimer then
                    frame.castTimer:SetText("1.5")
                    frame.castTimer:SetTextColor(1, 1, 1, 1)
                    frame.castTimer:Show()
                else
                    frame.castTimer:Hide()
                end
            end
            
            frame.castBar:SetStatusBarColor(1, 0.7, 0, 1)
            frame.castBar:Show()
        else
            local isPlayerCast = (unit == "player" or unit == "pet" or unit == "vehicle")
            local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unit)
            local isChannel = false
            local isEmpowered = false
            local numEmpowerStages = nil
            
            if not castName then
                -- Check for empowered spell using event-driven flag (reliable like CastBars.lua)
                if frame.isEmpoweredCast and frame.empowerSpellID then
                    if C_Spell and C_Spell.GetSpellInfo then
                        local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                        if success and spellInfo and spellInfo.name then
                            local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unit)
                            if chStart and chEnd then
                                castName = spellInfo.name
                                startTime = chStart
                                endTime = chEnd
                                spellID = frame.empowerSpellID
                                notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                                isEmpowered = true
                                isChannel = false  -- Empowered spells fill like casts
                                numEmpowerStages = GetEmpowerNumStages(unit) or 3
                            end
                        end
                    end
                end
                
                if not isEmpowered then
                    -- Check for regular channel
                    castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unit)
                    isChannel = true
                    
                    -- Clear empowered flags if we're in a regular channel
                    frame.empowerSpellID = nil
                    frame.isEmpoweredCast = false
                end
            else
                -- Regular cast - clear empowered flags
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
            
            -- Safe extract values for Midnight compatibility
            local safeCastName = SafeValue(castName)
            local safeSpellID = SafeNumber(spellID)
            local safeNotInterruptible = SafeValue(notInterruptible)
            
            -- Setup empowered stage dividers if this is an empowered cast
            if isEmpowered then
                local safeStages = numEmpowerStages or 3
                if type(safeStages) ~= "number" then
                    safeStages = SafeNumber(safeStages) or 3
                end
                if safeStages >= 2 then
                    SetupEmpowerDividers(frame.castBar, unit, safeStages)
                else
                    HideEmpowerDividers(frame.castBar)
                end
            else
                HideEmpowerDividers(frame.castBar)
            end
            
            -- Try to get a cast going
            local castBarSetup = false
            
            -- For empowered casts (player or not), use UnitEmpoweredChannelDuration for accurate timing
            if castName and isEmpowered and HAS_TIMER_BARS and UnitEmpoweredChannelDuration then
                local ok, obj = pcall(UnitEmpoweredChannelDuration, unit, true)  -- true = include hold-at-max
                if ok and obj then
                    frame.castBar:SetMinMaxValues(0, 1)
                    local timerOk = pcall(frame.castBar.SetTimerDuration, frame.castBar, obj, BAR_INTERPOLATION)
                    if timerOk then
                        castBarSetup = true
                        frame.castBarDurationObject = obj
                        frame.castBarUseTimerBar = true
                    end
                end
            -- For non-player non-empowered casts, use SetTimerDuration (handles secrets)
            elseif castName and not isPlayerCast and HAS_TIMER_BARS then
                local durationObj = nil
                if isChannel and UnitChannelDuration then
                    local ok, obj = pcall(UnitChannelDuration, unit)
                    if ok and obj then durationObj = obj end
                elseif not isChannel and UnitCastingDuration then
                    local ok, obj = pcall(UnitCastingDuration, unit)
                    if ok and obj then durationObj = obj end
                end
                
                if durationObj then
                    frame.castBar:SetMinMaxValues(0, 1)
                    local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                    if ok then
                        castBarSetup = true
                        frame.castBarDurationObject = durationObj
                        frame.castBarUseTimerBar = true
                    end
                end
            end
            
            -- Traditional timing for player casts or fallback
            if not castBarSetup then
                local safeStartTime = SafeNumber(startTime)
                local safeEndTime = SafeNumber(endTime)
                
                if safeCastName and safeStartTime and safeEndTime then
                    local duration = (safeEndTime - safeStartTime) / 1000
                    local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                    frame.castBar:SetMinMaxValues(0, duration)
                    
                    if isChannel then
                        frame.castBar:SetValue(duration - elapsed)
                    else
                        frame.castBar:SetValue(elapsed)
                    end
                    
                    if frame.castTimer and cbs.showTimer then
                        frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                    end
                    
                    castBarSetup = true
                    frame.castBarUseTimerBar = false
                    frame.castBarDurationObject = nil
                    frame.castBarStartTime = safeStartTime / 1000
                    frame.castBarEndTime = safeEndTime / 1000
                    frame.castBarMaxValue = duration
                    frame.castBarCasting = not isChannel
                    frame.castBarChanneling = isChannel
                end
            end
            
            if castBarSetup then
                -- Get cast bar height for icon positioning
                local cbHeight = cbs.height or 12
                
                -- Set icon (left side)
                if frame.castIcon then
                    if cbs.showIcon then
                        local spellTexture = nil
                        if safeSpellID then
                            spellTexture = GetSpellTextureByID(safeSpellID)
                        elseif spellID then
                            pcall(function()
                                spellTexture = GetSpellTextureByID(spellID)
                            end)
                        end
                        if spellTexture then
                            frame.castIcon:SetTexture(spellTexture)
                        end
                        frame.castIcon:SetSize(cbHeight, cbHeight)
                        frame.castIcon:ClearAllPoints()
                        frame.castIcon:SetPoint("LEFT", frame.castBar, "LEFT", 1, 0)
                        frame.castIcon:Show()
                    else
                        frame.castIcon:Hide()
                    end
                end
                
                -- Set spell name (positioned after icon)
                if frame.castText then
                    if cbs.showSpellName then
                        if safeCastName then
                            frame.castText:SetText(safeCastName)
                        elseif castName then
                            -- Try string.format which can handle secrets for display
                            local ok, text = pcall(string.format, "%s", castName)
                            if ok and text then
                                frame.castText:SetText(text)
                            end
                        end
                        -- Position text after icon
                        local leftOffset = cbs.showIcon and (cbHeight + 3) or 2
                        frame.castText:ClearAllPoints()
                        frame.castText:SetPoint("LEFT", frame.castBar, "LEFT", leftOffset, 0)
                        frame.castText:SetTextColor(1, 1, 1, 1)
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                
                -- Set timer
                if frame.castTimer then
                    if cbs.showTimer then
                        frame.castTimer:SetTextColor(1, 1, 1, 1)
                        frame.castTimer:Show()
                    else
                        frame.castTimer:Hide()
                    end
                end
                
                -- Set color (v2.1.6 - handles secret notInterruptible, empowered, important)
                local baseR, baseG, baseB = 1, 0.7, 0  -- Default cast color (orange)
                local safeSpellID = SafeNumber(spellID)
                local isImportant = false
                if TweaksUI.SpellAPI and safeSpellID then
                    isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
                end
                if isImportant then
                    if isChannel or isEmpowered then
                        baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                    else
                        baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                    end
                elseif isChannel or isEmpowered then
                    baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
                end
                ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, isPlayerCast)
                
                frame.castBar:Show()
            else
                -- Don't hide if we're in preview mode (panel is open)
                if currentOpenPanel ~= unit then
                    frame.castBar:Hide()
                end
            end
        end
    elseif frame.castBar then
        -- Don't hide if we're in preview mode
        if currentOpenPanel ~= unit then
            frame.castBar:Hide()
        end
    end
    
    -- ========================================================================
    -- AURA DISPLAY UPDATE (Phase 3)
    -- ========================================================================
    
    -- Helper function to update auras in a container
    local function UpdateAuraContainer(container, auraSettings, unitToken, isBuff)
        if not container or not auraSettings or not auraSettings.enabled then
            if container then container:Hide() end
            return
        end
        
        container:Show()
        
        local maxAuras = auraSettings.maxAuras or 8
        local filter = auraSettings.filter or (isBuff and "HELPFUL" or "HARMFUL")
        
        -- Hide all icons first
        for i, icon in ipairs(container.icons) do
            icon:Hide()
            icon.auraInstanceID = nil
            icon.spellName = nil
        end
        
        -- In simulation mode, show placeholder auras
        if isSimulated then
            local numSimAuras = isBuff and 4 or 3
            for i = 1, math.min(numSimAuras, maxAuras) do
                local icon = container.icons[i]
                if icon then
                    -- Use placeholder icon
                    if isBuff then
                        icon.texture:SetTexture("Interface\\Icons\\Spell_Holy_WordFortitude")
                    else
                        icon.texture:SetTexture("Interface\\Icons\\Spell_Shadow_CurseOfTounges")
                    end
                    
                    -- Show cooldown spiral (simulated)
                    -- Blizzard's CooldownFrameTemplate handles duration text automatically
                    if auraSettings.showDuration then
                        icon.cooldown:SetCooldown(GetTime() - 5, 30)  -- 25 seconds remaining
                        icon.cooldown:Show()
                        -- Apply duration font size to Blizzard's countdown text
                        API.ApplyCooldownTextSettings(icon.cooldown, auraSettings.durationFontSize or 10, auraSettings.durationColor, auraSettings.durationAnchor, auraSettings.durationOffsetX, auraSettings.durationOffsetY)
                    else
                        icon.cooldown:Hide()
                    end
                    -- Hide custom durationText (Blizzard handles it)
                    if icon.durationText then
                        icon.durationText:Hide()
                    end
                    
                    -- Show stack count (simulated)
                    if auraSettings.showStacks and i <= 2 then
                        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), auraSettings.stackFontSize or 10, GetFontOutline())
                        icon.stackText:SetText(tostring(i + 1))
                        icon.stackText:Show()
                    else
                        icon.stackText:Hide()
                    end
                    
                    -- Dispel type coloring for debuffs
                    if not isBuff and auraSettings.colorByDispelType then
                        local dispelColors = {
                            { 0.2, 0.6, 1, 1 },   -- Magic (blue)
                            { 0.6, 0, 1, 1 },     -- Curse (purple)
                            { 0.6, 0.4, 0, 1 },   -- Disease (brown)
                            { 0, 0.6, 0, 1 },     -- Poison (green)
                        }
                        local color = dispelColors[((i - 1) % 4) + 1]
                        if auraSettings.dispelBorderOnly then
                            icon.border:SetVertexColor(unpack(color))
                            icon.border:Show()
                        else
                            icon.texture:SetVertexColor(unpack(color))
                        end
                    elseif auraSettings.showBorder then
                        icon.border:SetVertexColor(unpack(auraSettings.borderColor or { 0, 0, 0, 1 }))
                        icon.border:Show()
                    end
                    
                    icon:Show()
                end
            end
            return
        end
        
        -- Real aura data - try Beta 4+ sorted API first, then fallback
        -- Use cached table to avoid allocations
        wipe(unitAurasCache)
        local auras = unitAurasCache
        
        -- Try GetUnitAuraInstanceIDs with sorting (Beta 4+)
        -- API signature: GetUnitAuraInstanceIDs(unit, filter [, maxCount, sortRule, sortDirection])
        if HAS_AURA_SORTING and C_UnitAuras.GetUnitAuraInstanceIDs then
            -- Convert string settings to enum values
            local sortRuleStr = auraSettings.sortRule or "Default"
            local sortDirStr = auraSettings.sortDirection or "Normal"
            local sortRule = Enum.UnitAuraSortRule[sortRuleStr] or Enum.UnitAuraSortRule.Default
            local sortDirection = Enum.UnitAuraSortDirection[sortDirStr] or Enum.UnitAuraSortDirection.Normal
            
            local success, auraIDs = pcall(function()
                return C_UnitAuras.GetUnitAuraInstanceIDs(unitToken, filter, maxAuras, sortRule, sortDirection)
            end)
            
            if success and auraIDs then
                -- Look up full aura data for each ID
                for _, auraID in ipairs(auraIDs) do
                    local auraSuccess, auraData = pcall(function()
                        return C_UnitAuras.GetAuraDataByAuraInstanceID(unitToken, auraID)
                    end)
                    if auraSuccess and auraData then
                        table.insert(auras, auraData)
                    end
                end
            end
        end
        
        -- Fallback: use AuraUtil.ForEachAura (no sorting)
        if #auras == 0 and AuraUtil and AuraUtil.ForEachAura then
            local usePackedAura = true
            pcall(function()
                AuraUtil.ForEachAura(unitToken, filter, maxAuras, function(aura)
                    if aura then
                        table.insert(auras, aura)
                    end
                    if #auras >= maxAuras then
                        return true  -- Stop
                    end
                    return false  -- Continue
                end, usePackedAura)
            end)
        end
        
        -- Fallback: use C_UnitAuras.GetAuraDataByIndex
        if #auras == 0 and C_UnitAuras and C_UnitAuras.GetAuraDataByIndex then
            for i = 1, maxAuras do
                local success, aura = pcall(function()
                    return C_UnitAuras.GetAuraDataByIndex(unitToken, i, filter)
                end)
                if success and aura then
                    table.insert(auras, aura)
                else
                    break  -- No more auras
                end
            end
        end
        
        -- Note: Cannot filter permanent auras by comparing values (secrets)
        -- Instead, we use SetAlphaFromBoolean with DoesAuraHaveExpirationTime below
        local hidePermanent = auraSettings.hidePermanent
        
        -- Update icons with aura data
        for i, auraData in ipairs(auras) do
            if i > maxAuras then break end
            
            local icon = container.icons[i]
            if icon and auraData then
                icon.auraInstanceID = auraData.auraInstanceID
                
                -- Store spell name for right-click cancel (player buffs only)
                pcall(function()
                    icon.spellName = auraData.name
                end)
                
                -- Hide permanent auras using SetAlphaFromBoolean (accepts secret booleans)
                -- This will make permanent buffs invisible but they still take up slots (gaps)
                if hidePermanent and auraData.auraInstanceID and C_UnitAuras.DoesAuraHaveExpirationTime then
                    pcall(function()
                        local hasExpiration = C_UnitAuras.DoesAuraHaveExpirationTime(unitToken, auraData.auraInstanceID)
                        if icon.SetAlphaFromBoolean then
                            -- SetAlphaFromBoolean: if hasExpiration is true, alpha = 1.0; if false, alpha = 0.0
                            icon:SetAlphaFromBoolean(hasExpiration, 1.0, 0.0)
                        end
                    end)
                else
                    icon:SetAlpha(1.0)
                end
                
                -- Icon texture - use pcall, SetTexture accepts secret values (fileIDs)
                -- Don't check "if auraData.icon" - that compares a secret value!
                local textureSet = false
                pcall(function()
                    icon.texture:SetTexture(auraData.icon)
                    icon.texture:SetVertexColor(1, 1, 1, 1)  -- Reset tint
                    textureSet = true
                end)
                
                -- If texture failed to set, skip this aura
                if not textureSet then
                    icon:Hide()
                else
                    -- Duration/cooldown spiral (sweep)
                    if auraSettings.showDuration then
                        -- Use TweaksUI.API compatibility layer for setting cooldown from aura
                        local cooldownSet = false
                        
                        if auraData.auraInstanceID then
                            cooldownSet = TweaksUI.API.SetCooldownFromAura(icon.cooldown, unitToken, auraData.auraInstanceID)
                        end
                        
                        -- Fallback: Traditional SetCooldown using aura data directly
                        -- Wrap in pcall because expirationTime/duration may be secret values
                        if not cooldownSet then
                            pcall(function()
                                if auraData.expirationTime and auraData.duration and auraData.duration > 0 then
                                    local startTime = auraData.expirationTime - auraData.duration
                                    icon.cooldown:SetCooldown(startTime, auraData.duration)
                                    cooldownSet = true
                                end
                            end)
                        end
                        
                        if cooldownSet then
                            icon.cooldown:Show()
                            -- Apply sweep alpha if set
                            local sweepAlpha = auraSettings.sweepAlpha or 1.0
                            icon.cooldown:SetAlpha(sweepAlpha)
                            -- Apply duration font size to Blizzard's countdown text
                            API.ApplyCooldownTextSettings(icon.cooldown, auraSettings.durationFontSize or 10, auraSettings.durationColor, auraSettings.durationAnchor, auraSettings.durationOffsetX, auraSettings.durationOffsetY)
                        else
                            icon.cooldown:Hide()
                        end
                    else
                        icon.cooldown:Hide()
                    end
                    
                    -- Duration text is now handled by Blizzard's CooldownFrameTemplate
                    -- with SetHideCountdownNumbers(false) - works with secret values and abbreviates times
                    if icon.durationText then
                        icon.durationText:Hide()
                    end
                    
                    -- Stack count
                    if auraSettings.showStacks then
                        local stackShown = false
                        -- Update font size
                        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), auraSettings.stackFontSize or 10, GetFontOutline())
                        if auraData.auraInstanceID and C_UnitAuras and C_UnitAuras.GetAuraApplicationDisplayCount then
                            -- Use Midnight API that returns formatted string (minBound=2 returns empty for < 2)
                            pcall(function()
                                local countText = C_UnitAuras.GetAuraApplicationDisplayCount(unitToken, auraData.auraInstanceID, 2)
                                -- countText may be secret, empty string shows nothing
                                icon.stackText:SetText(countText or "")
                                icon.stackText:Show()
                                stackShown = true
                            end)
                        end
                        -- Fallback: try direct applications field (wrapped in pcall for secret comparison)
                        if not stackShown then
                            pcall(function()
                                if auraData.applications and auraData.applications > 1 then
                                    icon.stackText:SetText(tostring(auraData.applications))
                                    icon.stackText:Show()
                                    stackShown = true
                                end
                            end)
                        end
                        if not stackShown then
                            icon.stackText:Hide()
                        end
                    else
                        icon.stackText:Hide()
                    end
                    
                    -- Dispel type coloring for debuffs
                    -- Uses GetDispelColorFromAura which handles Midnight secret values via color curve
                    local dispelColorApplied = false
                    if not isBuff and auraSettings.colorByDispelType then
                        local r, g, b, hasValidColor = GetDispelColorFromAura(unitToken, auraData)
                        if hasValidColor then
                            if auraSettings.dispelBorderOnly then
                                icon.border:SetVertexColor(r, g, b, 1)
                                icon.border:Show()
                            else
                                icon.texture:SetVertexColor(r, g, b, 1)
                            end
                            dispelColorApplied = true
                        end
                    end
                    
                    if not dispelColorApplied then
                        if auraSettings.showBorder then
                            icon.border:SetVertexColor(unpack(auraSettings.borderColor or { 0, 0, 0, 1 }))
                            icon.border:Show()
                        else
                            icon.border:Hide()
                        end
                    end
                    
                    icon:Show()
                end  -- end textureSet else block
            end
        end
    end
    
    -- Update buffs
    if frame.buffsContainer then
        UpdateAuraContainer(frame.buffsContainer, unitSettings.buffs, unit, true)
    end
    
    -- Update debuffs
    if frame.debuffsContainer then
        UpdateAuraContainer(frame.debuffsContainer, unitSettings.debuffs, unit, false)
    end
    
    -- ========================================================================
    -- RANGE FADE for individual frames (target, focus, etc.)
    -- ========================================================================
    -- Use explicit settings or module default if not configured
    local rangeFadeSettings = unitSettings.rangeFade
    local rangeFadeEnabled = false
    local outOfRangeAlpha = 0.4
    local perElementFade = false
    
    -- Check if range fade is enabled (either per-unit or via general settings)
    if rangeFadeSettings then
        rangeFadeEnabled = rangeFadeSettings.enabled
        outOfRangeAlpha = rangeFadeSettings.outOfRangeAlpha or 0.4
        perElementFade = rangeFadeSettings.perElementFade or false
    elseif settings.general and settings.general.rangeFade then
        -- Fall back to general rangeFade settings
        local gs = settings.general.rangeFade
        rangeFadeEnabled = gs.enabled
        outOfRangeAlpha = gs.outOfRangeAlpha or 0.4
        perElementFade = gs.perElementFade or false
    end
    
    if rangeFadeEnabled then
        -- Only check range for units that support it (not player, not simulated)
        local shouldCheckRange = not isSimulated and unit ~= "player"
        local inRange = true
        
        if shouldCheckRange and UnitExists(unit) then
            -- UnitInRange only works for friendly group members by default
            -- For hostile targets, we'll use spell range check as fallback
            if UnitIsFriend("player", unit) then
                -- For friendly units (party/raid), UnitInRange works
                local rangeResult = UnitInRange(unit)
                -- Handle potential secret value
                local success, isInRange = pcall(function()
                    if rangeResult == nil then return true end
                    return rangeResult == true
                end)
                inRange = success and isInRange or true
            else
                -- For hostile units, check if we can interact
                -- If unit exists but isn't a group member, use CheckInteractDistance as fallback
                local interactDist = CheckInteractDistance(unit, 4) -- 28 yards
                if interactDist ~= nil then
                    inRange = interactDist
                else
                    -- Can't determine, assume in range
                    inRange = true
                end
            end
        end
        
        -- Apply alpha based on range
        local targetAlpha = inRange and 1.0 or outOfRangeAlpha
        
        -- Only update if alpha changed (performance optimization)
        local lastRangeAlpha = frame.tuiLastRangeAlpha
        if lastRangeAlpha ~= targetAlpha then
            frame.tuiLastRangeAlpha = targetAlpha
            frame.tuiInRange = inRange
            
            -- Apply alpha to frame elements
            if perElementFade and not inRange then
                -- Per-element fade: keep frame visible, fade elements
                local elementAlphas = (rangeFadeSettings and rangeFadeSettings.elementAlphas) or {
                    healthBar = 0.3,
                    powerBar = 0.3,
                    nameText = 0.6,
                    healthText = 0.4,
                }
                if frame.healthBar then frame.healthBar:SetAlpha(inRange and 1.0 or elementAlphas.healthBar) end
                if frame.powerBar then frame.powerBar:SetAlpha(inRange and 1.0 or elementAlphas.powerBar) end
                if frame.nameText then frame.nameText:SetAlpha(inRange and 1.0 or elementAlphas.nameText) end
                if frame.healthText then frame.healthText:SetAlpha(inRange and 1.0 or elementAlphas.healthText) end
            else
                -- Simple frame-level alpha
                frame:SetAlpha(targetAlpha)
            end
        end
    end
end

-- ============================================================================
-- VISIBILITY MANAGER (Per-Frame)
-- ============================================================================

local VisibilityManager = {
    mouseoverFrames = {},  -- Per-unit mouseover detection frames
    mouseoverStates = {},  -- Per-unit mouseover state
    initialized = false,
}

-- Reset all mouseover frames (for debugging/fixing stuck mouse states)
function VisibilityManager:ResetAllMouseoverFrames()
    for unitType, mf in pairs(self.mouseoverFrames) do
        if mf then
            mf:EnableMouse(false)
            mf:SetScript("OnUpdate", nil)
            mf:SetScript("OnEnter", nil)
            mf:SetScript("OnLeave", nil)
            mf:Hide()
        end
    end
    self.mouseoverFrames = {}
    self.mouseoverStates = {}
    TweaksUI:PrintDebug("VisibilityManager: Reset all mouseover frames")
end

-- Expose for slash commands
TweaksUI.UnitFramesVisibilityManager = VisibilityManager

-- Get visibility settings for a specific unit
local function GetVisibilitySettings(unitType)
    if not settings then return nil end
    
    -- Map unit types to their settings
    if unitType == "raid_small" then
        return settings.raid and settings.raid.small and settings.raid.small.visibility
    elseif unitType == "raid_large" then
        return settings.raid and settings.raid.large and settings.raid.large.visibility
    elseif unitType == "tanks" then
        return settings.tanks and settings.tanks.visibility
    elseif unitType == "boss" then
        return settings.boss and settings.boss.visibility
    elseif unitType == "party" then
        return settings.party and settings.party.visibility
    else
        return settings[unitType] and settings[unitType].visibility
    end
end

-- Check if a specific unit should be shown based on its visibility settings
function VisibilityManager:ShouldShowUnit(unitType)
    -- Force all visible mode bypasses all visibility conditions
    if TweaksUI.forceAllVisible then
        return true
    end
    
    -- Always show if the settings panel for this unit is open
    if currentOpenPanel == unitType then
        return true
    end
    
    local vis = GetVisibilitySettings(unitType)
    if not vis or not vis.enabled then return true end  -- No visibility controls = always show
    
    -- Check if ANY condition is met (OR logic)
    
    -- Combat check
    if vis.combat and UnitAffectingCombat("player") then
        return true
    end
    
    -- Mouseover check
    if vis.mouseover and self.mouseoverStates[unitType] then
        return true
    end
    
    -- Target check
    if vis.target and UnitExists("target") then
        return true
    end
    
    -- Group check
    if vis.group and (IsInGroup() or IsInRaid()) then
        return true
    end
    
    -- Instance check
    if vis.instance then
        local _, instanceType = IsInInstance()
        local allowedTypes = vis.instanceTypes or {}
        if allowedTypes[instanceType] then
            return true
        end
    end
    
    -- No conditions met = hide
    return false
end

-- Apply visibility to a specific unit's frame(s)
function VisibilityManager:ApplyVisibilityForUnit(unitType, instant)
    local vis = GetVisibilitySettings(unitType)
    
    -- Get the frame(s) for this unit
    local frames = {}
    
    if unitType == "party" then
        for i, frame in pairs(partyMemberFrames) do
            if frame then table.insert(frames, frame) end
        end
    elseif unitType == "raid_small" then
        for i, frame in pairs(raidSmallMemberFrames) do
            if frame then table.insert(frames, frame) end
        end
    elseif unitType == "raid_large" then
        for i, frame in pairs(raidLargeMemberFrames) do
            if frame then table.insert(frames, frame) end
        end
    elseif unitType == "tanks" then
        for i, frame in pairs(tankMemberFrames) do
            if frame then table.insert(frames, frame) end
        end
    elseif unitType == "boss" then
        for i, frame in pairs(bossMemberFrames) do
            if frame then table.insert(frames, frame) end
        end
    elseif customFrames[unitType] then
        table.insert(frames, customFrames[unitType])
    end
    
    if #frames == 0 then return end
    
    -- Calculate target alpha
    local targetAlpha
    if not vis or not vis.enabled then
        targetAlpha = 1  -- No visibility controls = full opacity
    else
        local shouldShow = self:ShouldShowUnit(unitType)
        targetAlpha = shouldShow and 1 or (vis.fadeAlpha / 100)
    end
    
    -- Apply alpha to all frames for this unit
    for _, frame in ipairs(frames) do
        if instant then
            frame:SetAlpha(targetAlpha)
        else
            -- Smooth fade (simple version - just set immediately for now)
            frame:SetAlpha(targetAlpha)
        end
    end
end

-- Apply visibility to all frames
function VisibilityManager:ApplyAllVisibility(instant)
    -- Individual units
    for _, unitType in ipairs(INDIVIDUAL_UNITS) do
        self:ApplyVisibilityForUnit(unitType, instant)
    end
    
    -- Group frames
    self:ApplyVisibilityForUnit("party", instant)
    self:ApplyVisibilityForUnit("raid_small", instant)
    self:ApplyVisibilityForUnit("raid_large", instant)
    self:ApplyVisibilityForUnit("tanks", instant)
    self:ApplyVisibilityForUnit("boss", instant)
end

-- Update mouseover detection for a specific unit
function VisibilityManager:UpdateMouseoverForUnit(unitType)
    local vis = GetVisibilitySettings(unitType)
    
    -- If no visibility settings or mouseover not enabled, remove detection
    if not vis or not vis.enabled or not vis.mouseover then
        if self.mouseoverFrames[unitType] then
            self.mouseoverFrames[unitType]:Hide()
        end
        return
    end
    
    -- Get the frame(s) for this unit to calculate bounds
    local targetFrame
    if unitType == "party" then
        targetFrame = partyContainer
    elseif unitType == "raid_small" then
        targetFrame = raidSmallContainer
    elseif unitType == "raid_large" then
        targetFrame = raidLargeContainer
    elseif unitType == "tanks" then
        targetFrame = tankContainer
    elseif unitType == "boss" then
        targetFrame = bossContainer
    else
        targetFrame = customFrames[unitType]
    end
    
    if not targetFrame or not targetFrame:IsShown() then
        if self.mouseoverFrames[unitType] then
            self.mouseoverFrames[unitType]:Hide()
            self.mouseoverFrames[unitType]:SetScript("OnUpdate", nil)
        end
        return
    end
    
    -- Create or get mouseover frame
    if not self.mouseoverFrames[unitType] then
        local mf = CreateFrame("Frame", nil, UIParent)
        mf:SetFrameStrata("BACKGROUND")
        mf.unitType = unitType
        mf.elapsed = 0
        self.mouseoverFrames[unitType] = mf
        
        -- Use polling approach instead of EnableMouse to avoid blocking clicks
        -- This is safer when other addons (like DialogueUI) toggle UIParent visibility
        mf:SetScript("OnUpdate", function(self, elapsed)
            self.elapsed = (self.elapsed or 0) + elapsed
            if self.elapsed > 0.05 then  -- Check every 50ms
                self.elapsed = 0
                
                -- Check if mouse is over this frame's bounds (without EnableMouse)
                local isOver = self:IsMouseOver()
                local wasOver = VisibilityManager.mouseoverStates[self.unitType]
                
                if isOver and not wasOver then
                    VisibilityManager.mouseoverStates[self.unitType] = true
                    VisibilityManager:ApplyVisibilityForUnit(self.unitType, false)
                elseif not isOver and wasOver then
                    VisibilityManager.mouseoverStates[self.unitType] = false
                    VisibilityManager:ApplyVisibilityForUnit(self.unitType, false)
                end
            end
        end)
        
        -- CRITICAL: Don't use EnableMouse - it can block clicks after UIParent visibility toggles
        -- IsMouseOver() works without EnableMouse for polling
        mf:EnableMouse(false)
    end
    
    local mf = self.mouseoverFrames[unitType]
    
    -- Position to cover the target frame with padding
    local padding = 15
    local left = targetFrame:GetLeft()
    local bottom = targetFrame:GetBottom()
    local width = targetFrame:GetWidth()
    local height = targetFrame:GetHeight()
    
    if left and bottom and width and height then
        mf:ClearAllPoints()
        mf:SetPoint("BOTTOMLEFT", UIParent, "BOTTOMLEFT", left - padding, bottom - padding)
        mf:SetSize(width + padding * 2, height + padding * 2)
        mf:Show()
    else
        mf:Hide()
    end
end

-- Update all mouseover detections
function VisibilityManager:UpdateAllMouseover()
    for _, unitType in ipairs(INDIVIDUAL_UNITS) do
        self:UpdateMouseoverForUnit(unitType)
    end
    self:UpdateMouseoverForUnit("party")
    self:UpdateMouseoverForUnit("raid_small")
    self:UpdateMouseoverForUnit("raid_large")
    self:UpdateMouseoverForUnit("tanks")
    self:UpdateMouseoverForUnit("boss")
end

-- Initialize visibility system
function VisibilityManager:Initialize()
    if self.initialized then return end
    self.initialized = true
    
    -- Create event frame for visibility-related events
    local visFrame = CreateFrame("Frame")
    visFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
    visFrame:RegisterEvent("PLAYER_REGEN_DISABLED")
    visFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
    visFrame:RegisterEvent("GROUP_ROSTER_UPDATE")
    visFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
    visFrame:RegisterEvent("ZONE_CHANGED_NEW_AREA")
    
    visFrame:SetScript("OnEvent", function(self, event)
        if not settings then return end
        
        -- Check which units need updating based on event
        local unitsToUpdate = {}
        
        -- Determine which units have visibility enabled for this event type
        local function CheckUnit(unitType)
            local vis = GetVisibilitySettings(unitType)
            if vis and vis.enabled then
                if event == "PLAYER_REGEN_ENABLED" or event == "PLAYER_REGEN_DISABLED" then
                    if vis.combat then table.insert(unitsToUpdate, unitType) end
                elseif event == "PLAYER_TARGET_CHANGED" then
                    if vis.target then table.insert(unitsToUpdate, unitType) end
                elseif event == "GROUP_ROSTER_UPDATE" then
                    if vis.group then table.insert(unitsToUpdate, unitType) end
                elseif event == "PLAYER_ENTERING_WORLD" or event == "ZONE_CHANGED_NEW_AREA" then
                    table.insert(unitsToUpdate, unitType)
                end
            end
        end
        
        -- Check all unit types
        for _, unitType in ipairs(INDIVIDUAL_UNITS) do
            CheckUnit(unitType)
        end
        CheckUnit("party")
        CheckUnit("raid_small")
        CheckUnit("raid_large")
        CheckUnit("tanks")
        CheckUnit("boss")
        
        -- Apply updates
        if event == "PLAYER_ENTERING_WORLD" or event == "ZONE_CHANGED_NEW_AREA" then
            C_Timer.After(0.5, function()
                VisibilityManager:ApplyAllVisibility(true)
                VisibilityManager:UpdateAllMouseover()
            end)
        else
            for _, unitType in ipairs(unitsToUpdate) do
                VisibilityManager:ApplyVisibilityForUnit(unitType, true)
            end
        end
    end)
    
    -- Initial application
    C_Timer.After(1, function()
        self:ApplyAllVisibility(true)
        self:UpdateAllMouseover()
    end)
end

-- ============================================================================
-- EVENT HANDLING
-- ============================================================================

local function SetupEventFrame()
    if eventFrame then return end
    
    eventFrame = CreateFrame("Frame")
    eventFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
    eventFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
    eventFrame:RegisterEvent("PLAYER_FOCUS_CHANGED")
    eventFrame:RegisterEvent("UNIT_PET")
    eventFrame:RegisterEvent("UNIT_HEALTH")
    eventFrame:RegisterEvent("UNIT_MAXHEALTH")
    eventFrame:RegisterEvent("UNIT_POWER_UPDATE")
    eventFrame:RegisterEvent("UNIT_MAXPOWER")
    eventFrame:RegisterEvent("UNIT_DISPLAYPOWER")
    eventFrame:RegisterEvent("UNIT_NAME_UPDATE")
    eventFrame:RegisterEvent("UNIT_LEVEL")
    eventFrame:RegisterEvent("UNIT_FACTION")
    eventFrame:RegisterEvent("UNIT_CLASSIFICATION_CHANGED")
    eventFrame:RegisterEvent("RAID_TARGET_UPDATE")
    eventFrame:RegisterEvent("UNIT_PORTRAIT_UPDATE")
    eventFrame:RegisterEvent("PORTRAITS_UPDATED")
    eventFrame:RegisterEvent("UNIT_TARGET")
    -- Party events
    eventFrame:RegisterEvent("GROUP_ROSTER_UPDATE")
    eventFrame:RegisterEvent("PARTY_MEMBER_ENABLE")
    eventFrame:RegisterEvent("PARTY_MEMBER_DISABLE")
    -- Debuff events
    eventFrame:RegisterEvent("UNIT_AURA")
    -- Absorb events (Phase 2)
    eventFrame:RegisterEvent("UNIT_ABSORB_AMOUNT_CHANGED")
    -- Class power events (Phase 2)
    eventFrame:RegisterEvent("UNIT_POWER_FREQUENT")
    eventFrame:RegisterEvent("RUNE_POWER_UPDATE")
    eventFrame:RegisterEvent("PLAYER_SPECIALIZATION_CHANGED")
    eventFrame:RegisterEvent("UPDATE_SHAPESHIFT_FORM")
    -- Combat state events (for deferred updates)
    eventFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
    eventFrame:RegisterEvent("PLAYER_REGEN_DISABLED")  -- For combat indicator
    eventFrame:RegisterEvent("PLAYER_UPDATE_RESTING")  -- For resting indicator
    eventFrame:RegisterEvent("INCOMING_SUMMON_CHANGED")  -- For summon indicator
    -- Boss events
    eventFrame:RegisterEvent("INSTANCE_ENCOUNTER_ENGAGE_UNIT")
    eventFrame:RegisterEvent("UNIT_TARGETABLE_CHANGED")
    -- Cast bar events
    eventFrame:RegisterEvent("UNIT_SPELLCAST_START")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_STOP")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_FAILED")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_INTERRUPTED")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_CHANNEL_START")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_CHANNEL_STOP")
    -- Empowered spell events (Evoker, etc.)
    eventFrame:RegisterEvent("UNIT_SPELLCAST_EMPOWER_START")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_EMPOWER_STOP")
    eventFrame:RegisterEvent("UNIT_SPELLCAST_EMPOWER_UPDATE")
    
    eventFrame:SetScript("OnEvent", function(self, event, arg1, ...)
        if not settings then return end
        
        if event == "PLAYER_REGEN_ENABLED" or event == "PLAYER_REGEN_DISABLED" then
            -- Combat state changed - update player frame immediately for combat indicator
            if customFrames["player"] then
                UpdateFrameData("player")
            end
            
            -- Combat ended - process pending layout updates and refresh frames
            if event == "PLAYER_REGEN_ENABLED" then
                -- Process any deferred layout updates immediately
                for unit in pairs(pendingLayoutUpdates) do
                    if customFrames[unit] and settings[unit] and settings[unit].enabled then
                        UpdateFrameLayout(unit)
                        UpdateFrameData(unit)  -- Ensure data is updated after layout
                    end
                end
                wipe(pendingLayoutUpdates)
                
                -- Process pending boss unit watch updates
                if pendingBossUnitWatchUpdate then
                    pendingBossUnitWatchUpdate = false
                    if settings.boss and settings.boss.enabled then
                        pcall(function() UnitFrames:UpdateBossFrames() end)
                    end
                end
                
                -- Additional delayed refresh for frames
                C_Timer.After(0.1, function()
                    -- Skip if we re-entered combat
                    if InCombatLockdown() then return end
                    
                    -- Refresh individual frames - let UpdateFrameData handle visibility
                    for unit, frame in pairs(customFrames) do
                        if frame and settings[unit] and settings[unit].enabled then
                            UpdateFrameLayout(unit)
                            UpdateFrameData(unit)
                            -- Don't force show - UpdateFrameData handles visibility properly
                        end
                    end
                    -- Refresh party frames
                    if settings.party and settings.party.enabled then
                        pcall(function() UnitFrames:UpdatePartyFrames() end)
                    end
                end)
            end
            
        elseif event == "PLAYER_UPDATE_RESTING" then
            -- Resting state changed - update player frame for resting indicator
            if customFrames["player"] then
                UpdateFrameData("player")
            end
            
        elseif event == "INCOMING_SUMMON_CHANGED" then
            -- Summon status changed - update all frames that might have summon indicator
            for unit, frame in pairs(customFrames) do
                if frame then
                    UpdateFrameData(unit)
                end
            end
            -- Also update party frames
            if settings.party and settings.party.enabled then
                pcall(function() UnitFrames:UpdatePartyFrames() end)
            end
            
        elseif event == "PLAYER_ENTERING_WORLD" then
            -- Initialize player dispel types for filtering
            DispelUtils:UpdatePlayerDispelTypes()
            
            C_Timer.After(0.5, function()
                for unit, _ in pairs(customFrames) do
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end
                -- Also update party frames after zoning
                if settings.party and settings.party.enabled then
                    pcall(function() UnitFrames:UpdatePartyFrames() end)
                end
                -- Check if Blizzard cast bars should be hidden
                UpdateBlizzardCastBarVisibility()
            end)
            -- Additional delayed call to ensure Blizzard frames stay hidden
            C_Timer.After(1.5, function()
                if settings.party and settings.party.enabled then
                    pcall(function() UnitFrames:UpdatePartyFrames() end)
                end
                -- Recheck Blizzard cast bar visibility
                UpdateBlizzardCastBarVisibility()
            end)
            
        elseif event == "PLAYER_TARGET_CHANGED" then
            if customFrames["target"] then
                UpdateFrameData("target")
            end
            if customFrames["targettarget"] then
                UpdateFrameData("targettarget")
            end
            -- Update player frame for target highlight (if targeting self)
            if customFrames["player"] then
                UpdateFrameData("player")
            end
            -- Update focus frame for target highlight
            if customFrames["focus"] then
                UpdateFrameData("focus")
            end
            -- Update party frames for target highlight
            if settings.party and settings.party.enabled then
                pcall(function() UnitFrames:UpdatePartyFrames() end)
                -- Also hide Blizzard's party frame Selection highlights
                if PartyFrame then
                    for i = 1, 4 do
                        local memberFrame = PartyFrame["MemberFrame" .. i]
                        if memberFrame then
                            if memberFrame.Selection then
                                memberFrame.Selection:SetAlpha(0)
                                pcall(function() memberFrame.Selection:Hide() end)
                            end
                            if memberFrame.HighlightTexture then
                                memberFrame.HighlightTexture:SetAlpha(0)
                                pcall(function() memberFrame.HighlightTexture:Hide() end)
                            end
                        end
                    end
                end
            end
            
        elseif event == "PLAYER_FOCUS_CHANGED" then
            if customFrames["focus"] then
                UpdateFrameData("focus")
            end
            
        elseif event == "UNIT_PET" then
            if customFrames["pet"] then
                UpdateFrameData("pet")
            end
            
        elseif event == "UNIT_TARGET" then
            -- Update target of target when target changes their target
            if arg1 == "target" and customFrames["targettarget"] then
                UpdateFrameData("targettarget")
            end
            
        elseif event == "GROUP_ROSTER_UPDATE" or event == "PARTY_MEMBER_ENABLE" or event == "PARTY_MEMBER_DISABLE" then
            -- Update party container frames (protected)
            pcall(function() UnitFrames:UpdatePartyFrames() end)
            -- Update raid container frames (protected)
            pcall(function() UnitFrames:UpdateRaidFrames() end)
            -- Update tank frames (protected)
            pcall(function() UnitFrames:UpdateTankFrames() end)
            
            -- Re-hide Blizzard party frames whenever group changes
            if settings and settings.party and settings.party.enabled then
                C_Timer.After(0.1, function()
                    if not InCombatLockdown() then
                        UnitFrames.HideBlizzardPartyFrames()
                    end
                end)
            end
            
            -- Manage range checker based on group state
            local inGroup = IsInGroup() or IsInRaid()
            if inGroup then
                -- Start range checker if any group type has it enabled
                local shouldStart = false
                if settings.party and settings.party.rangeCheck and settings.party.rangeCheck.enabled then
                    shouldStart = true
                end
                if settings.raid and settings.raid.small and settings.raid.small.rangeCheck and settings.raid.small.rangeCheck.enabled then
                    shouldStart = true
                end
                if settings.raid and settings.raid.large and settings.raid.large.rangeCheck and settings.raid.large.rangeCheck.enabled then
                    shouldStart = true
                end
                if settings.tanks and settings.tanks.rangeCheck and settings.tanks.rangeCheck.enabled then
                    shouldStart = true
                end
                if shouldStart then
                    InitRangeChecker()
                end
            else
                StopRangeChecker()
            end
            
        elseif event == "INSTANCE_ENCOUNTER_ENGAGE_UNIT" or event == "UNIT_TARGETABLE_CHANGED" then
            -- Update boss frames when bosses appear/disappear
            if settings.boss and settings.boss.enabled then
                pcall(function() UnitFrames:UpdateBossFrames() end)
            end
            
        elseif event == "UNIT_AURA" then
            -- Update debuff indicators for the affected unit
            if arg1 and customFrames[arg1] then
                UpdateFrameData(arg1)
            end
            -- Party: Update specific party member frame (DATA ONLY - PERFORMANCE)
            if arg1 and arg1:match("^party%d$") then
                local index = tonumber(arg1:match("^party(%d)$"))
                if index and settings and settings.party and settings.party.enabled then
                    -- Use data-only update for performance (no layout changes on aura events)
                    UnitFrames:UpdatePartyMemberDataOnly(index)
                end
            elseif arg1 == "player" then
                -- Player aura change - update player slot in party if enabled
                if settings and settings.party and settings.party.enabled then
                    UnitFrames:UpdatePartyMemberDataOnly(1)  -- Player is always slot 1 in party
                end
            end
            -- Raid: Update specific raid member frame (DATA ONLY - PERFORMANCE)
            if arg1 and arg1:match("^raid%d+$") then
                local index = tonumber(arg1:match("^raid(%d+)$"))
                if index and settings and settings.raid and settings.raid.enabled then
                    local raidSize = GetNumGroupMembers()
                    local threshold = settings.raid.sizeThreshold or 20
                    local sizeType = raidSize <= threshold and "small" or "large"
                    -- Use data-only update for performance (no layout changes on aura events)
                    UnitFrames:UpdateRaidMemberDataOnly(sizeType, index)
                end
            end
            
        elseif event == "UNIT_HEALTH" or event == "UNIT_MAXHEALTH" or 
               event == "UNIT_POWER_UPDATE" or event == "UNIT_MAXPOWER" or
               event == "UNIT_DISPLAYPOWER" or event == "UNIT_ABSORB_AMOUNT_CHANGED" then
            if arg1 and customFrames[arg1] then
                UpdateFrameData(arg1)
            end
            -- Always update targettarget and focus - the API will get the right unit's data
            -- No need to compare units, just pass through
            if customFrames["targettarget"] then
                UpdateFrameData("targettarget")
            end
            if customFrames["focus"] then
                UpdateFrameData("focus")
            end
            -- Update SPECIFIC party member frame only (DATA ONLY - PERFORMANCE)
            if arg1 then
                local partyIndex = arg1:match("^party(%d)$")
                if partyIndex then
                    local index = tonumber(partyIndex)
                    if index and settings and settings.party and settings.party.enabled then
                        -- Use data-only update for performance (no layout changes on health events)
                        UnitFrames:UpdatePartyMemberDataOnly(index)
                    end
                elseif arg1 == "player" then
                    -- Player shows in party frames too
                    if settings and settings.party and settings.party.enabled then
                        UnitFrames:UpdatePartyMemberDataOnly(1)  -- Player is always slot 1 in party
                    end
                end
            end
            -- Update SPECIFIC raid member frame only (DATA ONLY - PERFORMANCE)
            if arg1 then
                local raidIndex = arg1:match("^raid(%d+)$")
                if raidIndex then
                    local index = tonumber(raidIndex)
                    if index and settings and settings.raid and settings.raid.enabled then
                        -- Determine size type based on current raid size
                        local raidSize = GetNumGroupMembers()
                        local threshold = settings.raid.sizeThreshold or 20
                        local sizeType = raidSize <= threshold and "small" or "large"
                        -- Use data-only update for performance (no layout changes on health events)
                        UnitFrames:UpdateRaidMemberDataOnly(sizeType, index)
                    end
                end
                -- Don't update all raid frames for player health - too expensive
            end
            -- Also update boss frames if it's a boss unit (DATA ONLY - PERFORMANCE)
            if arg1 and arg1:match("^boss%d$") then
                local bossIndex = tonumber(arg1:match("^boss(%d)$"))
                if bossIndex and settings and settings.boss and settings.boss.enabled then
                    -- Use data-only update for performance (no layout changes on health events)
                    UnitFrames:UpdateBossMemberDataOnly(bossIndex)
                end
            end
            
        elseif event == "UNIT_POWER_FREQUENT" or event == "RUNE_POWER_UPDATE" then
            -- Class power updates (combo points, runes, etc.) - player only
            if customFrames["player"] then
                UpdateFrameData("player")
            end
            
        elseif event == "PLAYER_SPECIALIZATION_CHANGED" or event == "UPDATE_SHAPESHIFT_FORM" then
            -- Spec or form changed - update layout for class power and refresh
            if customFrames["player"] then
                UpdateFrameLayout("player")
                UpdateFrameData("player")
            end
            
        elseif event == "UNIT_NAME_UPDATE" or event == "UNIT_LEVEL" or
               event == "UNIT_FACTION" or event == "UNIT_CLASSIFICATION_CHANGED" then
            if arg1 and customFrames[arg1] then
                UpdateFrameData(arg1)
            end
            
        elseif event == "RAID_TARGET_UPDATE" then
            for unit, _ in pairs(customFrames) do
                UpdateFrameData(unit)
            end
            -- Also update party and raid frames
            pcall(function() UnitFrames:UpdatePartyFrames() end)
            pcall(function() UnitFrames:UpdateRaidFrames() end)
            pcall(function() UnitFrames:UpdateTankFrames() end)
            
        elseif event == "UNIT_PORTRAIT_UPDATE" or event == "PORTRAITS_UPDATED" then
            for unit, frame in pairs(customFrames) do
                local us = settings[unit]
                if us and us.portrait and us.portrait.enabled then
                    UpdateFrameData(unit)
                end
            end
            
        elseif event == "UNIT_SPELLCAST_START" or event == "UNIT_SPELLCAST_STOP" or
               event == "UNIT_SPELLCAST_FAILED" or event == "UNIT_SPELLCAST_INTERRUPTED" or
               event == "UNIT_SPELLCAST_CHANNEL_START" or event == "UNIT_SPELLCAST_CHANNEL_STOP" or
               event == "UNIT_SPELLCAST_EMPOWER_START" or event == "UNIT_SPELLCAST_EMPOWER_STOP" or
               event == "UNIT_SPELLCAST_EMPOWER_UPDATE" then
            -- For EMPOWER events, spellID is at position 4 (unit, castGUID, castBarID, spellID)
            local empowerSpellID
            local isEmpowerStart = (event == "UNIT_SPELLCAST_EMPOWER_START")
            local isEmpowerStop = (event == "UNIT_SPELLCAST_EMPOWER_STOP")
            
            if event:find("EMPOWER") then
                local args = {...}
                empowerSpellID = args[3]  -- Position 4 minus arg1 = position 3 in ...
            end
            
            -- Update cast bar for the unit
            if arg1 and customFrames[arg1] then
                -- Store empowered state directly from event (reliable, like CastBars.lua)
                if isEmpowerStart and empowerSpellID then
                    customFrames[arg1].empowerSpellID = empowerSpellID
                    customFrames[arg1].isEmpoweredCast = true
                elseif isEmpowerStop then
                    customFrames[arg1].empowerSpellID = nil
                    customFrames[arg1].isEmpoweredCast = false
                end
                UpdateFrameData(arg1)
            end
            -- Update SPECIFIC party member frame only (DATA ONLY - PERFORMANCE)
            if arg1 then
                local partyIndex = arg1:match("^party(%d)$")
                if partyIndex then
                    local index = tonumber(partyIndex)
                    if index and settings and settings.party and settings.party.enabled then
                        -- Store empowered state on party frame
                        if partyMemberFrames and partyMemberFrames[index] then
                            if isEmpowerStart and empowerSpellID then
                                partyMemberFrames[index].empowerSpellID = empowerSpellID
                                partyMemberFrames[index].isEmpoweredCast = true
                            elseif isEmpowerStop then
                                partyMemberFrames[index].empowerSpellID = nil
                                partyMemberFrames[index].isEmpoweredCast = false
                            end
                        end
                        -- Use data-only update for performance (no layout changes on cast events)
                        UnitFrames:UpdatePartyMemberDataOnly(index)
                    end
                end
            end
            -- Update SPECIFIC raid member frame only (DATA ONLY - PERFORMANCE)
            if arg1 then
                local raidIndex = arg1:match("^raid(%d+)$")
                if raidIndex then
                    local index = tonumber(raidIndex)
                    if index and settings and settings.raid and settings.raid.enabled then
                        local raidSize = GetNumGroupMembers()
                        local threshold = settings.raid.sizeThreshold or 20
                        local sizeType = raidSize <= threshold and "small" or "large"
                        -- Store empowered state on raid frame
                        local raidFrames = sizeType == "small" and raidSmallMemberFrames or raidLargeMemberFrames
                        if raidFrames and raidFrames[index] then
                            if isEmpowerStart and empowerSpellID then
                                raidFrames[index].empowerSpellID = empowerSpellID
                                raidFrames[index].isEmpoweredCast = true
                            elseif isEmpowerStop then
                                raidFrames[index].empowerSpellID = nil
                                raidFrames[index].isEmpoweredCast = false
                            end
                        end
                        -- Use data-only update for performance (no layout changes on cast events)
                        UnitFrames:UpdateRaidMemberDataOnly(sizeType, index)
                    end
                end
            end
            -- Also update tank frames if it's a raid member
            if arg1 and arg1:match("^raid%d+$") then
                pcall(function() UnitFrames:UpdateTankFrames() end)
            end
            -- Also update boss frames if it's a boss unit (DATA ONLY - PERFORMANCE)
            if arg1 and arg1:match("^boss%d$") then
                local bossIndex = tonumber(arg1:match("^boss(%d)$"))
                if bossIndex and settings and settings.boss and settings.boss.enabled then
                    -- Store empowered state on boss frame
                    if bossMemberFrames and bossMemberFrames[bossIndex] then
                        if isEmpowerStart and empowerSpellID then
                            bossMemberFrames[bossIndex].empowerSpellID = empowerSpellID
                            bossMemberFrames[bossIndex].isEmpoweredCast = true
                        elseif isEmpowerStop then
                            bossMemberFrames[bossIndex].empowerSpellID = nil
                            bossMemberFrames[bossIndex].isEmpoweredCast = false
                        end
                    end
                    -- Use data-only update for performance (no layout changes on cast events)
                    UnitFrames:UpdateBossMemberDataOnly(bossIndex)
                end
            end
        end
    end)
end

-- ============================================================================
-- EDIT MODE INTEGRATION
-- ============================================================================

-- RegisterWithEditMode is deprecated - Layout system now handles positioning
-- This function is stubbed out for backwards compatibility
local function RegisterWithEditMode(unit)
    -- No-op: Layout system handles unit frame positioning now
end

-- ============================================================================
-- MODULE LIFECYCLE
-- ============================================================================

function UnitFrames:OnInitialize()
    TweaksUI:PrintDebug("Unit Frames module initializing...")
    
    -- Detect external addons that handle party/raid frames
    DetectExternalAddons()
    
    -- Show detection messages
    local partyAddon = self:GetExternalPartyAddon()
    local raidAddon = self:GetExternalRaidAddon()
    
    if partyAddon and raidAddon then
        if partyAddon == raidAddon then
            TweaksUI:Print("|cffFFD100" .. partyAddon .. "|r detected - TweaksUI party/raid frames disabled to avoid conflicts.")
        else
            TweaksUI:Print("|cffFFD100" .. partyAddon .. "|r detected - TweaksUI party frames disabled.")
            TweaksUI:Print("|cffFFD100" .. raidAddon .. "|r detected - TweaksUI raid frames disabled.")
        end
    elseif partyAddon then
        TweaksUI:Print("|cffFFD100" .. partyAddon .. "|r detected - TweaksUI party frames disabled to avoid conflicts.")
    elseif raidAddon then
        TweaksUI:Print("|cffFFD100" .. raidAddon .. "|r detected - TweaksUI raid frames disabled to avoid conflicts.")
    end
    
    settings = self:GetSettings()
    
    -- Apply defaults
    if settings.enabled == nil then
        settings.enabled = DEFAULTS.enabled
    end
    
    -- Initialize general settings (module-wide options)
    if not settings.general then
        settings.general = {}
    end
    for key, value in pairs(DEFAULTS.general) do
        if type(value) == "table" then
            -- Handle nested tables like mouseoverHighlight
            if not settings.general[key] then
                settings.general[key] = CopyTable(value)
            else
                -- Merge with defaults to add any new keys
                for subKey, subValue in pairs(value) do
                    if settings.general[key][subKey] == nil then
                        settings.general[key][subKey] = type(subValue) == "table" and CopyTable(subValue) or subValue
                    end
                end
            end
        elseif settings.general[key] == nil then
            settings.general[key] = value
        end
    end
    
    -- Individual unit types (not party)
    local initUnits = {"player", "target", "focus", "targettarget", "pet"}
    
    -- Per-unit defaults for individual unit types
    for _, unit in ipairs(initUnits) do
        if not settings[unit] then
            settings[unit] = GetDefaultFrameSettings(unit)
        else
            -- Merge with defaults
            local defaults = GetDefaultFrameSettings(unit)
            for category, catDefaults in pairs(defaults) do
                if type(catDefaults) == "table" then
                    if not settings[unit][category] then
                        settings[unit][category] = {}
                    end
                    for key, value in pairs(catDefaults) do
                        if settings[unit][category][key] == nil then
                            settings[unit][category][key] = type(value) == "table" and CopyTable(value) or value
                        end
                    end
                elseif settings[unit][category] == nil then
                    settings[unit][category] = catDefaults
                end
            end
        end
    end
    
    -- Party container defaults - uses same structure as individual frames
    if not settings.party then
        -- Start with GetDefaultFrameSettings for party-style frame
        settings.party = GetDefaultFrameSettings("party1")
        
        -- Add container-specific settings
        settings.party.container = {
            x = -450,
            y = 100,
            anchor = "CENTER",
            growthDirection = "DOWN",
            spacing = 2,
            scale = 1.0,
        }
        settings.party.sorting = {
            enabled = true,
            sortByRole = true,
            separateMeleeRanged = true,
            sortByClass = false,
            sortAlphabetically = true,
            selfPosition = "NORMAL",
        }
        settings.party.rangeFade = {
            enabled = true,
            checkInterval = 0.2,
            outOfRangeAlpha = 0.4,
            perElementFade = true,
        }
        settings.party.healPrediction = {
            enabled = true,
            showMyHeals = true,
            showOtherHeals = true,
            separateColors = false,
            myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
            otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
            allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
            showAbsorbs = true,
            absorbColor = { 0.8, 0.8, 0.2, 0.6 },
            absorbOverlay = true,
        }
        settings.party.hideInRaid = true  -- Hide party frames when in a raid group
    else
        -- Check if party settings structure is valid (has required tables)
        -- If old/corrupted structure, reset to defaults
        local needsReset = false
        if settings.party.memberFrame then needsReset = true end  -- Old structure
        if not settings.party.frame then needsReset = true end
        if not settings.party.healthBar then needsReset = true end
        if not settings.party.healthText then needsReset = true end
        if not settings.party.powerText then needsReset = true end
        if not settings.party.nameText then needsReset = true end
        if not settings.party.levelText then needsReset = true end
        if not settings.party.portrait then needsReset = true end
        if not settings.party.powerBar then needsReset = true end
        if not settings.party.raidTarget then needsReset = true end
        if not settings.party.roleIcon then needsReset = true end
        if not settings.party.debuffIndicators then needsReset = true end
        
        if needsReset then
            local wasEnabled = settings.party.enabled
            local oldContainer = settings.party.container
            
            -- Reset to fresh defaults
            settings.party = GetDefaultFrameSettings("party1")
            
            -- Only override enabled if it was explicitly set (not nil)
            if wasEnabled ~= nil then
                settings.party.enabled = wasEnabled
            end
            
            -- Preserve container position if it existed
            if oldContainer then
                settings.party.container = oldContainer
            else
                settings.party.container = {
                    x = -450,
                    y = 100,
                    anchor = "CENTER",
                    growthDirection = "DOWN",
                    spacing = 2,
                    scale = 1.0,
                }
            end
            settings.party.sorting = {
                enabled = true,
                sortByRole = true,
                separateMeleeRanged = true,
                sortByClass = false,
                sortAlphabetically = true,
                selfPosition = "NORMAL",
            }
            settings.party.rangeFade = {
                enabled = true,
                checkInterval = 0.2,
                outOfRangeAlpha = 0.4,
                perElementFade = true,
            }
            settings.party.healPrediction = {
                enabled = true,
                showMyHeals = true,
                showOtherHeals = true,
                separateColors = false,
                myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
                otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
                allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
                showAbsorbs = true,
                absorbColor = { 0.8, 0.8, 0.2, 0.6 },
                absorbOverlay = true,
            }
        else
            -- Get complete defaults for party frame
            local defaults = GetDefaultFrameSettings("party1")
            
            -- Helper to deep merge defaults into existing settings (only adds missing fields)
            local function MergeDefaults(existing, default)
                if type(existing) ~= "table" or type(default) ~= "table" then return end
                for k, v in pairs(default) do
                    if existing[k] == nil then
                        if type(v) == "table" then
                            existing[k] = CopyTable(v)
                        else
                            existing[k] = v
                        end
                    elseif type(v) == "table" and type(existing[k]) == "table" then
                        MergeDefaults(existing[k], v)
                    end
                end
            end
            
            -- Ensure all sections exist and have all required fields
            MergeDefaults(settings.party.frame, defaults.frame)
            MergeDefaults(settings.party.healthBar, defaults.healthBar)
            MergeDefaults(settings.party.powerBar, defaults.powerBar)
            MergeDefaults(settings.party.healthText, defaults.healthText)
            MergeDefaults(settings.party.powerText, defaults.powerText)
            MergeDefaults(settings.party.nameText, defaults.nameText)
            MergeDefaults(settings.party.levelText, defaults.levelText)
            MergeDefaults(settings.party.portrait, defaults.portrait)
            MergeDefaults(settings.party.raidTarget, defaults.raidTarget)
            MergeDefaults(settings.party.roleIcon, defaults.roleIcon)
            MergeDefaults(settings.party.debuffIndicators, defaults.debuffIndicators)
            
            -- New indicator settings (v1.1+) - ensure they exist with defaults
            if not settings.party.statusIndicators then
                settings.party.statusIndicators = CopyTable(defaults.statusIndicators)
            else
                MergeDefaults(settings.party.statusIndicators, defaults.statusIndicators)
            end
            if not settings.party.leaderIndicator then
                settings.party.leaderIndicator = CopyTable(defaults.leaderIndicator)
            else
                MergeDefaults(settings.party.leaderIndicator, defaults.leaderIndicator)
            end
            if not settings.party.summonIndicator then
                settings.party.summonIndicator = CopyTable(defaults.summonIndicator)
            else
                MergeDefaults(settings.party.summonIndicator, defaults.summonIndicator)
            end
            -- Note: mouseoverHighlight is now in general settings, not per-frame
            if not settings.party.targetHighlight then
                settings.party.targetHighlight = CopyTable(defaults.targetHighlight)
            else
                MergeDefaults(settings.party.targetHighlight, defaults.targetHighlight)
            end
            
            -- Ensure castBar exists (may be missing from old settings)
            if not settings.party.castBar then
                settings.party.castBar = CopyTable(defaults.castBar)
            else
                MergeDefaults(settings.party.castBar, defaults.castBar)
            end
            
            if not settings.party.container then
                settings.party.container = {
                    x = -450,
                    y = 100,
                    anchor = "CENTER",
                    growthDirection = "DOWN",
                    spacing = 2,
                    scale = 1.0,
                }
            else
                -- Ensure scale exists
                if settings.party.container.scale == nil then
                    settings.party.container.scale = 1.0
                end
            end
        end
    end
    
    -- Enforce minimum icon sizes for party frames (fixes small icons from old settings)
    if settings.party then
        -- Ensure rangeCheck exists with defaults (always enabled)
        if not settings.party.rangeCheck then
            settings.party.rangeCheck = {
                enabled = true,
                outOfRangeAlpha = 0.4,
                updateInterval = 0.2,
                useSmoothFade = true,
                fadeSpeed = 0.3,
            }
        elseif settings.party.rangeCheck.enabled == nil then
            settings.party.rangeCheck.enabled = true
        end
        
        -- Add hideInRaid default if missing
        if settings.party.hideInRaid == nil then
            settings.party.hideInRaid = true
        end
        
        -- Migrate sorting from old string format to new table format (v1.6.1+)
        if not settings.party.sorting or type(settings.party.sorting) ~= "table" then
            settings.party.sorting = {
                enabled = true,
                sortByRole = true,
                separateMeleeRanged = true,
                sortByClass = false,
                sortAlphabetically = true,
                selfPosition = "NORMAL",
            }
        end
        
        -- Add rangeFade settings if missing (v1.6.1+)
        if not settings.party.rangeFade or type(settings.party.rangeFade) ~= "table" then
            settings.party.rangeFade = {
                enabled = true,
                checkInterval = 0.2,
                outOfRangeAlpha = 0.4,
                perElementFade = true,
            }
        end
        
        -- Add healPrediction settings if missing (v1.6.1+)
        if not settings.party.healPrediction or type(settings.party.healPrediction) ~= "table" then
            settings.party.healPrediction = {
                enabled = true,
                showMyHeals = true,
                showOtherHeals = true,
                separateColors = false,
                myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
                otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
                allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
                showAbsorbs = true,
                absorbColor = { 0.8, 0.8, 0.2, 0.6 },
                absorbOverlay = true,
            }
        end
        
        -- Add defensiveIcon settings if missing (v1.6.2+)
        if not settings.party.defensiveIcon or type(settings.party.defensiveIcon) ~= "table" then
            settings.party.defensiveIcon = {
                enabled = true,
                size = 28,
                scale = 1.0,
                anchor = "CENTER",
                offsetX = 0,
                offsetY = 0,
                showBorder = true,
                borderSize = 2,
                borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
                showCooldown = true,
                showSwipe = true,
                showDuration = true,
        showDurationText = false,
            }
        end
        
        -- Add dispelOverlay settings if missing (v1.6.2+)
        if not settings.party.dispelOverlay or type(settings.party.dispelOverlay) ~= "table" then
            settings.party.dispelOverlay = {
                enabled = true,
            fillAlpha = 0.5,
                showBorder = true,
                borderSize = 2,
                borderAlpha = 0.9,
                showGlow = true,
                glowSize = 3,
                glowAlpha = 0.25,
                showPulse = true,
                onlyPlayerDispellable = false,
                showBleed = false,
                showEnrage = false,
            }
        end
        
        -- Add threatOverlay settings if missing (v1.6.2+)
        if not settings.party.threatOverlay or type(settings.party.threatOverlay) ~= "table" then
            settings.party.threatOverlay = {
                enabled = false,
                showBorder = true,
                borderSize = 2,
                borderAlpha = 0.9,
                showGlow = true,
                glowSize = 4,
                glowAlpha = 0.3,
                showPulse = true,
                
                onlyTanking = false,
                
            }
        end
        
        -- Add/migrate buffs settings (v1.6.3+)
        if not settings.party.buffs or type(settings.party.buffs) ~= "table" then
            settings.party.buffs = {
                enabled = false,
                maxAuras = 4,
                size = 16,
                spacing = 2,
                growDirection = "RIGHT",
                anchor = "BOTTOMLEFT",
                frameAnchor = "TOPLEFT",
                offsetX = 0,
                offsetY = 2,
                filter = "HELPFUL|PLAYER",
                hidePermanent = true,
                showDuration = true,
                showDurationText = false,
                showStacks = true,
                showBorder = true,
                durationFontSize = 10,
                stackFontSize = 10,
                sweepAlpha = 1.0,
                durationColor = { 1, 1, 0.6, 1 },
            }
        else
            -- Ensure filter is set correctly for existing settings
            if not settings.party.buffs.filter then
                settings.party.buffs.filter = "HELPFUL|PLAYER"
            end
            -- Ensure font size defaults exist
            if settings.party.buffs.durationFontSize == nil then
                settings.party.buffs.durationFontSize = 10
            end
            if settings.party.buffs.stackFontSize == nil then
                settings.party.buffs.stackFontSize = 10
            end
        end
        
        -- Add/migrate debuffs settings (v1.6.3+)
        if not settings.party.debuffs or type(settings.party.debuffs) ~= "table" then
            settings.party.debuffs = {
                enabled = false,
                maxAuras = 3,
                size = 16,
                spacing = 2,
                growDirection = "RIGHT",
                anchor = "TOPLEFT",
                frameAnchor = "BOTTOMLEFT",
                offsetX = 0,
                offsetY = -2,
                filter = "HARMFUL",
                hidePermanent = true,
                showDuration = true,
                showDurationText = false,
                showStacks = true,
                colorByDispelType = true,
                durationFontSize = 10,
                stackFontSize = 10,
                sweepAlpha = 1.0,
                durationColor = { 1, 1, 0.6, 1 },
            }
        else
            -- Ensure filter is set
            if not settings.party.debuffs.filter then
                settings.party.debuffs.filter = "HARMFUL"
            end
            -- Ensure font size defaults exist
            if settings.party.debuffs.durationFontSize == nil then
                settings.party.debuffs.durationFontSize = 10
            end
            if settings.party.debuffs.stackFontSize == nil then
                settings.party.debuffs.stackFontSize = 10
            end
        end
        
        if settings.party.roleIcon and settings.party.roleIcon.size and settings.party.roleIcon.size < 14 then
            settings.party.roleIcon.size = 16
        end
        if settings.party.raidTarget and settings.party.raidTarget.size and settings.party.raidTarget.size < 14 then
            settings.party.raidTarget.size = 18
        end
        if settings.party.debuffIndicators and settings.party.debuffIndicators.size and settings.party.debuffIndicators.size < 12 then
            settings.party.debuffIndicators.size = 14
        end
        
        -- Fix bad offsets that put icons outside frame (from old settings)
        if settings.party.roleIcon then
            local ri = settings.party.roleIcon
            -- If offset is way outside (like -50), reset to sensible inside values
            if ri.offsetX and (ri.offsetX < -20 or ri.offsetX > 20) then
                ri.offsetX = 2
            end
            if ri.offsetY and (ri.offsetY < -20 or ri.offsetY > 20) then
                ri.offsetY = -2
            end
        end
        if settings.party.raidTarget then
            local rt = settings.party.raidTarget
            if rt.offsetX and (rt.offsetX < -20 or rt.offsetX > 20) then
                rt.offsetX = 0
            end
            if rt.offsetY and (rt.offsetY < -20 or rt.offsetY > 20) then
                rt.offsetY = -2
            end
        end
    end
    
    -- Raid container defaults - now with small/large layouts
    if not settings.raid then
        settings.raid = CopyTable(RAID_DEFAULTS)
        -- Fill in small layout visual defaults from shared
        for k, v in pairs(RAID_FRAME_VISUAL_DEFAULTS) do
            if settings.raid.small[k] == nil then
                settings.raid.small[k] = CopyTable(v)
            end
        end
    else
        -- Check if raid settings structure is valid (new structure)
        local needsReset = false
        if not settings.raid.small then needsReset = true end
        if not settings.raid.large then needsReset = true end
        if settings.raid.small and not settings.raid.small.layout then needsReset = true end
        if settings.raid.large and not settings.raid.large.layout then needsReset = true end
        -- Also reset if old structure detected (had container at top level)
        if settings.raid.container and not settings.raid.small then needsReset = true end
        
        if needsReset then
            local wasEnabled = settings.raid.enabled
            
            -- Reset to fresh defaults
            settings.raid = CopyTable(RAID_DEFAULTS)
            -- Fill in small layout visual defaults
            for k, v in pairs(RAID_FRAME_VISUAL_DEFAULTS) do
                if settings.raid.small[k] == nil then
                    settings.raid.small[k] = CopyTable(v)
                end
            end
            
            if wasEnabled ~= nil then
                settings.raid.enabled = wasEnabled
            end
        else
            -- Merge defaults into existing settings
            local function MergeRaidDefaults(existing, default)
                if type(existing) ~= "table" or type(default) ~= "table" then return end
                for k, v in pairs(default) do
                    if existing[k] == nil then
                        if type(v) == "table" then
                            existing[k] = CopyTable(v)
                        else
                            existing[k] = v
                        end
                    elseif type(v) == "table" and type(existing[k]) == "table" then
                        MergeRaidDefaults(existing[k], v)
                    end
                end
            end
            
            MergeRaidDefaults(settings.raid, RAID_DEFAULTS)
            -- Also merge visual defaults into small
            for k, v in pairs(RAID_FRAME_VISUAL_DEFAULTS) do
                if settings.raid.small[k] == nil then
                    settings.raid.small[k] = CopyTable(v)
                end
            end
        end
        
        -- Explicit migration for sorting, rangeFade, healPrediction (v1.6.1+)
        -- Small raid
        if settings.raid.small then
            if not settings.raid.small.sorting or type(settings.raid.small.sorting) ~= "table" then
                settings.raid.small.sorting = {
                    enabled = true,
            fillAlpha = 0.5,
                    sortByRole = true,
                    separateMeleeRanged = false,
                    sortByClass = false,
                    sortAlphabetically = true,
                    sortByGroup = true,
                    selfPosition = "NORMAL",
                }
            end
            if not settings.raid.small.rangeFade or type(settings.raid.small.rangeFade) ~= "table" then
                settings.raid.small.rangeFade = {
                    enabled = true,
            fillAlpha = 0.5,
                    checkInterval = 0.2,
                    outOfRangeAlpha = 0.4,
                    perElementFade = true,
                }
            end
            if not settings.raid.small.healPrediction or type(settings.raid.small.healPrediction) ~= "table" then
                settings.raid.small.healPrediction = {
                    enabled = true,
            fillAlpha = 0.5,
                    showMyHeals = true,
                    showOtherHeals = true,
                    separateColors = false,
                    myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
                    otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
                    allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
                    showAbsorbs = true,
                    absorbColor = { 0.8, 0.8, 0.2, 0.6 },
                    absorbOverlay = true,
                }
            end
            if not settings.raid.small.defensiveIcon or type(settings.raid.small.defensiveIcon) ~= "table" then
                settings.raid.small.defensiveIcon = {
                    enabled = true,
                    size = 20,
                    scale = 1.0,
                    anchor = "CENTER",
                    offsetX = 0,
                    offsetY = 0,
                    showBorder = true,
                    borderSize = 1,
                    borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
                    showCooldown = true,
                    showSwipe = true,
                    showDuration = false,
        showDurationText = false,
                }
            end
            if not settings.raid.small.dispelOverlay or type(settings.raid.small.dispelOverlay) ~= "table" then
                settings.raid.small.dispelOverlay = {
                    enabled = true,
            fillAlpha = 0.5,
                    showBorder = true,
                    borderSize = 1,
                    borderAlpha = 0.9,
                    showGlow = false,
                    glowSize = 2,
                    glowAlpha = 0.2,
                    showPulse = true,
                    onlyPlayerDispellable = false,
                    showBleed = false,
                    showEnrage = false,
                }
            end
            if not settings.raid.small.threatOverlay or type(settings.raid.small.threatOverlay) ~= "table" then
                settings.raid.small.threatOverlay = {
                    enabled = false,
                    showBorder = true,
                    borderSize = 1,
                    borderAlpha = 0.9,
                    showGlow = false,
                    glowSize = 2,
                    glowAlpha = 0.2,
                    showPulse = true,
                    
                    onlyTanking = false,
                    
                }
            end
        end
        -- Large raid
        if settings.raid.large then
            if not settings.raid.large.sorting or type(settings.raid.large.sorting) ~= "table" then
                settings.raid.large.sorting = {
                    enabled = true,
            fillAlpha = 0.5,
                    sortByRole = true,
                    separateMeleeRanged = false,
                    sortByClass = false,
                    sortAlphabetically = true,
                    sortByGroup = true,
                    selfPosition = "NORMAL",
                }
            end
            if not settings.raid.large.rangeFade or type(settings.raid.large.rangeFade) ~= "table" then
                settings.raid.large.rangeFade = {
                    enabled = true,
            fillAlpha = 0.5,
                    checkInterval = 0.2,
                    outOfRangeAlpha = 0.4,
                    perElementFade = false,
                }
            end
            if not settings.raid.large.healPrediction or type(settings.raid.large.healPrediction) ~= "table" then
                settings.raid.large.healPrediction = {
                    enabled = true,
            fillAlpha = 0.5,
                    showMyHeals = true,
                    showOtherHeals = true,
                    separateColors = false,
                    myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
                    otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
                    allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
                    showAbsorbs = true,
                    absorbColor = { 0.8, 0.8, 0.2, 0.6 },
                    absorbOverlay = false,
                }
            end
            if not settings.raid.large.defensiveIcon or type(settings.raid.large.defensiveIcon) ~= "table" then
                settings.raid.large.defensiveIcon = {
                    enabled = true,
                    size = 18,
                    scale = 1.0,
                    anchor = "CENTER",
                    offsetX = 0,
                    offsetY = 0,
                    showBorder = true,
                    borderSize = 1,
                    borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
                    showCooldown = true,
                    showSwipe = true,
                    showDuration = false,
        showDurationText = false,
                }
            end
            if not settings.raid.large.dispelOverlay or type(settings.raid.large.dispelOverlay) ~= "table" then
                settings.raid.large.dispelOverlay = {
                    enabled = true,
            fillAlpha = 0.5,
                    showBorder = true,
                    borderSize = 1,
                    borderAlpha = 0.9,
                    showGlow = false,
                    glowSize = 2,
                    glowAlpha = 0.2,
                    showPulse = true,
                    onlyPlayerDispellable = false,
                    showBleed = false,
                    showEnrage = false,
                }
            end
            if not settings.raid.large.threatOverlay or type(settings.raid.large.threatOverlay) ~= "table" then
                settings.raid.large.threatOverlay = {
                    enabled = false,
                    showBorder = true,
                    borderSize = 1,
                    borderAlpha = 0.9,
                    showGlow = false,
                    glowSize = 2,
                    glowAlpha = 0.2,
                    showPulse = true,
                    
                    onlyTanking = false,
                    
                }
            end
            
            -- Add/migrate buffs settings for raid.large (v1.6.3+)
            if not settings.raid.large.buffs or type(settings.raid.large.buffs) ~= "table" then
                settings.raid.large.buffs = {
                    enabled = false,
                    maxAuras = 3,
                    size = 12,
                    spacing = 1,
                    growDirection = "RIGHT",
                    anchor = "BOTTOMLEFT",
                    frameAnchor = "TOPLEFT",
                    offsetX = 0,
                    offsetY = 1,
                    filter = "HELPFUL|PLAYER",
                    hidePermanent = true,
                    showDuration = true,
                    showDurationText = false,
                    showStacks = true,
                    showBorder = true,
                    durationFontSize = 10,
                    stackFontSize = 10,
                    sweepAlpha = 1.0,
                    durationColor = { 1, 1, 0.6, 1 },
                }
            else
                if not settings.raid.large.buffs.filter then
                    settings.raid.large.buffs.filter = "HELPFUL|PLAYER"
                end
                -- Ensure font size defaults exist
                if settings.raid.large.buffs.durationFontSize == nil then
                    settings.raid.large.buffs.durationFontSize = 10
                end
                if settings.raid.large.buffs.stackFontSize == nil then
                    settings.raid.large.buffs.stackFontSize = 10
                end
            end
            
            -- Add/migrate debuffs settings for raid.large (v1.6.3+)
            if not settings.raid.large.debuffs or type(settings.raid.large.debuffs) ~= "table" then
                settings.raid.large.debuffs = {
                    enabled = false,
                    maxAuras = 2,
                    size = 12,
                    spacing = 1,
                    growDirection = "RIGHT",
                    anchor = "TOPLEFT",
                    frameAnchor = "BOTTOMLEFT",
                    offsetX = 0,
                    offsetY = -1,
                    filter = "HARMFUL",
                    hidePermanent = true,
                    showDuration = true,
                    showDurationText = false,
                    showStacks = true,
                    colorByDispelType = true,
                    durationFontSize = 10,
                    stackFontSize = 10,
                    sweepAlpha = 1.0,
                    durationColor = { 1, 1, 0.6, 1 },
                }
            else
                if not settings.raid.large.debuffs.filter then
                    settings.raid.large.debuffs.filter = "HARMFUL"
                end
                -- Ensure font size defaults exist
                if settings.raid.large.debuffs.durationFontSize == nil then
                    settings.raid.large.debuffs.durationFontSize = 10
                end
                if settings.raid.large.debuffs.stackFontSize == nil then
                    settings.raid.large.debuffs.stackFontSize = 10
                end
            end
        end
    end
    
    -- Tank frames defaults
    if not settings.tanks then
        settings.tanks = CopyTable(TANK_DEFAULTS)
    else
        -- Merge defaults into existing settings
        local function MergeTankDefaults(existing, default)
            if type(existing) ~= "table" or type(default) ~= "table" then return end
            for k, v in pairs(default) do
                if existing[k] == nil then
                    if type(v) == "table" then
                        existing[k] = CopyTable(v)
                    else
                        existing[k] = v
                    end
                elseif type(v) == "table" and type(existing[k]) == "table" then
                    MergeTankDefaults(existing[k], v)
                end
            end
        end
        MergeTankDefaults(settings.tanks, TANK_DEFAULTS)
    end
    
    -- Boss frames defaults
    if not settings.boss then
        settings.boss = CopyTable(BOSS_DEFAULTS)
    else
        -- Merge defaults into existing settings
        local function MergeBossDefaults(existing, default)
            if type(existing) ~= "table" or type(default) ~= "table" then return end
            for k, v in pairs(default) do
                if existing[k] == nil then
                    if type(v) == "table" then
                        existing[k] = CopyTable(v)
                    else
                        existing[k] = v
                    end
                elseif type(v) == "table" and type(existing[k]) == "table" then
                    MergeBossDefaults(existing[k], v)
                end
            end
        end
        MergeBossDefaults(settings.boss, BOSS_DEFAULTS)
    end
    
    -- Get libraries
    LibSharedMedia = LibStub and LibStub("LibSharedMedia-3.0", true)
    -- LibEditMode is now managed by TweaksUI.EditMode (Core/EditModeManager.lua)
    TweaksUI:PrintDebug("Unit Frames: Using centralized EditModeManager")
end

-- Party member units (for party container)
-- Module-level constant (converted from local to avoid 200 local variable limit)
UnitFrames.PARTY_UNITS = {"player", "party1", "party2", "party3", "party4"}

-- Simulated party data for preview
local SIMULATED_PARTY = {
    { unit = "player", name = "You", class = "WARRIOR", health = 100000, maxHealth = 100000, power = 100, maxPower = 100, powerType = 1, role = "TANK" },
    { unit = "party1", name = "Healbot", class = "PRIEST", health = 72000, maxHealth = 80000, power = 65000, maxPower = 80000, powerType = 0, role = "HEALER", debuffType = "Magic" },
    { unit = "party2", name = "Tankadin", class = "PALADIN", health = 95000, maxHealth = 120000, power = 40000, maxPower = 50000, powerType = 0, role = "TANK" },
    { unit = "party3", name = "Stabsworth", class = "ROGUE", health = 68000, maxHealth = 85000, power = 100, maxPower = 100, powerType = 3, role = "DAMAGER", debuffType = "Poison" },
    { unit = "party4", name = "Pyromancer", class = "MAGE", health = 55000, maxHealth = 70000, power = 45000, maxPower = 60000, powerType = 0, role = "DAMAGER", debuffType = "Curse" },
}

-- Simulated raid data (40 players in 8 groups)
local SIMULATED_RAID = {}
local RAID_SIM_DATA = {
    classes = {"WARRIOR", "PALADIN", "HUNTER", "ROGUE", "PRIEST", "DEATHKNIGHT", "SHAMAN", "MAGE", "WARLOCK", "MONK", "DRUID", "DEMONHUNTER", "EVOKER"},
    roles = {"TANK", "HEALER", "DAMAGER", "DAMAGER", "DAMAGER"},  -- Weight toward DPS
    names = {"Aegis", "Blade", "Cinder", "Dawn", "Echo", "Frost", "Gale", "Haven", "Iron", "Jade", "Kite", "Luna", "Mist", "Nova", "Oak", "Pyre", "Quinn", "Rune", "Storm", "Thorn", "Uma", "Vale", "Wind", "Xen", "Yara", "Zephyr", "Arrow", "Blaze", "Cloud", "Dusk", "Ember", "Flare", "Grove", "Hawk", "Ivy", "Jinx", "Keeper", "Lark", "Moss", "Night"},
}
for i = 1, 40 do
    local group = math.ceil(i / 5)
    local healthMax = math.random(70000, 120000)
    local powerMax = math.random(40000, 80000)
    local healthPct = math.random(50, 100) / 100
    local powerPct = math.random(30, 100) / 100
    local classIndex = ((i - 1) % #RAID_SIM_DATA.classes) + 1
    local roleIndex = ((i - 1) % #RAID_SIM_DATA.roles) + 1
    local debuffTypes = {nil, nil, nil, "Magic", "Curse", "Disease", "Poison"}  -- Mostly nil
    local debuffIndex = math.random(1, #debuffTypes)
    
    SIMULATED_RAID[i] = {
        unit = i == 1 and "player" or "raid" .. i,
        name = RAID_SIM_DATA.names[i] or ("Raider" .. i),
        class = RAID_SIM_DATA.classes[classIndex],
        health = math.floor(healthMax * healthPct),
        maxHealth = healthMax,
        power = math.floor(powerMax * powerPct),
        maxPower = powerMax,
        powerType = (classIndex == 4 or classIndex == 12) and 3 or 0,  -- Energy for rogues/DH
        role = roleIndex <= 2 and RAID_SIM_DATA.roles[roleIndex] or "DAMAGER",
        group = group,
        debuffType = debuffTypes[debuffIndex],
    }
end
-- Ensure first 2 are tanks, next 4 are healers
SIMULATED_RAID[1].role = "TANK"
SIMULATED_RAID[2].role = "TANK"
SIMULATED_RAID[3].role = "HEALER"
SIMULATED_RAID[4].role = "HEALER"
SIMULATED_RAID[5].role = "HEALER"
SIMULATED_RAID[6].role = "HEALER"
-- Ensure some have debuffs for preview
SIMULATED_RAID[2].debuffType = "Magic"
SIMULATED_RAID[4].debuffType = "Curse"
SIMULATED_RAID[7].debuffType = "Disease"
SIMULATED_RAID[10].debuffType = "Poison"

-- ============================================================================
-- BLIZZARD PARTY FRAME HIDING
-- ============================================================================

function UnitFrames.HideBlizzardPartyFrames()
    -- IMPORTANT: Don't modify Blizzard secure frames during combat to avoid taint
    if InCombatLockdown() then return end
    
    -- CRITICAL: Don't modify frames during Edit Mode - this causes taint/errors
    if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
        return
    end
    
    -- Also skip during TUI Layout Mode (not strictly necessary but consistent)
    if TweaksUI.Layout and TweaksUI.Layout:IsActive() then
        return
    end
    
    -- Use MaskBlizzardFrame for each party unit - this handles everything consistently
    for i = 1, 4 do
        MaskBlizzardFrame("party" .. i)
    end
    
    -- Move main PartyFrame container off-screen
    if PartyFrame then
        MoveFrameOffScreen(PartyFrame, "PartyFrame")
    end
    
    -- Move CompactPartyFrame (raid-style party frames) off-screen
    if CompactPartyFrame then
        MoveFrameOffScreen(CompactPartyFrame, "CompactPartyFrame")
    end
    
    -- Move named CompactPartyFrameMember1-5 frames off-screen
    for i = 1, 5 do
        local memberName = "CompactPartyFrameMember" .. i
        local member = _G[memberName]
        if member then
            MoveFrameOffScreen(member, memberName)
        end
    end
    
    -- Move CompactRaidFrameContainer off-screen if showing party as raid
    if CompactRaidFrameContainer then
        MoveFrameOffScreen(CompactRaidFrameContainer, "CompactRaidFrameContainer")
    end
end

-- Hook the Selection highlight on party member frames to keep them hidden
-- Note: MaskBlizzardFrame handles the actual hooks when party is masked,
-- this function provides backup hooks that check settings.party.enabled
local function HookPartySelectionHighlights()
    if UnitFrames.BlizzState.partySelectionHooked then return end
    if not PartyFrame then return end
    
    -- Just ensure the main PartyFrame stays hidden when our party frames are enabled
    if not PartyFrame._tuiPartyHook then
        hooksecurefunc(PartyFrame, "SetAlpha", function(self, alpha)
            -- Use pcall to safely compare alpha (may be secret in Midnight)
            local isPositive = true
            pcall(function() isPositive = alpha > 0 end)
            if isPositive and settings and settings.party and settings.party.enabled then
                C_Timer.After(0, function()
                    if self and self.SetAlpha and not InCombatLockdown() then
                        self:SetAlpha(0)
                    end
                end)
            end
        end)
        PartyFrame._tuiPartyHook = true
    end
    
    UnitFrames.BlizzState.partySelectionHooked = true
end

-- Hook Blizzard party frames to prevent them from showing
local function HookBlizzardPartyFrames()
    if UnitFrames.BlizzState.partyHooked then return end
    UnitFrames.BlizzState.partyHooked = true
    
    -- Hook the Selection highlights to keep them hidden
    HookPartySelectionHighlights()
    
    -- Hook PartyFrame's Show method
    if PartyFrame then
        hooksecurefunc(PartyFrame, "Show", function(self)
            if settings and settings.party and settings.party.enabled then
                -- Skip during Edit Mode to prevent taint
                if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
                    return
                end
                -- Re-hide immediately
                C_Timer.After(0, function()
                    if not InCombatLockdown() then
                        UnitFrames.HideBlizzardPartyFrames()
                    end
                end)
            end
        end)
        
        -- Also hook SetShown
        local origSetShown = PartyFrame.SetShown
        if origSetShown then
            hooksecurefunc(PartyFrame, "SetShown", function(self, shown)
                if shown and settings and settings.party and settings.party.enabled then
                    -- Skip during Edit Mode to prevent taint
                    if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
                        return
                    end
                    C_Timer.After(0, function()
                        if not InCombatLockdown() then
                            UnitFrames.HideBlizzardPartyFrames()
                        end
                    end)
                end
            end)
        end
    end
    
    -- Hook CompactPartyFrame if it exists
    if CompactPartyFrame then
        hooksecurefunc(CompactPartyFrame, "Show", function(self)
            if settings and settings.party and settings.party.enabled then
                -- Skip during Edit Mode to prevent taint
                if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
                    return
                end
                C_Timer.After(0, function()
                    if not InCombatLockdown() then
                        UnitFrames.HideBlizzardPartyFrames()
                    end
                end)
            end
        end)
        
        -- Hook SetAlpha to keep it at 0
        hooksecurefunc(CompactPartyFrame, "SetAlpha", function(self, alpha)
            -- Use pcall to safely compare alpha (may be secret in Midnight)
            local isPositive = true
            pcall(function() isPositive = alpha > 0 end)
            if isPositive and settings and settings.party and settings.party.enabled then
                if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                    C_Timer.After(0, function()
                        if self and self.SetAlpha then
                            self:SetAlpha(0)
                        end
                    end)
                end
            end
        end)
    end
    
    -- Hook CompactPartyFrameMember1-5 frames
    for i = 1, 5 do
        local memberName = "CompactPartyFrameMember" .. i
        local member = _G[memberName]
        if member and not member._tuiHooked then
            hooksecurefunc(member, "Show", function(self)
                if settings and settings.party and settings.party.enabled then
                    if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                        self:SetAlpha(0)
                        if not InCombatLockdown() then
                            pcall(function() self:EnableMouse(false) end)
                        end
                    end
                end
            end)
            hooksecurefunc(member, "SetAlpha", function(self, alpha)
                -- Use pcall to safely compare alpha (may be secret in Midnight)
                local isPositive = true
                pcall(function() isPositive = alpha > 0 end)
                if isPositive and settings and settings.party and settings.party.enabled then
                    if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                self:SetAlpha(0)
                            end
                        end)
                    end
                end
            end)
            member._tuiHooked = true
            
            -- Hook SelectionHighlight
            local highlight = _G[memberName .. "SelectionHighlight"]
            if highlight and not highlight._tuiHooked then
                hooksecurefunc(highlight, "Show", function(self)
                    if settings and settings.party and settings.party.enabled then
                        self:SetAlpha(0)
                        self:Hide()
                    end
                end)
                hooksecurefunc(highlight, "SetAlpha", function(self, alpha)
                    -- Use pcall to safely compare alpha (may be secret in Midnight)
                    local isPositive = true
                    pcall(function() isPositive = alpha > 0 end)
                    if isPositive and settings and settings.party and settings.party.enabled then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                self:SetAlpha(0)
                            end
                        end)
                    end
                end)
                highlight._tuiHooked = true
            end
            
            -- Hook Background
            local bg = _G[memberName .. "Background"]
            if bg and not bg._tuiHooked then
                hooksecurefunc(bg, "Show", function(self)
                    if settings and settings.party and settings.party.enabled then
                        self:SetAlpha(0)
                        self:Hide()
                    end
                end)
                hooksecurefunc(bg, "SetAlpha", function(self, alpha)
                    -- Use pcall to safely compare alpha (may be secret in Midnight)
                    local isPositive = true
                    pcall(function() isPositive = alpha > 0 end)
                    if isPositive and settings and settings.party and settings.party.enabled then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                self:SetAlpha(0)
                            end
                        end)
                    end
                end)
                bg._tuiHooked = true
            end
        end
    end
end

-- Re-apply party frame hiding after combat ends and on group changes
local partyFrameRegenFrame = CreateFrame("Frame")
partyFrameRegenFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
partyFrameRegenFrame:RegisterEvent("GROUP_ROSTER_UPDATE")
partyFrameRegenFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
partyFrameRegenFrame:RegisterEvent("GROUP_FORMED")
partyFrameRegenFrame:RegisterEvent("GROUP_JOINED")
partyFrameRegenFrame:SetScript("OnEvent", function(self, event)
    if settings and settings.party and settings.party.enabled then
        -- Wait a moment for frames to be created/updated
        C_Timer.After(0.2, function()
            if not InCombatLockdown() then
                UnitFrames.HideBlizzardPartyFrames()
            end
        end)
    end
end)

-- ============================================================================
-- PARTY CONTAINER SYSTEM
-- ============================================================================

function UnitFrames:CreatePartyContainer()
    -- Skip if external addon handles party frames
    if self:IsPartyDisabledByExternalAddon() then
        TweaksUI:PrintDebug("Party container creation skipped - " .. (self:GetExternalPartyAddon() or "external addon") .. " is handling party frames")
        return nil
    end
    
    if partyContainer then 
        return partyContainer 
    end
    
    local ps = settings.party
    if not ps then 
        return 
    end
    
    local spacing = ps.container.spacing or 2
    local scale = ps.container.scale or 1.0
    local growthDirection = ps.container.growthDirection or "DOWN"
    
    -- Create main container
    partyContainer = CreateFrame("Frame", "TweaksUI_PartyContainer", UIParent)
    
    -- Set initial size based on growth direction
    if growthDirection == "DOWN" or growthDirection == "UP" then
        partyContainer:SetSize(ps.frame.width + 4, (ps.frame.height + spacing) * 5 + 4)
    else
        partyContainer:SetSize((ps.frame.width + spacing) * 5 + 4, ps.frame.height + 4)
    end
    
    -- No backdrop - Layout overlays provide visual feedback during positioning
    -- Container is invisible, member frames provide the visual
    
    -- Position from settings initially - Layout will take over when registered
    partyContainer:SetPoint(ps.container.anchor, UIParent, ps.container.anchor, ps.container.x, ps.container.y)
    partyContainer:SetScale(scale)
    partyContainer:SetMovable(true)
    partyContainer:SetClampedToScreen(true)
    
    -- Drag handling is done by Layout system now
    -- Keep EnableMouse false - Layout overlay handles interaction
    partyContainer:EnableMouse(false)
    
    -- Create member frames
    for i, unitData in ipairs(UnitFrames.PARTY_UNITS) do
        self:CreatePartyMemberFrame(i, unitData)
    end
    
    -- Hide Blizzard party frame completely
    UnitFrames.HideBlizzardPartyFrames()
    
    -- Register with Layout system
    -- Try immediately, then retry if Layout not ready yet
    local containerSettings = ps.container
    local wrapper = UnitFrames:RegisterContainerWithLayout("party", partyContainer, containerSettings)
    
    if not wrapper then
        -- Layout not ready yet, retry after a short delay
        C_Timer.After(0.2, function()
            if partyContainer and not containerWrappers["party"] then
                UnitFrames:RegisterContainerWithLayout("party", partyContainer, containerSettings)
            end
        end)
    end
    
    return partyContainer
end

function UnitFrames:CreatePartyMemberFrame(index, unit)
    local ps = settings.party
    local mf = ps.frame
    local spacing = ps.container.spacing or 2
    local growthDirection = ps.container.growthDirection or "DOWN"
    
    -- Create secure button for click interactions
    local frame = CreateFrame("Button", "TweaksUI_PartyMember" .. index, partyContainer, "SecureUnitButtonTemplate, BackdropTemplate")
    frame:SetSize(mf.width, mf.height)
    
    -- Position based on growth direction
    if growthDirection == "DOWN" then
        local yOffset = -2 - ((index - 1) * (mf.height + spacing))
        frame:SetPoint("TOPLEFT", partyContainer, "TOPLEFT", 2, yOffset)
    elseif growthDirection == "UP" then
        local yOffset = 2 + ((index - 1) * (mf.height + spacing))
        frame:SetPoint("BOTTOMLEFT", partyContainer, "BOTTOMLEFT", 2, yOffset)
    elseif growthDirection == "RIGHT" then
        local xOffset = 2 + ((index - 1) * (mf.width + spacing))
        frame:SetPoint("TOPLEFT", partyContainer, "TOPLEFT", xOffset, -2)
    elseif growthDirection == "LEFT" then
        local xOffset = -2 - ((index - 1) * (mf.width + spacing))
        frame:SetPoint("TOPRIGHT", partyContainer, "TOPRIGHT", xOffset, -2)
    end
    
    -- Set unit attribute for secure clicking
    frame:SetAttribute("unit", unit)
    frame:SetAttribute("type1", "target")  -- Left click targets
    frame:SetAttribute("type2", "togglemenu")  -- Right click opens menu
    
    -- Register for clicks
    frame:RegisterForClicks("AnyUp")
    
    -- Background
    if mf.showBackground then
        frame:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8x8",
            edgeFile = mf.showBorder and "Interface\\Buttons\\WHITE8x8" or nil,
            edgeSize = mf.borderSize,
        })
        frame:SetBackdropColor(mf.bgColor[1], mf.bgColor[2], mf.bgColor[3], mf.bgColor[4])
        if mf.showBorder then
            frame:SetBackdropBorderColor(mf.borderColor[1], mf.borderColor[2], mf.borderColor[3], mf.borderColor[4])
        end
    end
    
    -- Health bar
    local healthBar = CreateFrame("StatusBar", nil, frame)
    healthBar:SetPoint("TOPLEFT", 2, -2)
    healthBar:SetPoint("TOPRIGHT", -2, -2)
    healthBar:SetHeight(ps.healthBar.height)
    healthBar:SetStatusBarTexture(GetTexturePath(ps.healthBar.texture))
    healthBar:SetStatusBarColor(0.2, 0.8, 0.2)  -- Default green color
    -- Apply bar masking
    if TweaksUI.BarMasking and ps.healthBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(healthBar, ps.healthBar.maskShape)
    end
    -- Min/max will be set by UpdatePartyMemberFrame with actual health values
    frame.healthBar = healthBar
    
    -- Health bar background
    local healthBg = healthBar:CreateTexture(nil, "BACKGROUND")
    healthBg:SetAllPoints()
    healthBg:SetColorTexture(0.1, 0.1, 0.1, 0.8)
    
    -- Power bar
    local powerBar = CreateFrame("StatusBar", nil, frame)
    powerBar:SetPoint("TOPLEFT", healthBar, "BOTTOMLEFT", 0, -1)
    powerBar:SetPoint("TOPRIGHT", healthBar, "BOTTOMRIGHT", 0, -1)
    powerBar:SetHeight(ps.powerBar.height)
    powerBar:SetStatusBarTexture(GetTexturePath(ps.powerBar.texture))
    powerBar:SetStatusBarColor(0.2, 0.2, 0.8)  -- Default blue color
    -- Apply bar masking
    if TweaksUI.BarMasking and ps.powerBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(powerBar, ps.powerBar.maskShape)
    end
    -- Min/max will be set by UpdatePartyMemberFrame with actual power values
    frame.powerBar = powerBar
    
    -- Power bar background
    local powerBg = powerBar:CreateTexture(nil, "BACKGROUND")
    powerBg:SetAllPoints()
    powerBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
    
    -- Portrait frame (similar to solo frames)
    local portraitFrame = CreateFrame("Frame", "TweaksUI_PartyMember" .. index .. "_Portrait", frame)
    portraitFrame:SetFrameLevel(frame:GetFrameLevel() + 2)
    
    -- 3D Portrait (PlayerModel)
    local portrait3D = CreateFrame("PlayerModel", "TweaksUI_PartyMember" .. index .. "_Portrait3D", portraitFrame)
    portrait3D:SetAllPoints()
    
    -- 2D Portrait texture
    local portrait2D = portraitFrame:CreateTexture(nil, "ARTWORK")
    portrait2D:SetAllPoints()
    
    -- Class icon texture
    local classIcon = portraitFrame:CreateTexture(nil, "ARTWORK")
    classIcon:SetAllPoints()
    
    -- Portrait background
    local portraitBg = portraitFrame:CreateTexture(nil, "BACKGROUND")
    portraitBg:SetAllPoints()
    portraitBg:SetColorTexture(0, 0, 0, 0.8)
    portraitFrame.bg = portraitBg
    
    frame.portraitFrame = portraitFrame
    frame.portrait3D = portrait3D
    frame.portrait2D = portrait2D
    frame.classIcon = classIcon
    portraitFrame:Hide()  -- Hidden by default, shown if enabled in settings
    
    -- Name text
    local nameText = healthBar:CreateFontString(nil, "OVERLAY")
    nameText:SetFont(GetFontPath(DEFAULT_FONT), ps.nameText.fontSize, GetFontOutline(ps.nameText.fontOutline))
    nameText:SetPoint("LEFT", healthBar, "LEFT", 4, 0)
    nameText:SetJustifyH("LEFT")
    frame.nameText = nameText
    
    -- Health text
    local healthText = healthBar:CreateFontString(nil, "OVERLAY")
    healthText:SetFont(GetFontPath(DEFAULT_FONT), ps.healthText.fontSize, GetFontOutline(ps.healthText.fontOutline))
    healthText:SetPoint("RIGHT", healthBar, "RIGHT", -4, 0)
    healthText:SetJustifyH("RIGHT")
    frame.healthText = healthText
    
    -- Role icon - use a frame container for proper z-ordering
    local roleIconFrame = CreateFrame("Frame", nil, frame)
    roleIconFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
    local riSize = ps.roleIcon.size or 16
    roleIconFrame:SetSize(riSize, riSize)
    local riAnchor = ps.roleIcon.anchor or "CENTER"
    local riFrameAnchor = ps.roleIcon.frameAnchor or "TOPLEFT"
    local riOffsetX = ps.roleIcon.offsetX or 2
    local riOffsetY = ps.roleIcon.offsetY or -2
    roleIconFrame:SetPoint(riAnchor, frame, riFrameAnchor, riOffsetX, riOffsetY)
    
    local roleIcon = roleIconFrame:CreateTexture(nil, "OVERLAY", nil, 7)
    roleIcon:SetAllPoints()
    -- Texture will be set via SetAtlas in UpdatePartyMemberFrame
    roleIconFrame:Hide()
    frame.roleIcon = roleIcon
    frame.roleIconFrame = roleIconFrame
    
    -- Raid target icon - use a frame container for proper z-ordering
    local raidTargetFrame = CreateFrame("Frame", nil, frame)
    raidTargetFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
    local rtSize = ps.raidTarget.size or 18
    raidTargetFrame:SetSize(rtSize, rtSize)
    local rtAnchor = ps.raidTarget.anchor or "CENTER"
    local rtFrameAnchor = ps.raidTarget.frameAnchor or "TOP"
    local rtOffsetX = ps.raidTarget.offsetX or 0
    local rtOffsetY = ps.raidTarget.offsetY or -2
    raidTargetFrame:SetPoint(rtAnchor, frame, rtFrameAnchor, rtOffsetX, rtOffsetY)
    
    local raidTarget = raidTargetFrame:CreateTexture(nil, "OVERLAY", nil, 7)
    raidTarget:SetAllPoints()
    raidTarget:SetTexture("Interface\\TargetingFrame\\UI-RaidTargetingIcons")
    raidTargetFrame:Hide()
    frame.raidTarget = raidTarget
    frame.raidTargetFrame = raidTargetFrame
    
    -- Cast Bar (always create, visibility controlled by enabled setting)
    -- Ensure castBar settings exist
    if not ps.castBar then
        ps.castBar = {
            enabled = false,
            height = 8,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
        }
    end
    local cbHeight = ps.castBar.height or 8
    local castBar = CreateFrame("StatusBar", nil, frame)
    castBar:SetStatusBarTexture(GetTexturePath(ps.castBar.texture))
    castBar:SetStatusBarColor(1, 0.7, 0, 1)
    castBar:SetHeight(cbHeight)
    castBar:SetPoint("TOPLEFT", frame, "BOTTOMLEFT", 1, -1)
    castBar:SetPoint("TOPRIGHT", frame, "BOTTOMRIGHT", -1, -1)
    castBar:SetMinMaxValues(0, 1)
    castBar:SetValue(0)
    castBar:Hide()
    frame.castBar = castBar
    
    local castBg = castBar:CreateTexture(nil, "BACKGROUND")
    castBg:SetAllPoints()
    castBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
    
    -- Always create text/icon/timer elements
    local castText = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    castText:SetPoint("LEFT", castBar, "LEFT", cbHeight + 2, 0)
    frame.castText = castText
    
    local castIcon = castBar:CreateTexture(nil, "OVERLAY")
    castIcon:SetSize(cbHeight, cbHeight)
    castIcon:SetPoint("LEFT", castBar, "LEFT", 1, 0)
    frame.castIcon = castIcon
    
    local castTimer = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    castTimer:SetPoint("RIGHT", castBar, "RIGHT", -2, 0)
    frame.castTimer = castTimer
    
    -- Debuff indicator container - use higher frame level
    local debuffContainer = CreateFrame("Frame", nil, frame)
    debuffContainer:SetFrameLevel(frame:GetFrameLevel() + 10)
    local diSize = ps.debuffIndicators.size or 14
    local diStyle = ps.debuffIndicators.style or "squares"
    debuffContainer:SetSize(diSize * 4, diSize)
    local diPosition = ps.debuffIndicators.position or "BOTTOMRIGHT"
    local diOffsetX = ps.debuffIndicators.offsetX or -2
    local diOffsetY = ps.debuffIndicators.offsetY or 2
    debuffContainer:SetPoint(diPosition, frame, diPosition, diOffsetX, diOffsetY)
    frame.debuffContainer = debuffContainer
    
    -- Debuff type colors (same as solo frames)
    local LOCAL_DEBUFF_COLORS = {
        Magic = {0.2, 0.6, 1.0, 1},     -- Blue
        Curse = {0.6, 0.0, 1.0, 1},     -- Purple
        Disease = {0.6, 0.4, 0.0, 1},   -- Brown
        Poison = {0.0, 0.6, 0.0, 1},    -- Green
    }
    
    -- Create debuff indicator icons with style support
    frame.debuffIndicators = {}
    local debuffTypes = {"Magic", "Curse", "Disease", "Poison"}
    for j, debuffType in ipairs(debuffTypes) do
        local indicator = CreateFrame("Frame", nil, debuffContainer, "BackdropTemplate")
        indicator:SetSize(diSize, diSize)
        indicator:SetPoint("RIGHT", debuffContainer, "RIGHT", -((j-1) * (diSize + 1)), 0)
        indicator:SetFrameLevel(debuffContainer:GetFrameLevel() + 1)
        
        local color = LOCAL_DEBUFF_COLORS[debuffType]
        indicator.color = color
        indicator.debuffType = debuffType
        
        -- Create colored square (for "squares" and fallback mode)
        indicator.square = indicator:CreateTexture(nil, "BACKGROUND")
        indicator.square:SetAllPoints()
        indicator.square:SetColorTexture(color[1], color[2], color[3], 1)
        
        -- Create Blizzard-style icon (for "icons" and "both" modes)
        indicator.icon = indicator:CreateTexture(nil, "ARTWORK")
        indicator.icon:SetAllPoints()
        indicator.icon:SetTexCoord(0.08, 0.92, 0.08, 0.92)  -- Slight inset for cleaner look
        
        -- Try to set atlas first, fallback to texture path
        local atlasSet = false
        if Constants.DEBUFF_TYPE_ATLASES and Constants.DEBUFF_TYPE_ATLASES[debuffType] then
            local success = pcall(function()
                indicator.icon:SetAtlas(Constants.DEBUFF_TYPE_ATLASES[debuffType])
            end)
            if success then atlasSet = true end
        end
        if not atlasSet and Constants.DEBUFF_TYPE_TEXTURES and Constants.DEBUFF_TYPE_TEXTURES[debuffType] then
            indicator.icon:SetTexture(Constants.DEBUFF_TYPE_TEXTURES[debuffType])
        end
        
        -- Set initial style
        UpdateDebuffIndicatorStyle(indicator, diStyle, diSize)
        
        indicator:Hide()
        frame.debuffIndicators[debuffType] = indicator
    end
    
    -- ========================================================================
    -- LEADER INDICATOR for party frames
    -- ========================================================================
    frame.leaderFrame = CreateFrame("Frame", nil, frame)
    frame.leaderFrame:SetFrameLevel(frame:GetFrameLevel() + 20)
    frame.leaderFrame:SetSize(16, 16)
    
    frame.leaderIndicator = frame.leaderFrame:CreateTexture(nil, "OVERLAY")
    frame.leaderIndicator:SetAllPoints()
    frame.leaderIndicator:SetTexture("Interface\\GroupFrame\\UI-Group-LeaderIcon")
    frame.leaderIndicator:Hide()
    
    -- ========================================================================
    -- SUMMON INDICATOR for party frames
    -- Shows pending/accepted summon status
    -- ========================================================================
    local frameName = "TweaksUI_PartyFrame" .. index
    
    frame.summonFrame = CreateFrame("Frame", frameName .. "_SummonIndicator", frame)
    frame.summonFrame:SetFrameStrata("HIGH")
    frame.summonFrame:SetFrameLevel(100)
    frame.summonFrame:SetSize(20, 20)
    frame.summonFrame:Hide()
    
    frame.summonIndicator = frame.summonFrame:CreateTexture(nil, "OVERLAY")
    frame.summonIndicator:SetAllPoints()
    frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonPending")
    
    -- ========================================================================
    -- MOUSEOVER HIGHLIGHT for party frames (Universal from general settings)
    -- Two styles: overlay, border
    -- ========================================================================
    
    -- Overlay style (HIGH strata frame with color fill)
    frame.mouseoverOverlayFrame = CreateFrame("Frame", frameName .. "_MouseoverOverlay", frame)
    frame.mouseoverOverlayFrame:SetFrameStrata("HIGH")
    frame.mouseoverOverlayFrame:SetFrameLevel(100)
    frame.mouseoverOverlayFrame:SetAllPoints()
    frame.mouseoverOverlay = frame.mouseoverOverlayFrame:CreateTexture(nil, "OVERLAY")
    frame.mouseoverOverlay:SetAllPoints()
    frame.mouseoverOverlay:SetColorTexture(1, 1, 1, 0.15)
    frame.mouseoverOverlayFrame:Hide()
    
    -- Border style (solid border)
    frame.mouseoverBorder = CreateFrame("Frame", frameName .. "_MouseoverBorder", frame, "BackdropTemplate")
    frame.mouseoverBorder:SetFrameLevel(frame:GetFrameLevel() + 2)
    frame.mouseoverBorder:SetPoint("TOPLEFT", frame, "TOPLEFT", -2, 2)
    frame.mouseoverBorder:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", 2, -2)
    frame.mouseoverBorder:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 2,
    })
    frame.mouseoverBorder:SetBackdropBorderColor(1, 1, 1, 1)
    frame.mouseoverBorder:Hide()
    
    -- ========================================================================
    -- BUFF/DEBUFF AURA ICONS (same approach as target frames)
    -- ========================================================================
    
    -- Helper to create a single aura icon
    local function CreatePartyAuraIcon(parent, iconIndex)
        local icon = CreateFrame("Frame", nil, parent, "BackdropTemplate")
        icon:SetFrameLevel(parent:GetFrameLevel() + 1)
        icon:EnableMouse(true)
        
        icon.texture = icon:CreateTexture(nil, "ARTWORK")
        icon.texture:SetAllPoints()
        icon.texture:SetTexCoord(0.08, 0.92, 0.08, 0.92)
        
        icon.cooldown = CreateFrame("Cooldown", nil, icon, "CooldownFrameTemplate")
        icon.cooldown:SetAllPoints()
        icon.cooldown:SetDrawEdge(false)
        icon.cooldown:SetDrawBling(false)
        icon.cooldown:SetDrawSwipe(true)
        icon.cooldown:SetReverse(true)
        icon.cooldown:SetHideCountdownNumbers(false)  -- Use Blizzard's built-in text (works with secret values)
        
        icon.border = icon:CreateTexture(nil, "OVERLAY")
        icon.border:SetPoint("TOPLEFT", -1, 1)
        icon.border:SetPoint("BOTTOMRIGHT", 1, -1)
        icon.border:SetTexture("Interface\\Buttons\\UI-Debuff-Overlays")
        icon.border:SetTexCoord(0.296875, 0.5703125, 0, 0.515625)
        icon.border:Hide()
        
        icon.textOverlay = CreateFrame("Frame", nil, icon)
        icon.textOverlay:SetAllPoints()
        icon.textOverlay:SetFrameLevel(icon:GetFrameLevel() + 10)
        
        icon.stackText = icon.textOverlay:CreateFontString(nil, "OVERLAY")
        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
        icon.stackText:SetPoint("BOTTOMRIGHT", 0, 0)
        icon.stackText:SetTextColor(1, 1, 1, 1)
        
        -- Duration text (no longer used - Blizzard's CooldownFrameTemplate handles it)
        icon.durationText = icon.textOverlay:CreateFontString(nil, "OVERLAY")
        icon.durationText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
        icon.durationText:SetPoint("CENTER", 0, 0)
        icon.durationText:SetTextColor(1, 1, 0.6, 1)
        icon.durationText:Hide()  -- Blizzard's cooldown handles duration text now
        
        icon.index = iconIndex
        icon.auraInstanceID = nil
        
        -- Tooltip
        icon:SetScript("OnEnter", function(self)
            if self.auraInstanceID and parent.unit then
                GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
                pcall(function()
                    if parent.isBuff then
                        if GameTooltip.SetUnitBuffByAuraInstanceID then
                            GameTooltip:SetUnitBuffByAuraInstanceID(parent.unit, self.auraInstanceID)
                        end
                    else
                        if GameTooltip.SetUnitDebuffByAuraInstanceID then
                            GameTooltip:SetUnitDebuffByAuraInstanceID(parent.unit, self.auraInstanceID)
                        end
                    end
                end)
                GameTooltip:Show()
            end
        end)
        icon:SetScript("OnLeave", function() GameTooltip:Hide() end)
        
        icon:Hide()
        return icon
    end
    
    -- Buffs container
    frame.buffsContainer = CreateFrame("Frame", frameName .. "_Buffs", frame)
    frame.buffsContainer:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.buffsContainer:SetSize(100, 20)
    frame.buffsContainer.unit = unit
    frame.buffsContainer.icons = {}
    frame.buffsContainer.isBuff = true
    for i = 1, 8 do
        frame.buffsContainer.icons[i] = CreatePartyAuraIcon(frame.buffsContainer, i)
    end
    
    -- Debuffs container
    frame.debuffsContainer = CreateFrame("Frame", frameName .. "_Debuffs", frame)
    frame.debuffsContainer:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.debuffsContainer:SetSize(100, 20)
    frame.debuffsContainer.unit = unit
    frame.debuffsContainer.icons = {}
    frame.debuffsContainer.isBuff = false
    for i = 1, 8 do
        frame.debuffsContainer.icons[i] = CreatePartyAuraIcon(frame.debuffsContainer, i)
    end
    
    -- ========================================================================
    -- TARGET HIGHLIGHT for party frames (Border style)
    -- ========================================================================
    frame.targetHighlight = CreateFrame("Frame", frameName .. "_TargetHighlight", frame, "BackdropTemplate")
    frame.targetHighlight:SetFrameLevel(frame:GetFrameLevel() + 3)
    frame.targetHighlight:SetPoint("TOPLEFT", frame, "TOPLEFT", -2, 2)
    frame.targetHighlight:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", 2, -2)
    frame.targetHighlight:SetBackdrop({
        edgeFile = "Interface\\Buttons\\WHITE8X8",
        edgeSize = 2,
    })
    frame.targetHighlight:SetBackdropBorderColor(1, 1, 1, 1)
    frame.targetHighlight:Hide()
    
    -- Target Highlight Glow (alternative style)
    frame.targetHighlightGlow = frame:CreateTexture(nil, "BACKGROUND", nil, -8)
    frame.targetHighlightGlow:SetPoint("TOPLEFT", frame, "TOPLEFT", -4, 4)
    frame.targetHighlightGlow:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", 4, -4)
    frame.targetHighlightGlow:SetTexture("Interface\\Buttons\\UI-ActionButton-Border")
    frame.targetHighlightGlow:SetBlendMode("ADD")
    frame.targetHighlightGlow:SetVertexColor(1, 1, 1, 0.6)
    frame.targetHighlightGlow:Hide()
    
    -- Store unit reference
    frame.unit = unit
    frame.index = index
    
    -- Tooltip - custom tooltip to avoid secret value errors with SetUnit
    frame:SetScript("OnEnter", function(self)
        local showTooltip = false
        GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
        
        local TestMode = TweaksUI.UnitFramesTestMode
        local isTestMode = (previewParty or (TestMode and TestMode:IsActive()))
        if isTestMode and not UnitExists(self.unit) then
            local simData = SIMULATED_PARTY[self.index]
            if simData then
                local classColor = RAID_CLASS_COLORS[simData.class]
                if classColor then
                    GameTooltip:AddLine(simData.name, classColor.r, classColor.g, classColor.b)
                else
                    GameTooltip:AddLine(simData.name, 1, 1, 1)
                end
                GameTooltip:AddLine("Level 80 " .. simData.class, 0.7, 0.7, 0.7)
                if simData.role and simData.role ~= "NONE" then
                    GameTooltip:AddLine(simData.role, 0.5, 0.5, 0.5)
                end
                showTooltip = true
            end
        elseif UnitExists(self.unit) then
            -- Build custom tooltip to avoid secret value issues
            local name = UnitName(self.unit) or "Unknown"
            local _, class = UnitClass(self.unit)
            local level = UnitLevel(self.unit) or "??"
            local role = UnitGroupRolesAssigned(self.unit)
            
            local classColor = class and RAID_CLASS_COLORS[class]
            if classColor then
                GameTooltip:AddLine(name, classColor.r, classColor.g, classColor.b)
            else
                GameTooltip:AddLine(name, 1, 1, 1)
            end
            
            local classDisplayName = class and UnitClass(self.unit) or "Unknown"
            GameTooltip:AddLine("Level " .. level .. " " .. classDisplayName, 0.7, 0.7, 0.7)
            
            if role and role ~= "NONE" then
                local roleNames = {TANK = "Tank", HEALER = "Healer", DAMAGER = "Damage"}
                GameTooltip:AddLine(roleNames[role] or role, 0.5, 0.5, 0.5)
            end
            showTooltip = true
        end
        
        if showTooltip then
            GameTooltip:Show()
        end
        
        -- Handle mouseover highlight for overlay and border styles
        local mhSettings = settings and settings.general and settings.general.mouseoverHighlight
        if mhSettings and mhSettings.enabled then
            if mhSettings.style == "overlay" and self.mouseoverOverlayFrame then
                self.mouseoverOverlayFrame:Show()
            elseif mhSettings.style == "border" and self.mouseoverBorder then
                self.mouseoverBorder:Show()
            end
        end
    end)
    frame:SetScript("OnLeave", function(self)
        GameTooltip:Hide()
        -- Hide mouseover highlights
        if self.mouseoverOverlayFrame then self.mouseoverOverlayFrame:Hide() end
        if self.mouseoverBorder then self.mouseoverBorder:Hide() end
    end)
    
    partyMemberFrames[index] = frame
    return frame
end

function UnitFrames:UpdatePartyMemberFrame(index)
    local frame = partyMemberFrames[index]
    if not frame then return end
    
    local ps = settings.party
    if not ps then return end
    
    local unit = frame.unit
    local TestMode = TweaksUI.UnitFramesTestMode
    local isTestMode = (previewParty or (TestMode and TestMode:IsActive()))
    local simData = isTestMode and SIMULATED_PARTY[index] or nil
    local unitExists = UnitExists(unit) or (isTestMode and simData)
    
    -- For player slot, always show if in a group or simulating
    if unit == "player" then
        unitExists = IsInGroup() or isTestMode
    end
    
    if not unitExists then
        -- Only hide outside of combat (secure frame restriction)
        if not InCombatLockdown() then
            frame:Hide()
        end
        return
    end
    
    -- Only show outside of combat (secure frame restriction)
    if not InCombatLockdown() then
        frame:Show()
    end
    
    -- Get unit data - only non-secret values stored
    local name, class, role, powerType
    local healthPercent = 100  -- Default for simulation
    
    if isTestMode and simData then
        -- Use simulated data in simulation mode
        powerType = simData.powerType or 0
        name = simData.name or "Unknown"
        class = simData.class or "WARRIOR"
        role = simData.role or "NONE"
        -- Calculate percent for simulation (safe - not secret values)
        if simData.maxHealth and simData.maxHealth > 0 then
            healthPercent = (simData.health / simData.maxHealth) * 100
        end
    elseif UnitExists(unit) then
        powerType = UnitPowerType(unit) or 0
        name = UnitName(unit) or "Unknown"
        _, class = UnitClass(unit)
        class = class or "WARRIOR"
        role = UnitGroupRolesAssigned(unit) or "NONE"
        
        -- Use SafeUnitHealthPercent which handles CurveConstants.ScaleTo100
        local pct = SafeUnitHealthPercent(unit, true) or SafeUnitHealthPercent(unit, false)
        if pct then
            healthPercent = pct
        end
    else
        -- Unit doesn't exist - hide frame (only outside combat)
        if not InCombatLockdown() then
            frame:Hide()
        end
        return
    end
    
    -- Update frame size from settings (only outside combat - secure frame restriction)
    local mf = ps.frame
    if mf and not InCombatLockdown() then
        frame:SetSize(mf.width, mf.height)
    end
    
    -- Calculate portrait offset for bar positioning
    local portraitOffset = 0
    local pps = ps.portrait
    if pps and pps.enabled and frame.portraitFrame then
        local portraitSize = pps.size or 32
        local portraitPosition = pps.position or "left"
        if portraitPosition == "left" and not pps.outside then
            portraitOffset = portraitSize + 2
        end
    end
    
    -- Update health bar size and position
    if frame.healthBar and ps.healthBar then
        frame.healthBar:SetHeight(ps.healthBar.height or 20)
        frame.healthBar:ClearAllPoints()
        frame.healthBar:SetPoint("TOPLEFT", frame, "TOPLEFT", 2 + portraitOffset, -2)
        frame.healthBar:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -2, -2)
        
        -- Update texture from settings
        local texturePath = GetTexturePath(ps.healthBar.texture)
        frame.healthBar:SetStatusBarTexture(texturePath)
        
        -- Apply bar masking
        if TweaksUI.BarMasking and ps.healthBar.maskShape then
            TweaksUI.BarMasking:ApplyToStatusBar(frame.healthBar, ps.healthBar.maskShape)
        end
    end
    
    -- Update power bar size and position
    if frame.powerBar and ps.powerBar then
        frame.powerBar:SetHeight(ps.powerBar.height or 6)
        frame.powerBar:ClearAllPoints()
        frame.powerBar:SetPoint("TOPLEFT", frame.healthBar, "BOTTOMLEFT", 0, -1)
        frame.powerBar:SetPoint("TOPRIGHT", frame.healthBar, "BOTTOMRIGHT", 0, -1)
        
        -- Update texture from settings
        local texturePath = GetTexturePath(ps.powerBar.texture)
        frame.powerBar:SetStatusBarTexture(texturePath)
        
        -- Apply bar masking
        if TweaksUI.BarMasking and ps.powerBar.maskShape then
            TweaksUI.BarMasking:ApplyToStatusBar(frame.powerBar, ps.powerBar.maskShape)
        end
    end
    
    -- Update health bar - use percent-based approach for Midnight secret value compatibility
    -- Just pass the value straight through - StatusBar handles secrets natively
    frame.healthBar:SetMinMaxValues(0, 100)
    local healthPct
    if isTestMode and simData then
        -- Simulation mode - calculate percent from simulated values
        healthPct = (simData.maxHealth > 0) and ((simData.health / simData.maxHealth) * 100) or 100
    else
        -- Use SafeUnitHealthPercent for Midnight compatibility
        healthPct = SafeUnitHealthPercent(unit, true) or 100
    end
    -- Use smooth animation if available (Midnight Beta 3+)
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    -- Health bar color - use class color (no arithmetic needed)
    if ps.healthBar and ps.healthBar.colorMode == "class" and class then
        local color = RAID_CLASS_COLORS[class]
        if color then
            frame.healthBar:SetStatusBarColor(color.r, color.g, color.b)
        else
            frame.healthBar:SetStatusBarColor(0.5, 0.5, 0.5)
        end
    else
        -- Default green if not class-colored
        frame.healthBar:SetStatusBarColor(0, 0.8, 0)
    end
    
    -- Update power bar - pass values directly to StatusBar
    local power, maxPower
    if isTestMode and simData then
        power = simData.power
        maxPower = simData.maxPower
    else
        power = UnitPower(unit)
        maxPower = UnitPowerMax(unit)
    end
    frame.powerBar:SetMinMaxValues(0, maxPower)
    -- Use smooth animation if available (Midnight Beta 3+)
    SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
    
    -- Power bar color
    local powerColor = PowerBarColor and PowerBarColor[powerType]
    if powerColor then
        frame.powerBar:SetStatusBarColor(powerColor.r, powerColor.g, powerColor.b)
    else
        frame.powerBar:SetStatusBarColor(0.2, 0.2, 0.8)
    end
    
    -- Update name text with dynamic settings
    if frame.nameText then
        local ns = ps.nameText
        if ns and ns.enabled then
            -- Update font
            local fontSize = ns.fontSize or 10
            local fontOutline = ns.fontOutline or "OUTLINE"
            frame.nameText:SetFont(GetFontPath(DEFAULT_FONT), fontSize, GetFontOutline(fontOutline))
            
            -- Update position using simplified anchor system
            frame.nameText:ClearAllPoints()
            local anchor = ns.anchor or ns.frameAnchor or "LEFT"
            local offsetX = ns.offsetX or 4
            local offsetY = ns.offsetY or 0
            if ns.anchorToHealthBar then
                frame.nameText:SetPoint(anchor, frame.healthBar, anchor, offsetX, offsetY)
            else
                frame.nameText:SetPoint(anchor, frame, anchor, offsetX, offsetY)
            end
            
            -- Derive horizontal alignment from anchor point
            local hAlign = "CENTER"
            if anchor == "LEFT" or anchor == "TOPLEFT" or anchor == "BOTTOMLEFT" then
                hAlign = "LEFT"
            elseif anchor == "RIGHT" or anchor == "TOPRIGHT" or anchor == "BOTTOMRIGHT" then
                hAlign = "RIGHT"
            end
            frame.nameText:SetJustifyH(hAlign)
            
            -- Set text
            frame.nameText:SetText(name or "")
            
            -- Set color
            if ns.colorMode == "class" and class then
                local color = RAID_CLASS_COLORS[class]
                if color then
                    frame.nameText:SetTextColor(color.r, color.g, color.b)
                else
                    frame.nameText:SetTextColor(1, 1, 1)
                end
            elseif ns.customColor then
                frame.nameText:SetTextColor(ns.customColor[1] or 1, ns.customColor[2] or 1, ns.customColor[3] or 1, ns.customColor[4] or 1)
            else
                frame.nameText:SetTextColor(1, 1, 1)
            end
            frame.nameText:Show()
        else
            frame.nameText:Hide()
        end
    end
    
    -- Update health text with proper formatting
    if frame.healthText then
        local hs = ps.healthText
        if hs and hs.enabled then
            -- Update font
            local fontSize = hs.fontSize or 10
            local fontOutline = hs.fontOutline or "OUTLINE"
            frame.healthText:SetFont(GetFontPath(DEFAULT_FONT), fontSize, GetFontOutline(fontOutline))
            
            -- Update position
            frame.healthText:ClearAllPoints()
            local anchor = hs.hAlign or "RIGHT"
            local offsetX = hs.offsetX or -4
            local offsetY = hs.offsetY or 0
            frame.healthText:SetPoint(anchor, frame.healthBar, anchor, offsetX, offsetY)
            frame.healthText:SetJustifyH(anchor)
            
            -- Format health text based on settings
            local format = hs.format or "percent"
            local healthStr = ""
            
            if UnitIsDeadOrGhost(unit) and not isTestMode then
                healthStr = "Dead"
            else
                -- Helper to safely format health values
                -- Respects the abbreviate setting
                local function SafeFormatNumber(value)
                    if value == nil then return "" end
                    local success, result = pcall(function()
                        if hs.abbreviate ~= false then  -- Default to true if not set
                            return AbbreviateLargeNumbers(value) or ""
                        else
                            return BreakUpLargeNumbers(value) or ""
                        end
                    end)
                    return success and result or ""
                end
                
                if format == "percent" then
                    healthStr = string.format("%.0f%%", healthPercent or 0)
                elseif format == "current" then
                    if isTestMode and simData then
                        healthStr = hs.abbreviate ~= false and AbbreviateNumber(simData.health) or FormatNumber(simData.health)
                    else
                        healthStr = SafeFormatNumber(UnitHealth(unit))
                    end
                elseif format == "both" or format == "current_percent" then
                    local currentStr
                    if isTestMode and simData then
                        currentStr = hs.abbreviate ~= false and AbbreviateNumber(simData.health) or FormatNumber(simData.health)
                    else
                        currentStr = SafeFormatNumber(UnitHealth(unit))
                    end
                    healthStr = currentStr .. " | " .. string.format("%.0f%%", healthPercent or 0)
                elseif format == "deficit" then
                    if isTestMode and simData then
                        local deficit = (simData.maxHealth or 0) - (simData.health or 0)
                        if deficit > 0 then
                            healthStr = "-" .. (hs.abbreviate ~= false and AbbreviateNumber(deficit) or FormatNumber(deficit))
                        end
                    elseif HAS_HEALTH_MISSING then
                        local missing = UnitHealthMissing(unit)
                        healthStr = "-" .. SafeFormatNumber(missing)
                    else
                        healthStr = SafeFormatNumber(UnitHealth(unit))
                    end
                elseif format == "deficit_percent" then
                    if healthPercent < 100 then
                        healthStr = string.format("-%.0f%%", 100 - healthPercent)
                    end
                else
                    -- Default to percent
                    healthStr = string.format("%.0f%%", healthPercent or 0)
                end
            end
            
            frame.healthText:SetText(healthStr)
            
            -- Set color based on health percentage - requires arithmetic
            if hs.colorByHealth then
                if isTestMode and simData then
                    local pct = healthPercent / 100
                    frame.healthText:SetTextColor(1 - pct, pct, 0)
                else
                    -- For real units, try using Midnight color curve
                    local r, g, b = GetHealthGradientColorMidnight(unit, nil)
                    frame.healthText:SetTextColor(r, g, b)
                end
            else
                frame.healthText:SetTextColor(1, 1, 1)
            end
            
            frame.healthText:Show()
        else
            frame.healthText:Hide()
        end
    end
    
    -- Update role icon using Blizzard's atlas system (most reliable method)
    if ps.roleIcon and ps.roleIcon.enabled and role and role ~= "NONE" then
        -- Dynamically update size and position from settings
        local riSize = ps.roleIcon.size or 16
        local riAnchor = ps.roleIcon.anchor or "CENTER"
        local riFrameAnchor = ps.roleIcon.frameAnchor or "TOPLEFT"
        local riOffsetX = ps.roleIcon.offsetX or 2
        local riOffsetY = ps.roleIcon.offsetY or -2
        
        if frame.roleIconFrame then
            frame.roleIconFrame:SetSize(riSize, riSize)
            frame.roleIconFrame:ClearAllPoints()
            frame.roleIconFrame:SetPoint(riAnchor, frame, riFrameAnchor, riOffsetX, riOffsetY)
        end
        
        -- Try multiple atlas names in order of preference
        local atlasOptions = {
            TANK = {
                "groupfinder-icon-role-large-tank",
                "roleicon-tank",
            },
            HEALER = {
                "groupfinder-icon-role-large-heal",
                "groupfinder-icon-role-large-healer",
                "roleicon-healer",
                "roleicon-heal",
            },
            DAMAGER = {
                "groupfinder-icon-role-large-dps",
                "groupfinder-icon-role-large-damage",
                "roleicon-dps",
            },
        }
        
        local options = atlasOptions[role]
        local atlasSet = false
        
        if options then
            for _, atlasName in ipairs(options) do
                local success = pcall(function()
                    frame.roleIcon:SetAtlas(atlasName, true)
                end)
                -- Check if atlas was actually set (GetAtlas returns the name if successful)
                if success then
                    local currentAtlas = frame.roleIcon:GetAtlas()
                    if currentAtlas and currentAtlas ~= "" then
                        atlasSet = true
                        break
                    end
                end
            end
        end
        
        if atlasSet then
            frame.roleIcon:Show()
            if frame.roleIconFrame then frame.roleIconFrame:Show() end
        else
            frame.roleIcon:Hide()
            if frame.roleIconFrame then frame.roleIconFrame:Hide() end
        end
    else
        if frame.roleIcon then frame.roleIcon:Hide() end
        if frame.roleIconFrame then frame.roleIconFrame:Hide() end
    end
    
    -- Update portrait
    if frame.portraitFrame then
        local pps = ps.portrait
        if pps and pps.enabled then
            local portraitSize = pps.size or 32
            local portraitPosition = pps.position or "left"
            local portraitOffsetX = pps.offsetX or 0
            local portraitOffsetY = pps.offsetY or 0
            
            -- Position and size portrait
            frame.portraitFrame:SetSize(portraitSize, portraitSize)
            frame.portraitFrame:ClearAllPoints()
            if portraitPosition == "left" then
                frame.portraitFrame:SetPoint("TOPLEFT", frame, "TOPLEFT", 2 + portraitOffsetX, -2 + portraitOffsetY)
            else
                frame.portraitFrame:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -2 + portraitOffsetX, -2 + portraitOffsetY)
            end
            
            -- Show appropriate portrait type
            frame.portrait3D:Hide()
            frame.portrait2D:Hide()
            frame.classIcon:Hide()
            
            local portraitMode = string.lower(pps.mode or "3d")
            
            if isTestMode and not UnitExists(unit) then
                -- Simulation mode - use class icon
                local simData = SIMULATED_PARTY[frame.index]
                if simData and simData.class then
                    frame.classIcon:SetTexture("Interface\\TargetingFrame\\UI-Classes-Circles")
                    local coords = CLASS_ICON_TCOORDS[simData.class]
                    if coords then
                        frame.classIcon:SetTexCoord(unpack(coords))
                    end
                    frame.classIcon:Show()
                end
            elseif UnitExists(unit) then
                if portraitMode == "3d" then
                    frame.portrait3D:SetUnit(unit)
                    frame.portrait3D:SetCamera(0)
                    frame.portrait3D:Show()
                elseif portraitMode == "2d" then
                    SetPortraitTexture(frame.portrait2D, unit)
                    frame.portrait2D:SetTexCoord(0, 1, 0, 1)  -- Reset tex coords
                    frame.portrait2D:Show()
                elseif portraitMode == "class" then
                    frame.classIcon:SetTexture("Interface\\TargetingFrame\\UI-Classes-Circles")
                    local _, unitClass = UnitClass(unit)
                    if unitClass then
                        local coords = CLASS_ICON_TCOORDS[unitClass]
                        if coords then
                            frame.classIcon:SetTexCoord(unpack(coords))
                        end
                    end
                    frame.classIcon:Show()
                elseif portraitMode == "none" then
                    -- None mode - hide all portrait elements
                    frame.portrait3D:Hide()
                    frame.portrait2D:Hide()
                    frame.classIcon:Hide()
                end
            end
            
            -- Only show portrait frame if mode is not "none"
            if portraitMode ~= "none" then
                frame.portraitFrame:Show()
            else
                frame.portraitFrame:Hide()
            end
        else
            frame.portraitFrame:Hide()
        end
    end
    
    -- Update raid target
    if ps.raidTarget and ps.raidTarget.enabled then
        -- Dynamically update size and position from settings
        local rtSize = ps.raidTarget.size or 18
        local rtAnchor = ps.raidTarget.anchor or "CENTER"
        local rtFrameAnchor = ps.raidTarget.frameAnchor or "TOP"
        local rtOffsetX = ps.raidTarget.offsetX or 0
        local rtOffsetY = ps.raidTarget.offsetY or -2
        
        if frame.raidTargetFrame then
            frame.raidTargetFrame:SetSize(rtSize, rtSize)
            frame.raidTargetFrame:ClearAllPoints()
            frame.raidTargetFrame:SetPoint(rtAnchor, frame, rtFrameAnchor, rtOffsetX, rtOffsetY)
        end
        
        local raidIndex = GetRaidTargetIndex(unit)
        if raidIndex then
            SetRaidTargetIconTexture(frame.raidTarget, raidIndex)
            frame.raidTarget:Show()
            if frame.raidTargetFrame then frame.raidTargetFrame:Show() end
        else
            frame.raidTarget:Hide()
            if frame.raidTargetFrame then frame.raidTargetFrame:Hide() end
        end
    else
        frame.raidTarget:Hide()
        if frame.raidTargetFrame then frame.raidTargetFrame:Hide() end
    end
    
    -- Update debuff indicators
    -- Show during simulation even if disabled (so user can preview layout)
    local showDebuffIndicators = ps.debuffIndicators and (ps.debuffIndicators.enabled or isTestMode)
    if showDebuffIndicators then
        -- Dynamically update size, position, and style from settings
        local diSize = ps.debuffIndicators.size or 14
        local diStyle = ps.debuffIndicators.style or "squares"
        local diPosition = ps.debuffIndicators.position or "BOTTOMRIGHT"
        local diOffsetX = ps.debuffIndicators.offsetX or -2
        local diOffsetY = ps.debuffIndicators.offsetY or 2
        
        if frame.debuffContainer then
            frame.debuffContainer:SetSize(diSize * 4, diSize)
            frame.debuffContainer:ClearAllPoints()
            frame.debuffContainer:SetPoint(diPosition, frame, diPosition, diOffsetX, diOffsetY)
            frame.debuffContainer:Show()  -- Make sure container is visible
        end
        
        -- Midnight approach: Colored boxes instead of type-specific icons
        -- Each dispellable debuff gets a box with color from the curve
        -- No type detection needed - color comes directly from curve
        
        -- Hide existing type-specific indicators (legacy)
        for debuffType, indicator in pairs(frame.debuffIndicators) do
            indicator:Hide()
        end
        
        if isTestMode and simData and simData.debuffType then
            -- Simulation mode - show simulated type indicator
            local indicator = frame.debuffIndicators[simData.debuffType]
            if indicator then
                UpdateDebuffIndicatorStyle(indicator, diStyle, diSize)
                indicator:SetAlpha(1)
                indicator:ClearAllPoints()
                indicator:SetPoint("RIGHT", frame.debuffContainer, "RIGHT", 0, 0)
                indicator:Show()
            end
        else
            -- Use helper function for colored boxes
            UpdateDispelBoxes(frame, unit, diSize, 5, ps.debuffIndicators.onlyPlayerDispellable)
        end
    end
    
    -- ========================================================================
    -- LEADER INDICATOR UPDATE for party frames
    -- ========================================================================
    local lis = ps.leaderIndicator
    if lis and lis.enabled and frame.leaderIndicator then
        local isLeader, isAssistant
        
        if isTestMode and simData then
            -- Simulate: first party member is leader
            isLeader = (index == 1)
            isAssistant = false
        else
            -- UnitIsGroupLeader and UnitIsGroupAssistant return booleans, safe
            isLeader = UnitIsGroupLeader(unit)
            isAssistant = UnitIsGroupAssistant(unit)
        end
        
        -- Update position from settings
        local liSize = lis.size or 16
        local liAnchor = lis.anchor or "CENTER"
        local liFrameAnchor = lis.frameAnchor or "TOPRIGHT"
        local liOffsetX = lis.offsetX or -2
        local liOffsetY = lis.offsetY or -2
        
        frame.leaderFrame:SetSize(liSize, liSize)
        frame.leaderFrame:ClearAllPoints()
        frame.leaderFrame:SetPoint(liAnchor, frame, liFrameAnchor, liOffsetX, liOffsetY)
        
        if isLeader then
            frame.leaderIndicator:SetTexture("Interface\\GroupFrame\\UI-Group-LeaderIcon")
            frame.leaderIndicator:Show()
        elseif isAssistant then
            frame.leaderIndicator:SetTexture("Interface\\GroupFrame\\UI-Group-AssistantIcon")
            frame.leaderIndicator:Show()
        else
            frame.leaderIndicator:Hide()
        end
    elseif frame.leaderIndicator then
        frame.leaderIndicator:Hide()
    end
    
    -- ========================================================================
    -- SUMMON INDICATOR UPDATE for party frames
    -- ========================================================================
    local sumSettings = ps.summonIndicator
    if sumSettings and sumSettings.enabled and frame.summonFrame and frame.summonIndicator then
        local summonStatus
        
        if isTestMode and simData then
            -- Simulate: second party member has pending summon for preview
            summonStatus = (index == 2) and 1 or 0
        else
            -- C_IncomingSummon.IncomingSummonStatus returns enum, safe
            summonStatus = C_IncomingSummon and C_IncomingSummon.IncomingSummonStatus and C_IncomingSummon.IncomingSummonStatus(unit) or 0
        end
        
        -- Update position from settings
        local sumSize = sumSettings.size or 20
        local sumAnchor = sumSettings.anchor or "CENTER"
        local sumFrameAnchor = sumSettings.frameAnchor or "CENTER"
        local sumOffsetX = sumSettings.offsetX or 0
        local sumOffsetY = sumSettings.offsetY or 0
        
        frame.summonFrame:SetSize(sumSize, sumSize)
        frame.summonFrame:ClearAllPoints()
        frame.summonFrame:SetPoint(sumAnchor, frame, sumFrameAnchor, sumOffsetX, sumOffsetY)
        
        -- Enum.SummonStatus: None=0, Pending=1, Accepted=2, Declined=3
        if summonStatus == 1 then  -- Pending
            local r, g, b, a = unpack(sumSettings.pendingColor or { 1, 0.8, 0, 1 })
            frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonPending")
            frame.summonIndicator:SetVertexColor(r, g, b, a)
            frame.summonFrame:Show()
        elseif summonStatus == 2 then  -- Accepted
            local r, g, b, a = unpack(sumSettings.acceptedColor or { 0, 1, 0, 1 })
            frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonAccepted")
            frame.summonIndicator:SetVertexColor(r, g, b, a)
            frame.summonFrame:Show()
        else
            frame.summonFrame:Hide()
        end
    elseif frame.summonFrame then
        frame.summonFrame:Hide()
    end
    
    -- ========================================================================
    -- MOUSEOVER HIGHLIGHT UPDATE for party frames (Universal from general settings)
    -- Two styles: overlay, border
    -- ========================================================================
    local mhs = settings.general and settings.general.mouseoverHighlight
    if mhs and frame.mouseoverOverlayFrame and frame.mouseoverBorder then
        -- Hide all styles first
        frame.mouseoverOverlayFrame:Hide()
        frame.mouseoverBorder:Hide()
        
        if mhs.enabled then
            local r, g, b, a = unpack(mhs.color or { 1, 1, 1, 0.15 })
            local style = mhs.style or "overlay"
            
            -- Anchor to healthBar for proper scaling
            local anchor = frame.healthBar or frame
            
            if style == "overlay" then
                frame.mouseoverOverlayFrame:ClearAllPoints()
                frame.mouseoverOverlayFrame:SetAllPoints(anchor)
                frame.mouseoverOverlay:SetColorTexture(r, g, b, a)
                -- Visibility handled by OnEnter/OnLeave (HIGH strata, manual control)
            elseif style == "border" then
                local thickness = mhs.borderThickness or 2
                frame.mouseoverBorder:ClearAllPoints()
                frame.mouseoverBorder:SetPoint("TOPLEFT", anchor, "TOPLEFT", -thickness, thickness)
                frame.mouseoverBorder:SetPoint("BOTTOMRIGHT", anchor, "BOTTOMRIGHT", thickness, -thickness)
                frame.mouseoverBorder:SetBackdrop({
                    edgeFile = "Interface\\Buttons\\WHITE8X8",
                    edgeSize = thickness,
                })
                frame.mouseoverBorder:SetBackdropBorderColor(r, g, b, a)
                -- Border visibility handled by OnEnter/OnLeave hooks
            end
        end
    end
    
    -- ========================================================================
    -- TARGET HIGHLIGHT UPDATE for party frames
    -- ========================================================================
    local ths = ps.targetHighlight
    if ths and ths.enabled and frame.targetHighlight and frame.targetHighlightGlow then
        local isTarget
        
        if isTestMode then
            -- Simulate: first party member is "targeted"
            isTarget = (index == 1)
        else
            -- Check if this unit is the player's current target
            isTarget = UnitIsUnit(unit, "target")
        end
        
        local r, g, b, a = unpack(ths.color or { 1, 1, 1, 1 })
        
        if ths.style == "glow" then
            frame.targetHighlight:Hide()
            if isTarget then
                frame.targetHighlightGlow:SetVertexColor(r, g, b, a * 0.6)
                frame.targetHighlightGlow:Show()
            else
                frame.targetHighlightGlow:Hide()
            end
        else
            -- Border style (default)
            frame.targetHighlightGlow:Hide()
            local thickness = ths.thickness or 2
            frame.targetHighlight:ClearAllPoints()
            frame.targetHighlight:SetPoint("TOPLEFT", frame, "TOPLEFT", -thickness, thickness)
            frame.targetHighlight:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", thickness, -thickness)
            frame.targetHighlight:SetBackdrop({
                edgeFile = "Interface\\Buttons\\WHITE8X8",
                edgeSize = thickness,
            })
            frame.targetHighlight:SetBackdropBorderColor(r, g, b, a)
            
            if isTarget then
                frame.targetHighlight:Show()
            else
                frame.targetHighlight:Hide()
            end
        end
    elseif frame.targetHighlight and frame.targetHighlightGlow then
        frame.targetHighlight:Hide()
        frame.targetHighlightGlow:Hide()
    end
    
    -- Update cast bar
    local showPartyPreview = isTestMode and frame.castBar and ps.castBar
    if (frame.castBar and ps.castBar and ps.castBar.enabled) or showPartyPreview then
        local unitID = unit
        local cbs = ps.castBar
        
        -- Handle simulation mode
        if isTestMode and not UnitExists(unitID) then
            -- Show a simulated cast bar on the first frame only
            if frame.index == 1 then
                frame.castBar:SetMinMaxValues(0, 3)
                frame.castBar:SetValue(1.5)
                if frame.castText then 
                    if not cbs or cbs.showSpellName then
                        frame.castText:SetText("Simulated Cast")
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                if frame.castTimer then 
                    if not cbs or cbs.showTimer then
                        frame.castTimer:SetText("1.5")
                        frame.castTimer:Show()
                    else
                        frame.castTimer:Hide()
                    end
                end
                if frame.castIcon then 
                    if not cbs or cbs.showIcon then
                        frame.castIcon:SetTexture("Interface\\Icons\\Spell_Nature_Heal")
                        frame.castIcon:Show()
                    else
                        frame.castIcon:Hide()
                    end
                end
                frame.castBar:SetStatusBarColor(1, 0.7, 0, 1)
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        else
            -- Real cast bar update (v2.1.3 - SetTimerDuration for secrets)
            local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unitID)
            local isChannel = false
            local isEmpowered = false
            local numEmpowerStages = nil
            if not castName then
                -- Check for empowered spell using event-driven flag
                if frame.isEmpoweredCast and frame.empowerSpellID then
                    if C_Spell and C_Spell.GetSpellInfo then
                        local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                        if success and spellInfo and spellInfo.name then
                            local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unitID)
                            if chStart and chEnd then
                                castName = spellInfo.name
                                startTime = chStart
                                endTime = chEnd
                                spellID = frame.empowerSpellID
                                notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                                isEmpowered = true
                                isChannel = false
                                numEmpowerStages = GetEmpowerNumStages(unitID) or 3
                            end
                        end
                    end
                end
                
                if not isEmpowered then
                    castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unitID)
                    isChannel = true
                    frame.empowerSpellID = nil
                    frame.isEmpoweredCast = false
                end
            else
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
            
            -- Setup/hide empowered dividers
            if isEmpowered then
                local safeStages = numEmpowerStages or 3
                if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
                if safeStages >= 2 then
                    SetupEmpowerDividers(frame.castBar, unitID, safeStages)
                else
                    HideEmpowerDividers(frame.castBar)
                end
            else
                HideEmpowerDividers(frame.castBar)
            end
            
            local castBarSetup = false
            
            -- Try SetTimerDuration (handles secrets)
            if castName and HAS_TIMER_BARS then
                local durationObj = nil
                if isEmpowered and UnitEmpoweredChannelDuration then
                    local ok, obj = pcall(UnitEmpoweredChannelDuration, unitID, true)
                    if ok and obj then durationObj = obj end
                elseif isChannel and UnitChannelDuration then
                    local ok, obj = pcall(UnitChannelDuration, unitID)
                    if ok and obj then durationObj = obj end
                elseif not isChannel and UnitCastingDuration then
                    local ok, obj = pcall(UnitCastingDuration, unitID)
                    if ok and obj then durationObj = obj end
                end
                
                if durationObj then
                    frame.castBar:SetMinMaxValues(0, 1)
                    local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                    if ok then
                        castBarSetup = true
                        frame.castBarDurationObject = durationObj
                        frame.castBarUseTimerBar = true
                    end
                end
            end
            
            -- Traditional fallback
            if not castBarSetup then
                local safeCastName = SafeValue(castName)
                local safeStartTime = SafeNumber(startTime)
                local safeEndTime = SafeNumber(endTime)
                
                if safeCastName and safeStartTime and safeEndTime then
                    local duration = (safeEndTime - safeStartTime) / 1000
                    local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                    frame.castBar:SetMinMaxValues(0, duration)
                    
                    if isChannel then
                        frame.castBar:SetValue(duration - elapsed)
                    else
                        frame.castBar:SetValue(elapsed)
                    end
                    
                    if frame.castTimer and cbs.showTimer then
                        frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                        frame.castTimer:Show()
                    end
                    
                    castBarSetup = true
                end
            end
            
            if castBarSetup then
                -- Spell name
                if frame.castText then
                    if cbs.showSpellName then
                        local safeCastName = SafeValue(castName)
                        if safeCastName then
                            frame.castText:SetText(safeCastName)
                        elseif castName then
                            local ok, text = pcall(string.format, "%s", castName)
                            if ok and text then frame.castText:SetText(text) end
                        end
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                
                -- Icon
                if frame.castIcon then
                    if cbs.showIcon then
                        local safeSpellID = SafeNumber(spellID)
                        if safeSpellID then
                            local spellTexture = GetSpellTextureByID(safeSpellID)
                            if spellTexture then
                                frame.castIcon:SetTexture(spellTexture)
                                frame.castIcon:Show()
                            end
                        elseif spellID then
                            pcall(function()
                                local spellTexture = GetSpellTextureByID(spellID)
                                if spellTexture then
                                    frame.castIcon:SetTexture(spellTexture)
                                    frame.castIcon:Show()
                                end
                            end)
                        end
                    else
                        frame.castIcon:Hide()
                    end
                end
                
                -- Timer text for timer bar mode
                if frame.castBarUseTimerBar and frame.castTimer and cbs.showTimer then
                    local safeRemaining = nil
                    if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                        local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                        if ok and r then safeRemaining = r end
                    end
                    if safeRemaining then
                        local ok, text = pcall(string.format, "%.1f", safeRemaining)
                        if ok and text then frame.castTimer:SetText(text) end
                    end
                    frame.castTimer:Show()
                end
                
                -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
                local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
                local safeSpellID = SafeNumber(spellID)
                local isImportant = false
                if TweaksUI.SpellAPI and safeSpellID then
                    isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
                end
                if isImportant then
                    if isChannel then
                        baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                    else
                        baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                    end
                elseif isChannel then
                    baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
                end
                ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
                
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        end
    elseif frame.castBar then
        frame.castBar:Hide()
        if frame.castText then frame.castText:Hide() end
        if frame.castTimer then frame.castTimer:Hide() end
        if frame.castIcon then frame.castIcon:Hide() end
    end
    
    -- Update dispel overlay
    local DispelOverlay = TweaksUI.DispelOverlay
    if DispelOverlay and ps.dispelOverlay then
        DispelOverlay:UpdateOverlay(frame, ps.dispelOverlay)
    end
    
    -- Update threat overlay
    local ThreatOverlay = TweaksUI.ThreatOverlay
    if ThreatOverlay and ps.threatOverlay then
        ThreatOverlay:UpdateOverlay(frame, ps.threatOverlay)
    end
    
    -- ========================================================================
    -- UPDATE AURAS (buffs/debuffs) - exact copy of target frame approach
    -- ========================================================================
    
    local function UpdatePartyAuraContainer(container, auraSettings, unitToken, isBuff)
        if not container or not auraSettings or not auraSettings.enabled then
            if container then container:Hide() end
            return
        end
        
        container:Show()
        container.unit = unitToken
        
        local maxAuras = auraSettings.maxAuras or 8
        local iconSize = auraSettings.size or 18
        local spacing = auraSettings.spacing or 2
        local growDir = auraSettings.growDirection or "RIGHT"
        local filter = auraSettings.filter or (isBuff and "HELPFUL" or "HARMFUL")
        local hidePermanent = auraSettings.hidePermanent
        
        -- Hide all icons first
        for i, icon in ipairs(container.icons) do
            icon:Hide()
            icon.auraInstanceID = nil
        end
        
        -- In test mode, show placeholder auras
        if isTestMode and not UnitExists(unitToken) then
            local numSimAuras = isBuff and 3 or 2
            for i = 1, math.min(numSimAuras, maxAuras) do
                local icon = container.icons[i]
                if icon then
                    icon.texture:SetTexture(isBuff and "Interface\\Icons\\Spell_Holy_WordFortitude" or "Interface\\Icons\\Spell_Shadow_CurseOfTounges")
                    icon:SetSize(iconSize, iconSize)
                    icon:ClearAllPoints()
                    local offset = (i - 1) * (iconSize + spacing)
                    if growDir == "RIGHT" then
                        icon:SetPoint("LEFT", container, "LEFT", offset, 0)
                    elseif growDir == "LEFT" then
                        icon:SetPoint("RIGHT", container, "RIGHT", -offset, 0)
                    end
                    icon.cooldown:Hide()
                    icon.stackText:Hide()
                    icon.durationText:Hide()
                    icon:Show()
                end
            end
            return
        end
        
        -- Collect auras - same approach as target frame
        -- Use cached table to avoid allocations
        wipe(partyAurasCache)
        local auras = partyAurasCache
        
        -- Try GetUnitAuraInstanceIDs with sorting (Midnight+)
        if HAS_AURA_SORTING and C_UnitAuras.GetUnitAuraInstanceIDs then
            local sortRuleStr = auraSettings.sortRule or "Default"
            local sortDirStr = auraSettings.sortDirection or "Normal"
            local sortRule = Enum.UnitAuraSortRule[sortRuleStr] or Enum.UnitAuraSortRule.Default
            local sortDirection = Enum.UnitAuraSortDirection and Enum.UnitAuraSortDirection[sortDirStr] or nil
            
            local success, auraIDs = pcall(function()
                return C_UnitAuras.GetUnitAuraInstanceIDs(unitToken, filter, maxAuras, sortRule, sortDirection)
            end)
            
            if success and auraIDs then
                for _, auraID in ipairs(auraIDs) do
                    local auraSuccess, auraData = pcall(function()
                        return C_UnitAuras.GetAuraDataByAuraInstanceID(unitToken, auraID)
                    end)
                    if auraSuccess and auraData then
                        table.insert(auras, auraData)
                    end
                end
            end
        end
        
        -- Fallback: ForEachAura
        if #auras == 0 and AuraUtil and AuraUtil.ForEachAura then
            pcall(function()
                AuraUtil.ForEachAura(unitToken, filter, maxAuras, function(aura)
                    if aura then table.insert(auras, aura) end
                    if #auras >= maxAuras then return true end
                    return false
                end, true)
            end)
        end
        
        -- Fallback: GetAuraDataByIndex
        if #auras == 0 and C_UnitAuras and C_UnitAuras.GetAuraDataByIndex then
            for i = 1, maxAuras do
                local success, aura = pcall(function()
                    return C_UnitAuras.GetAuraDataByIndex(unitToken, i, filter)
                end)
                if success and aura then
                    table.insert(auras, aura)
                else
                    break
                end
            end
        end
        
        -- Update icons with aura data - EXACT same approach as target frame
        for i, auraData in ipairs(auras) do
            if i > maxAuras then break end
            
            local icon = container.icons[i]
            if icon and auraData then
                -- Direct assignment of auraInstanceID (assignment is allowed with secrets)
                icon.auraInstanceID = auraData.auraInstanceID
                
                -- Hide permanent auras using SetAlphaFromBoolean if available
                if hidePermanent and auraData.auraInstanceID and C_UnitAuras.DoesAuraHaveExpirationTime then
                    pcall(function()
                        local hasExpiration = C_UnitAuras.DoesAuraHaveExpirationTime(unitToken, auraData.auraInstanceID)
                        if icon.SetAlphaFromBoolean then
                            icon:SetAlphaFromBoolean(hasExpiration, 1.0, 0.0)
                        end
                    end)
                else
                    icon:SetAlpha(1.0)
                end
                
                -- Set texture - pcall because icon may be secret fileID
                local textureSet = false
                pcall(function()
                    icon.texture:SetTexture(auraData.icon)
                    icon.texture:SetVertexColor(1, 1, 1, 1)
                    textureSet = true
                end)
                
                if not textureSet then
                    icon:Hide()
                else
                    icon:SetSize(iconSize, iconSize)
                    
                    -- Duration/cooldown sweep - USE TweaksUI.API like target frame does
                    if auraSettings.showDuration ~= false then
                        local cooldownSet = false
                        
                        if auraData.auraInstanceID then
                            cooldownSet = TweaksUI.API.SetCooldownFromAura(icon.cooldown, unitToken, auraData.auraInstanceID)
                        end
                        
                        if cooldownSet then
                            icon.cooldown:Show()
                            -- Apply sweep alpha if set
                            local sweepAlpha = auraSettings.sweepAlpha or 1.0
                            icon.cooldown:SetAlpha(sweepAlpha)
                            -- Apply duration font size to Blizzard's countdown text
                            API.ApplyCooldownTextSettings(icon.cooldown, auraSettings.durationFontSize or 10, auraSettings.durationColor, auraSettings.durationAnchor, auraSettings.durationOffsetX, auraSettings.durationOffsetY)
                        else
                            icon.cooldown:Hide()
                        end
                    else
                        icon.cooldown:Hide()
                    end
                    
                    -- Duration text is now handled by Blizzard's CooldownFrameTemplate
                    -- with SetHideCountdownNumbers(false) - works with secret values
                    if icon.durationText then
                        icon.durationText:Hide()
                    end
                    
                    -- Stack count using Midnight API
                    if auraSettings.showStacks then
                        local stackShown = false
                        -- Apply stack font size from settings
                        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), auraSettings.stackFontSize or 10, GetFontOutline())
                        if auraData.auraInstanceID and C_UnitAuras and C_UnitAuras.GetAuraApplicationDisplayCount then
                            pcall(function()
                                local countText = C_UnitAuras.GetAuraApplicationDisplayCount(unitToken, auraData.auraInstanceID, 2)
                                icon.stackText:SetText(countText or "")
                                icon.stackText:Show()
                                stackShown = true
                            end)
                        end
                        if not stackShown then
                            icon.stackText:Hide()
                        end
                    else
                        icon.stackText:Hide()
                    end
                    
                    -- Position
                    icon:ClearAllPoints()
                    local offset = (i - 1) * (iconSize + spacing)
                    if growDir == "RIGHT" then
                        icon:SetPoint("LEFT", container, "LEFT", offset, 0)
                    elseif growDir == "LEFT" then
                        icon:SetPoint("RIGHT", container, "RIGHT", -offset, 0)
                    elseif growDir == "DOWN" then
                        icon:SetPoint("TOP", container, "TOP", 0, -offset)
                    elseif growDir == "UP" then
                        icon:SetPoint("BOTTOM", container, "BOTTOM", 0, offset)
                    end
                    
                    icon:Show()
                end
            end
        end
    end
    
    -- Position and update buff container
    if frame.buffsContainer and ps.buffs then
        if ps.buffs.enabled then
            frame.buffsContainer:ClearAllPoints()
            local anchor = ps.buffs.anchor or "BOTTOMLEFT"
            local frameAnchor = ps.buffs.frameAnchor or "TOPLEFT"
            local xOff = ps.buffs.offsetX or 0
            local yOff = ps.buffs.offsetY or 2
            frame.buffsContainer:SetPoint(anchor, frame, frameAnchor, xOff, yOff)
            UpdatePartyAuraContainer(frame.buffsContainer, ps.buffs, unit, true)
        else
            frame.buffsContainer:Hide()
        end
    end
    
    -- Position and update debuff container
    if frame.debuffsContainer and ps.debuffs then
        if ps.debuffs.enabled then
            frame.debuffsContainer:ClearAllPoints()
            local anchor = ps.debuffs.anchor or "TOPLEFT"
            local frameAnchor = ps.debuffs.frameAnchor or "BOTTOMLEFT"
            local xOff = ps.debuffs.offsetX or 0
            local yOff = ps.debuffs.offsetY or -2
            frame.debuffsContainer:SetPoint(anchor, frame, frameAnchor, xOff, yOff)
            UpdatePartyAuraContainer(frame.debuffsContainer, ps.debuffs, unit, false)
        else
            frame.debuffsContainer:Hide()
        end
    end
    
    -- Update defensive icon (big defensive cooldown display)
    local DefensiveIcons = TweaksUI.DefensiveIcons
    if DefensiveIcons and ps.defensiveIcon then
        DefensiveIcons:UpdateDefensiveIcon(frame, ps.defensiveIcon)
    end
end

-- ============================================================================
-- PARTY FRAME DATA-ONLY UPDATE (Performance optimization)
-- ============================================================================
-- Lightweight update function for frequent events (UNIT_HEALTH, UNIT_AURA, UNIT_SPELLCAST)
-- Only updates dynamic data: health, power, health text, debuff indicators, cast bar
-- Does NOT update layout, fonts, positions, portraits, role icons, etc.
-- The full UpdatePartyMemberFrame should only be called on settings changes

function UnitFrames:UpdatePartyMemberDataOnly(index)
    local frame = partyMemberFrames[index]
    if not frame then return end
    
    local ps = settings and settings.party
    if not ps then return end
    
    local unit = frame.unit
    
    -- Quick exit if unit doesn't exist
    if not UnitExists(unit) then
        return
    end
    
    -- ========================================================================
    -- HEALTH BAR UPDATE (most frequent)
    -- ========================================================================
    local healthPct = SafeUnitHealthPercent(unit, true) or 100
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    -- Health bar color (only health gradient needs recalculation)
    if ps.healthBar and ps.healthBar.colorMode == "health" then
        local r, g, b = GetHealthGradientColorMidnight(unit, nil)
        frame.healthBar:SetStatusBarColor(r, g, b)
    end
    -- Class colors don't change, skip them
    
    -- ========================================================================
    -- POWER BAR UPDATE
    -- ========================================================================
    if frame.powerBar then
        local power = UnitPower(unit)
        local maxPower = UnitPowerMax(unit)
        frame.powerBar:SetMinMaxValues(0, maxPower)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
    end
    
    -- ========================================================================
    -- HEALTH TEXT UPDATE
    -- ========================================================================
    if frame.healthText and ps.healthText and ps.healthText.enabled then
        frame.healthText:SetText(FormatHealthTextMidnight(unit, ps.healthText.format, nil, nil))
        -- Update health text color if using health-based coloring
        if ps.healthText.colorByHealth then
            local r, g, b = GetHealthGradientColorMidnight(unit, nil)
            frame.healthText:SetTextColor(r, g, b)
        end
    end
    
    -- ========================================================================
    -- DEBUFF INDICATORS UPDATE (Midnight: colored boxes)
    -- ========================================================================
    if ps.debuffIndicators and ps.debuffIndicators.enabled and frame.debuffIndicators then
        -- Hide legacy type-specific indicators
        for debuffType, indicator in pairs(frame.debuffIndicators) do
            indicator:Hide()
        end
        
        -- Use helper function for colored boxes
        local diSize = ps.debuffIndicators.size or 12
        UpdateDispelBoxes(frame, unit, diSize, 5, ps.debuffIndicators.onlyPlayerDispellable)
    end
    
    -- ========================================================================
    -- CAST BAR UPDATE (v2.1.3 - SetTimerDuration for secret values)
    -- ========================================================================
    if frame.castBar and ps.castBar and ps.castBar.enabled then
        local unitID = unit
        local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unitID)
        local isChannel = false
        local isEmpowered = false
        local numEmpowerStages = nil
        if not castName then
            -- Check for empowered spell using event-driven flag
            if frame.isEmpoweredCast and frame.empowerSpellID then
                if C_Spell and C_Spell.GetSpellInfo then
                    local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                    if success and spellInfo and spellInfo.name then
                        local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unitID)
                        if chStart and chEnd then
                            castName = spellInfo.name
                            startTime = chStart
                            endTime = chEnd
                            spellID = frame.empowerSpellID
                            notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                            isEmpowered = true
                            isChannel = false
                            numEmpowerStages = GetEmpowerNumStages(unitID) or 3
                        end
                    end
                end
            end
            
            if not isEmpowered then
                castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unitID)
                isChannel = true
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
        else
            frame.empowerSpellID = nil
            frame.isEmpoweredCast = false
        end
        
        -- Setup/hide empowered dividers
        if isEmpowered then
            local safeStages = numEmpowerStages or 3
            if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
            if safeStages >= 2 then
                SetupEmpowerDividers(frame.castBar, unitID, safeStages)
            else
                HideEmpowerDividers(frame.castBar)
            end
        else
            HideEmpowerDividers(frame.castBar)
        end
        
        local castBarSetup = false
        
        -- Try SetTimerDuration for party members (handles secrets)
        if castName and HAS_TIMER_BARS then
            local durationObj = nil
            if isEmpowered and UnitEmpoweredChannelDuration then
                local ok, obj = pcall(UnitEmpoweredChannelDuration, unitID, true)
                if ok and obj then durationObj = obj end
            elseif isChannel and UnitChannelDuration then
                local ok, obj = pcall(UnitChannelDuration, unitID)
                if ok and obj then durationObj = obj end
            elseif not isChannel and UnitCastingDuration then
                local ok, obj = pcall(UnitCastingDuration, unitID)
                if ok and obj then durationObj = obj end
            end
            
            if durationObj then
                frame.castBar:SetMinMaxValues(0, 1)
                local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                if ok then
                    castBarSetup = true
                    frame.castBarDurationObject = durationObj
                    frame.castBarUseTimerBar = true
                end
            end
        end
        
        -- Traditional fallback
        if not castBarSetup then
            local safeCastName = SafeValue(castName)
            local safeStartTime = SafeNumber(startTime)
            local safeEndTime = SafeNumber(endTime)
            
            if safeCastName and safeStartTime and safeEndTime then
                local duration = (safeEndTime - safeStartTime) / 1000
                local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                frame.castBar:SetMinMaxValues(0, duration)
                
                if isChannel then
                    frame.castBar:SetValue(duration - elapsed)
                else
                    frame.castBar:SetValue(elapsed)
                end
                
                if frame.castTimer and ps.castBar.showTimer then
                    frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                    frame.castTimer:Show()
                end
                
                castBarSetup = true
            end
        end
        
        if castBarSetup then
            -- Spell name (use string.format for secrets)
            if frame.castText and ps.castBar.showSpellName then
                local safeCastName = SafeValue(castName)
                if safeCastName then
                    frame.castText:SetText(safeCastName)
                elseif castName then
                    local ok, text = pcall(string.format, "%s", castName)
                    if ok and text then frame.castText:SetText(text) end
                end
                frame.castText:Show()
            end
            
            -- Timer text for timer bar mode
            if frame.castBarUseTimerBar and frame.castTimer and ps.castBar.showTimer then
                local safeRemaining = nil
                if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                    local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                    if ok and r then safeRemaining = r end
                end
                if safeRemaining then
                    local ok, text = pcall(string.format, "%.1f", safeRemaining)
                    if ok and text then frame.castTimer:SetText(text) end
                end
                frame.castTimer:Show()
            end
            
            -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
            local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
            local safeSpellID = SafeNumber(spellID)
            local isImportant = false
            if TweaksUI.SpellAPI and safeSpellID then
                isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
            end
            if isImportant then
                if isChannel then
                    baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                else
                    baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                end
            elseif isChannel then
                baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
            end
            ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
            
            frame.castBar:Show()
        else
            frame.castBar:Hide()
            if frame.castText then frame.castText:Hide() end
            if frame.castTimer then frame.castTimer:Hide() end
            if frame.castIcon then frame.castIcon:Hide() end
        end
    end
    
    -- ========================================================================
    -- OVERLAY UPDATES (lightweight - just visibility/color changes)
    -- ========================================================================
    -- Dispel overlay
    local DispelOverlay = TweaksUI.DispelOverlay
    if DispelOverlay and ps.dispelOverlay then
        DispelOverlay:UpdateOverlay(frame, ps.dispelOverlay)
    end
    
    -- Threat overlay
    local ThreatOverlay = TweaksUI.ThreatOverlay
    if ThreatOverlay and ps.threatOverlay then
        ThreatOverlay:UpdateOverlay(frame, ps.threatOverlay)
    end
    
    -- Defensive icon
    local DefensiveIcons = TweaksUI.DefensiveIcons
    if DefensiveIcons and ps.defensiveIcon then
        DefensiveIcons:UpdateDefensiveIcon(frame, ps.defensiveIcon)
    end
end

function UnitFrames:UpdatePartyFrames()
    if not settings then return end
    if not partyContainer then return end
    
    -- Check preview mode or test mode (TestMode is for /tuitest command)
    local TestMode = TweaksUI.UnitFramesTestMode
    local isTestMode = TestMode and TestMode:IsActive()
    local isPreviewMode = previewParty or isTestMode
    
    -- If not enabled AND not in preview mode, hide and return
    if not settings.party or not settings.party.enabled then
        if not isPreviewMode then
            if not InCombatLockdown() then
                partyContainer:Hide()
            end
            return
        end
    end
    
    -- Hide party frames when in a raid group (if setting enabled)
    if settings.party.hideInRaid and IsInRaid() and not isPreviewMode then
        if not InCombatLockdown() then
            partyContainer:Hide()
        end
        return
    end
    
    -- Keep Blizzard party frames hidden (already protected internally)
    UnitFrames.HideBlizzardPartyFrames()
    
    -- Only show party frames if in a real group or preview mode is enabled
    local inGroup = IsInGroup() or isPreviewMode
    
    if not inGroup then
        if not InCombatLockdown() then
            partyContainer:Hide()
        end
        return
    end
    
    if not InCombatLockdown() then
        partyContainer:Show()
    end
    
    local ps = settings.party
    local mf = ps.frame
    local spacing = ps.container.spacing or 2
    local scale = ps.container.scale or 1.0
    local growthDirection = ps.container.growthDirection or "DOWN"
    
    -- Only update layout/positions outside of combat (secure frame restrictions)
    if not InCombatLockdown() then
        -- If managed by Layout, only update scale on wrapper, not container position
        if containerWrappers["party"] then
            -- Scale is handled by wrapper now
            partyContainer:SetScale(1.0)
            containerWrappers["party"].frame:SetScale(scale)
        else
            -- Not yet registered with Layout (or Layout not available)
            -- Apply scale and position directly from settings
            partyContainer:SetScale(scale)
            partyContainer:ClearAllPoints()
            partyContainer:SetPoint(ps.container.anchor, UIParent, ps.container.anchor, ps.container.x, ps.container.y)
        end
        
        -- Get sorted unit order if sorting is enabled
        local Sorting = TweaksUI.UnitFramesSorting
        local sortedUnits = nil
        local sortSettings = ps.sorting
        
        if Sorting and sortSettings and sortSettings.enabled then
            sortedUnits = Sorting:GetSortedUnitList(UnitFrames.PARTY_UNITS, sortSettings)
        end
        
        -- Update each member frame position and unit assignment
        for i = 1, 5 do
            local frame = partyMemberFrames[i]
            if frame then
                -- Update unit assignment if sorting is enabled
                if sortedUnits then
                    local newUnit = sortedUnits[i]
                    if newUnit and newUnit ~= frame.unit then
                        frame.unit = newUnit
                        frame:SetAttribute("unit", newUnit)
                    end
                end
                
                -- Update frame position based on growth direction and spacing
                frame:ClearAllPoints()
                if growthDirection == "DOWN" then
                    local yOffset = -2 - ((i - 1) * (mf.height + spacing))
                    frame:SetPoint("TOPLEFT", partyContainer, "TOPLEFT", 2, yOffset)
                elseif growthDirection == "UP" then
                    local yOffset = 2 + ((i - 1) * (mf.height + spacing))
                    frame:SetPoint("BOTTOMLEFT", partyContainer, "BOTTOMLEFT", 2, yOffset)
                elseif growthDirection == "RIGHT" then
                    local xOffset = 2 + ((i - 1) * (mf.width + spacing))
                    frame:SetPoint("TOPLEFT", partyContainer, "TOPLEFT", xOffset, -2)
                elseif growthDirection == "LEFT" then
                    local xOffset = -2 - ((i - 1) * (mf.width + spacing))
                    frame:SetPoint("TOPRIGHT", partyContainer, "TOPRIGHT", xOffset, -2)
                end
            end
        end
        
        -- Resize container based on visible frames
        local visibleCount = 0
        for i = 1, 5 do
            if partyMemberFrames[i] and partyMemberFrames[i]:IsShown() then
                visibleCount = visibleCount + 1
            end
        end
        
        -- Set container size based on growth direction
        if growthDirection == "DOWN" or growthDirection == "UP" then
            local height = (mf.height + spacing) * visibleCount + 4
            partyContainer:SetSize(mf.width + 4, math.max(height, mf.height + 4))
        else
            local width = (mf.width + spacing) * visibleCount + 4
            partyContainer:SetSize(math.max(width, mf.width + 4), mf.height + 4)
        end
    end
    
    -- Always update frame content (health, power, names, etc.) - this is safe during combat
    for i = 1, 5 do
        self:UpdatePartyMemberFrame(i)
    end
end

-- Helper method to get party member frames (used by submodules)
function UnitFrames:GetPartyMemberFrames()
    return partyMemberFrames
end

-- Helper method to get party settings (used by submodules like DefensiveIcons)
function UnitFrames:GetPartySettings()
    return settings and settings.party
end

-- Helper method to get current raid settings based on raid size (used by submodules)
function UnitFrames:GetCurrentRaidSettings()
    if not settings or not settings.raid then return nil end
    
    local rs = settings.raid
    local raidSize = GetNumGroupMembers()
    local threshold = rs.sizeThreshold or 20
    
    if raidSize <= threshold then
        return rs.small
    else
        return rs.large
    end
end

-- Helper method to get raid member frames (used by submodules)
function UnitFrames:GetRaidMemberFrames()
    -- Return the appropriate raid frames based on current raid size
    if not IsInRaid() then return {} end
    
    local rs = settings.raid
    if not rs then return {} end
    
    local raidSize = GetNumGroupMembers()
    local threshold = rs.sizeThreshold or 20
    
    if raidSize <= threshold then
        return raidSmallMemberFrames or {}
    else
        return raidLargeMemberFrames or {}
    end
end

-- Helper method to get all group frames (party or raid, whichever is active)
function UnitFrames:GetAllGroupFrames()
    local frames = {}
    
    -- Add party frames if in party (not raid)
    if IsInGroup() and not IsInRaid() then
        for _, frame in pairs(partyMemberFrames) do
            table.insert(frames, frame)
        end
    end
    
    -- Add raid frames if in raid
    if IsInRaid() then
        local raidFrames = self:GetRaidMemberFrames()
        for _, frame in pairs(raidFrames) do
            table.insert(frames, frame)
        end
    end
    
    return frames
end

-- Helper method to get the player frame
function UnitFrames:GetPlayerFrame()
    return customFrames["player"]
end

-- Helper method to get the target frame
function UnitFrames:GetTargetFrame()
    return customFrames["target"]
end

-- Helper method to get the focus frame
function UnitFrames:GetFocusFrame()
    return customFrames["focus"]
end

-- Helper method to get any individual unit frame
function UnitFrames:GetUnitFrame(unit)
    return customFrames[unit]
end

function UnitFrames:DestroyPartyContainer()
    -- Can't destroy secure frames during combat
    if InCombatLockdown() then return end
    
    -- Clean up Layout registration first
    if containerWrappers["party"] then
        if Layout and Layout.UnregisterElement then
            Layout:UnregisterElement("container_party")
        end
        -- Destroy the wrapper frame
        if containerWrappers["party"].frame then
            containerWrappers["party"].frame:Hide()
        end
        if containerWrappers["party"].Destroy then
            containerWrappers["party"]:Destroy()
        end
        containerWrappers["party"] = nil
    end
    
    if partyContainer then
        partyContainer:Hide()
        partyContainer = nil
    end
    for i, frame in pairs(partyMemberFrames) do
        if frame then
            frame:Hide()
            frame:SetParent(nil)
        end
    end
    partyMemberFrames = {}
    
    -- Restore Blizzard party frame
    if PartyFrame then
        PartyFrame:SetAlpha(1)
        PartyFrame:EnableMouse(true)
        
        -- Restore member frames as well
        for i = 1, 4 do
            local memberFrame = PartyFrame["MemberFrame" .. i]
            if memberFrame then
                memberFrame:SetAlpha(1)
                memberFrame:EnableMouse(true)
            end
        end
    end
    
    -- Restore CompactPartyFrame (raid-style party frames)
    if CompactPartyFrame then
        CompactPartyFrame:SetAlpha(1)
        CompactPartyFrame:EnableMouse(true)
    end
    
    -- Restore CompactRaidFrameContainer if it was hidden for party
    if CompactRaidFrameContainer then
        CompactRaidFrameContainer:SetAlpha(1)
        CompactRaidFrameContainer:EnableMouse(true)
    end
end

-- ============================================================================
-- RAID FRAMES
-- ============================================================================

function UnitFrames.HideBlizzardRaidFrames()
    if InCombatLockdown() then return end
    
    -- CRITICAL: Don't modify frames during Edit Mode - this causes taint/errors
    if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
        return
    end
    
    -- Also skip during TUI Layout Mode
    if TweaksUI.Layout and TweaksUI.Layout:IsActive() then
        return
    end
    
    -- Move CompactRaidFrameContainer off-screen
    if CompactRaidFrameContainer then
        MoveFrameOffScreen(CompactRaidFrameContainer, "CompactRaidFrameContainer")
    end
    
    -- Move CompactRaidFrameManager off-screen
    if CompactRaidFrameManager then
        MoveFrameOffScreen(CompactRaidFrameManager, "CompactRaidFrameManager")
    end
    
    -- Move CompactRaidFrame1-40 member frames off-screen
    for i = 1, 40 do
        local memberName = "CompactRaidFrame" .. i
        local member = _G[memberName]
        if member then
            MoveFrameOffScreen(member, memberName)
        end
    end
    
    -- Move CompactRaidGroup1-8 containers off-screen
    for i = 1, 8 do
        local groupName = "CompactRaidGroup" .. i
        local group = _G[groupName]
        if group then
            MoveFrameOffScreen(group, groupName)
        end
    end
end

-- Track if we've hooked Blizzard raid frames
UnitFrames.BlizzState.raidHooked = false

local function HookBlizzardRaidFrames()
    if UnitFrames.BlizzState.raidHooked then return end
    UnitFrames.BlizzState.raidHooked = true
    
    -- Hook CompactRaidFrameContainer
    if CompactRaidFrameContainer then
        hooksecurefunc(CompactRaidFrameContainer, "Show", function(self)
            if settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                    C_Timer.After(0, function()
                        if not InCombatLockdown() then
                            UnitFrames.HideBlizzardRaidFrames()
                        end
                    end)
                end
            end
        end)
        
        hooksecurefunc(CompactRaidFrameContainer, "SetAlpha", function(self, alpha)
            -- Use pcall to safely compare alpha (may be secret in Midnight)
            local isPositive = true
            pcall(function() isPositive = alpha > 0 end)
            if isPositive and settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                    C_Timer.After(0, function()
                        if self and self.SetAlpha then
                            self:SetAlpha(0)
                        end
                    end)
                end
            end
        end)
    end
    
    -- Hook CompactRaidFrameManager
    if CompactRaidFrameManager then
        hooksecurefunc(CompactRaidFrameManager, "Show", function(self)
            if settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                    C_Timer.After(0, function()
                        if not InCombatLockdown() then
                            UnitFrames.HideBlizzardRaidFrames()
                        end
                    end)
                end
            end
        end)
    end
    
    -- Hook individual CompactRaidFrame1-40 member frames
    for i = 1, 40 do
        local memberName = "CompactRaidFrame" .. i
        local member = _G[memberName]
        if member and not member._tuiRaidHooked then
            hooksecurefunc(member, "Show", function(self)
                if settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                    if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                        self:SetAlpha(0)
                        pcall(function() self:EnableMouse(false) end)
                    end
                end
            end)
            hooksecurefunc(member, "SetAlpha", function(self, alpha)
                -- Use pcall to safely compare alpha (may be secret in Midnight)
                local isPositive = true
                pcall(function() isPositive = alpha > 0 end)
                if isPositive and settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                    if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                self:SetAlpha(0)
                            end
                        end)
                    end
                end
            end)
            member._tuiRaidHooked = true
            
            -- Hook SelectionHighlight
            local highlight = _G[memberName .. "SelectionHighlight"]
            if highlight and not highlight._tuiRaidHooked then
                hooksecurefunc(highlight, "Show", function(self)
                    if settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                        self:SetAlpha(0)
                        self:Hide()
                    end
                end)
                hooksecurefunc(highlight, "SetAlpha", function(self, alpha)
                    -- Use pcall to safely compare alpha (may be secret in Midnight)
                    local isPositive = true
                    pcall(function() isPositive = alpha > 0 end)
                    if isPositive and settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                        C_Timer.After(0, function()
                            if self and self.SetAlpha then
                                self:SetAlpha(0)
                            end
                        end)
                    end
                end)
                highlight._tuiRaidHooked = true
            end
            
            -- Hook Background
            local bg = _G[memberName .. "Background"]
            if bg and not bg._tuiRaidHooked then
                hooksecurefunc(bg, "Show", function(self)
                    if settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
                        self:SetAlpha(0)
                        self:Hide()
                    end
                end)
                bg._tuiRaidHooked = true
            end
        end
    end
end

-- Re-apply raid frame hiding after combat ends and on group changes
local raidFrameRegenFrame = CreateFrame("Frame")
raidFrameRegenFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
raidFrameRegenFrame:RegisterEvent("GROUP_ROSTER_UPDATE")
raidFrameRegenFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
raidFrameRegenFrame:SetScript("OnEvent", function(self, event)
    if settings and settings.raid and (settings.raid.small.enabled or settings.raid.large.enabled) then
        C_Timer.After(0.2, function()
            if not InCombatLockdown() then
                UnitFrames.HideBlizzardRaidFrames()
                HookBlizzardRaidFrames()
            end
        end)
    end
end)

function UnitFrames.ShowBlizzardRaidFrames()
    if InCombatLockdown() then return end
    
    -- Restore CompactRaidFrameContainer from off-screen
    RestoreFrameFromOffScreen("CompactRaidFrameContainer")
    
    -- Restore CompactRaidFrameManager from off-screen
    RestoreFrameFromOffScreen("CompactRaidFrameManager")
    
    -- Restore individual CompactRaidFrame1-40 member frames from off-screen
    for i = 1, 40 do
        RestoreFrameFromOffScreen("CompactRaidFrame" .. i)
    end
    
    -- Restore CompactRaidGroup1-8 containers from off-screen
    for i = 1, 8 do
        RestoreFrameFromOffScreen("CompactRaidGroup" .. i)
    end
end

function UnitFrames:CreateRaidContainer(sizeType)
    -- Skip if external addon handles raid frames
    if self:IsRaidDisabledByExternalAddon() then
        TweaksUI:PrintDebug("Raid container creation skipped - " .. (self:GetExternalRaidAddon() or "external addon") .. " is handling raid frames")
        return nil
    end
    
    sizeType = sizeType or "small"
    
    local container, memberFrames
    if sizeType == "small" then
        if raidSmallContainer then return raidSmallContainer end
        container = nil
        memberFrames = raidSmallMemberFrames
    else
        if raidLargeContainer then return raidLargeContainer end
        container = nil
        memberFrames = raidLargeMemberFrames
    end
    
    local rs = settings.raid
    if not rs then return end
    
    local layoutSettings = rs[sizeType]
    if not layoutSettings then return end
    
    local containerSettings = layoutSettings.container
    local scale = containerSettings.scale or 1.0
    
    -- Create main container (no backdrop - Layout overlays provide visual feedback)
    local frameName = "TweaksUI_RaidContainer_" .. sizeType
    container = CreateFrame("Frame", frameName, UIParent)
    
    -- Position from settings initially - Layout will take over when registered
    container:SetPoint(containerSettings.anchor or "CENTER", UIParent, containerSettings.anchor or "CENTER", containerSettings.x or 0, containerSettings.y or 0)
    container:SetScale(scale)
    container:SetMovable(true)
    container:SetClampedToScreen(true)
    
    -- Drag handling is done by Layout system now
    container:EnableMouse(false)
    
    -- Initial size will be calculated by UpdateRaidFrames
    container:SetSize(400, 200)
    container.sizeType = sizeType
    
    -- Store reference
    if sizeType == "small" then
        raidSmallContainer = container
    else
        raidLargeContainer = container
    end
    
    -- Create member frames
    local maxFrames = sizeType == "small" and 20 or 40
    for i = 1, maxFrames do
        self:CreateRaidMemberFrame(sizeType, i)
    end
    
    -- Hide Blizzard raid frames and set up hooks
    UnitFrames.HideBlizzardRaidFrames()
    HookBlizzardRaidFrames()
    
    -- Register with Layout system
    local regSizeType = sizeType
    local regContainer = container
    local regSettings = containerSettings
    
    local wrapper = UnitFrames:RegisterContainerWithLayout("raid_" .. regSizeType, regContainer, regSettings)
    
    if not wrapper then
        C_Timer.After(0.2, function()
            if regContainer and not containerWrappers["raid_" .. regSizeType] then
                UnitFrames:RegisterContainerWithLayout("raid_" .. regSizeType, regContainer, regSettings)
            end
        end)
    end
    
    return container
end

function UnitFrames:CreateRaidMemberFrame(sizeType, index)
    local rs = settings.raid
    if not rs then return end
    
    local layoutSettings = rs[sizeType]
    if not layoutSettings then return end
    
    -- Ensure castBar settings exist
    if not layoutSettings.castBar then
        layoutSettings.castBar = {
            enabled = false,
            height = 6,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
        }
    end
    
    local mf = layoutSettings.frame
    local container = sizeType == "small" and raidSmallContainer or raidLargeContainer
    local memberFrames = sizeType == "small" and raidSmallMemberFrames or raidLargeMemberFrames
    
    if not container then return end
    
    -- Create secure button for click interactions
    local frameName = "TweaksUI_RaidMember_" .. sizeType .. "_" .. index
    local frame = CreateFrame("Button", frameName, container, "SecureUnitButtonTemplate, BackdropTemplate")
    frame:SetSize(mf.width, mf.height)
    
    -- Set unit attribute (will be updated dynamically)
    local unit = "raid" .. index
    frame:SetAttribute("unit", unit)
    frame.unit = unit  -- Store for easy access
    frame:SetAttribute("type1", "target")
    frame:SetAttribute("type2", "togglemenu")
    frame:RegisterForClicks("AnyUp")
    
    -- Background
    if mf.showBackground then
        frame:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8x8",
            edgeFile = mf.showBorder and "Interface\\Buttons\\WHITE8x8" or nil,
            edgeSize = mf.borderSize or 1,
        })
        frame:SetBackdropColor(mf.bgColor[1], mf.bgColor[2], mf.bgColor[3], mf.bgColor[4])
        if mf.showBorder then
            frame:SetBackdropBorderColor(mf.borderColor[1], mf.borderColor[2], mf.borderColor[3], mf.borderColor[4])
        end
    end
    
    -- Health bar
    local healthBar = CreateFrame("StatusBar", nil, frame)
    healthBar:SetPoint("TOPLEFT", 1, -1)
    healthBar:SetPoint("TOPRIGHT", -1, -1)
    healthBar:SetHeight(layoutSettings.healthBar.height)
    healthBar:SetStatusBarTexture(GetTexturePath(layoutSettings.healthBar.texture))
    healthBar:SetStatusBarColor(0.2, 0.8, 0.2)
    -- Apply bar masking
    if TweaksUI.BarMasking and layoutSettings.healthBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(healthBar, layoutSettings.healthBar.maskShape)
    end
    frame.healthBar = healthBar
    
    local healthBg = healthBar:CreateTexture(nil, "BACKGROUND")
    healthBg:SetAllPoints()
    healthBg:SetColorTexture(0.1, 0.1, 0.1, 0.8)
    
    -- Power bar
    local powerBar = CreateFrame("StatusBar", nil, frame)
    powerBar:SetPoint("TOPLEFT", healthBar, "BOTTOMLEFT", 0, -1)
    powerBar:SetPoint("TOPRIGHT", healthBar, "BOTTOMRIGHT", 0, -1)
    powerBar:SetHeight(layoutSettings.powerBar.height)
    powerBar:SetStatusBarTexture(GetTexturePath(layoutSettings.powerBar.texture))
    powerBar:SetStatusBarColor(0.2, 0.2, 0.8)
    -- Apply bar masking
    if TweaksUI.BarMasking and layoutSettings.powerBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(powerBar, layoutSettings.powerBar.maskShape)
    end
    frame.powerBar = powerBar
    
    local powerBg = powerBar:CreateTexture(nil, "BACKGROUND")
    powerBg:SetAllPoints()
    powerBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
    
    -- Name text
    local nameText = healthBar:CreateFontString(nil, "OVERLAY")
    nameText:SetFont(GetFontPath(DEFAULT_FONT), layoutSettings.nameText.fontSize, GetFontOutline(layoutSettings.nameText.fontOutline))
    nameText:SetPoint("LEFT", healthBar, "LEFT", 2, 0)
    nameText:SetJustifyH("LEFT")
    frame.nameText = nameText
    
    -- Health text
    local healthText = healthBar:CreateFontString(nil, "OVERLAY")
    healthText:SetFont(GetFontPath(DEFAULT_FONT), layoutSettings.healthText.fontSize, GetFontOutline(layoutSettings.healthText.fontOutline))
    healthText:SetPoint("RIGHT", healthBar, "RIGHT", -2, 0)
    healthText:SetJustifyH("RIGHT")
    frame.healthText = healthText
    
    -- Role icon
    local roleIconFrame = CreateFrame("Frame", nil, frame)
    roleIconFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
    local riSize = layoutSettings.roleIcon.size or 12
    roleIconFrame:SetSize(riSize, riSize)
    roleIconFrame:SetPoint(layoutSettings.roleIcon.anchor or "CENTER", frame, layoutSettings.roleIcon.frameAnchor or "TOPLEFT", layoutSettings.roleIcon.offsetX or 1, layoutSettings.roleIcon.offsetY or -1)
    
    local roleIcon = roleIconFrame:CreateTexture(nil, "OVERLAY", nil, 7)
    roleIcon:SetAllPoints()
    roleIconFrame:Hide()
    frame.roleIcon = roleIcon
    frame.roleIconFrame = roleIconFrame
    
    -- Raid target icon
    local raidTargetFrame = CreateFrame("Frame", nil, frame)
    raidTargetFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
    local rtSize = layoutSettings.raidTarget.size or 14
    raidTargetFrame:SetSize(rtSize, rtSize)
    raidTargetFrame:SetPoint(layoutSettings.raidTarget.anchor or "CENTER", frame, layoutSettings.raidTarget.frameAnchor or "TOP", layoutSettings.raidTarget.offsetX or 0, layoutSettings.raidTarget.offsetY or -2)
    
    local raidTarget = raidTargetFrame:CreateTexture(nil, "OVERLAY", nil, 7)
    raidTarget:SetAllPoints()
    raidTarget:SetTexture("Interface\\TargetingFrame\\UI-RaidTargetingIcons")
    raidTargetFrame:Hide()
    frame.raidTarget = raidTarget
    frame.raidTargetFrame = raidTargetFrame
    
    -- Debuff indicators
    local debuffContainer = CreateFrame("Frame", nil, frame)
    debuffContainer:SetFrameLevel(frame:GetFrameLevel() + 10)
    local diSize = layoutSettings.debuffIndicators.size or 10
    local diStyle = layoutSettings.debuffIndicators.style or "squares"
    debuffContainer:SetSize(diSize * 4, diSize)
    debuffContainer:SetPoint(layoutSettings.debuffIndicators.position or "BOTTOMRIGHT", frame, layoutSettings.debuffIndicators.position or "BOTTOMRIGHT", layoutSettings.debuffIndicators.offsetX or -1, layoutSettings.debuffIndicators.offsetY or 1)
    frame.debuffContainer = debuffContainer
    
    local LOCAL_DEBUFF_COLORS = {
        Magic = {0.2, 0.6, 1.0, 1},
        Curse = {0.6, 0.0, 1.0, 1},
        Disease = {0.6, 0.4, 0.0, 1},
        Poison = {0.0, 0.6, 0.0, 1},
    }
    
    frame.debuffIndicators = {}
    local debuffTypes = {"Magic", "Curse", "Disease", "Poison"}
    for j, debuffType in ipairs(debuffTypes) do
        local indicator = CreateFrame("Frame", nil, debuffContainer, "BackdropTemplate")
        indicator:SetSize(diSize, diSize)
        indicator:SetPoint("RIGHT", debuffContainer, "RIGHT", -((j-1) * (diSize + 1)), 0)
        indicator:SetFrameLevel(debuffContainer:GetFrameLevel() + 1)
        
        local color = LOCAL_DEBUFF_COLORS[debuffType]
        indicator.color = color
        indicator.debuffType = debuffType
        
        -- Create colored square (for "squares" and fallback mode)
        indicator.square = indicator:CreateTexture(nil, "BACKGROUND")
        indicator.square:SetAllPoints()
        indicator.square:SetColorTexture(color[1], color[2], color[3], 1)
        
        -- Create Blizzard-style icon (for "icons" and "both" modes)
        indicator.icon = indicator:CreateTexture(nil, "ARTWORK")
        indicator.icon:SetAllPoints()
        indicator.icon:SetTexCoord(0.08, 0.92, 0.08, 0.92)
        
        -- Try to set atlas first, fallback to texture path
        local atlasSet = false
        if Constants.DEBUFF_TYPE_ATLASES and Constants.DEBUFF_TYPE_ATLASES[debuffType] then
            local success = pcall(function()
                indicator.icon:SetAtlas(Constants.DEBUFF_TYPE_ATLASES[debuffType])
            end)
            if success then atlasSet = true end
        end
        if not atlasSet and Constants.DEBUFF_TYPE_TEXTURES and Constants.DEBUFF_TYPE_TEXTURES[debuffType] then
            indicator.icon:SetTexture(Constants.DEBUFF_TYPE_TEXTURES[debuffType])
        end
        
        -- Set initial style
        UpdateDebuffIndicatorStyle(indicator, diStyle, diSize)
        
        indicator:Hide()
        frame.debuffIndicators[debuffType] = indicator
    end
    
    -- Cast Bar (always create, visibility controlled by enabled setting)
    if layoutSettings.castBar then
        local cbHeight = layoutSettings.castBar.height or 6
        local castBar = CreateFrame("StatusBar", nil, frame)
        castBar:SetStatusBarTexture(GetTexturePath(layoutSettings.castBar.texture))
        castBar:SetStatusBarColor(1, 0.7, 0, 1)
        castBar:SetHeight(cbHeight)
        castBar:SetPoint("TOPLEFT", frame, "BOTTOMLEFT", 1, -1)
        castBar:SetPoint("TOPRIGHT", frame, "BOTTOMRIGHT", -1, -1)
        castBar:SetMinMaxValues(0, 1)
        castBar:SetValue(0)
        castBar:Hide()
        frame.castBar = castBar
        
        local castBg = castBar:CreateTexture(nil, "BACKGROUND")
        castBg:SetAllPoints()
        castBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
        
        -- Always create text/icon/timer elements
        local castText = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        castText:SetPoint("LEFT", castBar, "LEFT", cbHeight + 2, 0)
        frame.castText = castText
        
        local castIcon = castBar:CreateTexture(nil, "OVERLAY")
        castIcon:SetSize(cbHeight, cbHeight)
        castIcon:SetPoint("LEFT", castBar, "LEFT", 1, 0)
        frame.castIcon = castIcon
        
        local castTimer = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        castTimer:SetPoint("RIGHT", castBar, "RIGHT", -2, 0)
        frame.castTimer = castTimer
    end
    
    -- Summon Indicator (shows pending/accepted summon status)
    local sumSettings = layoutSettings.summonIndicator
    if sumSettings then
        frame.summonFrame = CreateFrame("Frame", frameName .. "_SummonIndicator", frame)
        frame.summonFrame:SetFrameStrata("HIGH")
        frame.summonFrame:SetFrameLevel(100)
        frame.summonFrame:SetSize(sumSettings.size or 16, sumSettings.size or 16)
        frame.summonFrame:SetPoint(sumSettings.anchor or "CENTER", frame, sumSettings.frameAnchor or "CENTER", sumSettings.offsetX or 0, sumSettings.offsetY or 0)
        frame.summonFrame:Hide()
        
        frame.summonIndicator = frame.summonFrame:CreateTexture(nil, "OVERLAY")
        frame.summonIndicator:SetAllPoints()
        frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonPending")
    end
    
    -- Highlight
    local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
    highlight:SetAllPoints()
    highlight:SetColorTexture(1, 1, 1, 0.1)
    
    -- ========================================================================
    -- BUFF/DEBUFF AURA ICONS (same approach as party/target frames)
    -- ========================================================================
    
    local function CreateRaidAuraIcon(parent, iconIndex)
        local icon = CreateFrame("Frame", nil, parent, "BackdropTemplate")
        icon:SetFrameLevel(parent:GetFrameLevel() + 1)
        icon:EnableMouse(true)
        
        icon.texture = icon:CreateTexture(nil, "ARTWORK")
        icon.texture:SetAllPoints()
        icon.texture:SetTexCoord(0.08, 0.92, 0.08, 0.92)
        
        icon.cooldown = CreateFrame("Cooldown", nil, icon, "CooldownFrameTemplate")
        icon.cooldown:SetAllPoints()
        icon.cooldown:SetDrawEdge(false)
        icon.cooldown:SetDrawBling(false)
        icon.cooldown:SetDrawSwipe(true)
        icon.cooldown:SetReverse(true)
        icon.cooldown:SetHideCountdownNumbers(false)  -- Use Blizzard's built-in text (works with secret values)
        
        icon.border = icon:CreateTexture(nil, "OVERLAY")
        icon.border:SetPoint("TOPLEFT", -1, 1)
        icon.border:SetPoint("BOTTOMRIGHT", 1, -1)
        icon.border:SetTexture("Interface\\Buttons\\UI-Debuff-Overlays")
        icon.border:SetTexCoord(0.296875, 0.5703125, 0, 0.515625)
        icon.border:Hide()
        
        icon.textOverlay = CreateFrame("Frame", nil, icon)
        icon.textOverlay:SetAllPoints()
        icon.textOverlay:SetFrameLevel(icon:GetFrameLevel() + 10)
        
        icon.stackText = icon.textOverlay:CreateFontString(nil, "OVERLAY")
        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
        icon.stackText:SetPoint("BOTTOMRIGHT", 0, 0)
        icon.stackText:SetTextColor(1, 1, 1, 1)
        
        -- Duration text (no longer used - Blizzard's CooldownFrameTemplate handles it)
        icon.durationText = icon.textOverlay:CreateFontString(nil, "OVERLAY")
        icon.durationText:SetFont(GetFontPath(DEFAULT_FONT), 10, GetFontOutline())
        icon.durationText:SetPoint("CENTER", 0, 0)
        icon.durationText:SetTextColor(1, 1, 0.6, 1)
        icon.durationText:Hide()  -- Blizzard's cooldown handles duration text now
        
        icon.index = iconIndex
        icon.auraInstanceID = nil
        
        icon:SetScript("OnEnter", function(self)
            if self.auraInstanceID and parent.unit then
                GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
                pcall(function()
                    if parent.isBuff then
                        if GameTooltip.SetUnitBuffByAuraInstanceID then
                            GameTooltip:SetUnitBuffByAuraInstanceID(parent.unit, self.auraInstanceID)
                        end
                    else
                        if GameTooltip.SetUnitDebuffByAuraInstanceID then
                            GameTooltip:SetUnitDebuffByAuraInstanceID(parent.unit, self.auraInstanceID)
                        end
                    end
                end)
                GameTooltip:Show()
            end
        end)
        icon:SetScript("OnLeave", function() GameTooltip:Hide() end)
        
        icon:Hide()
        return icon
    end
    
    frame.buffsContainer = CreateFrame("Frame", frameName .. "_Buffs", frame)
    frame.buffsContainer:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.buffsContainer:SetSize(100, 20)
    frame.buffsContainer.unit = unit
    frame.buffsContainer.icons = {}
    frame.buffsContainer.isBuff = true
    for i = 1, 8 do
        frame.buffsContainer.icons[i] = CreateRaidAuraIcon(frame.buffsContainer, i)
    end
    
    frame.debuffsContainer = CreateFrame("Frame", frameName .. "_Debuffs", frame)
    frame.debuffsContainer:SetFrameLevel(frame:GetFrameLevel() + 15)
    frame.debuffsContainer:SetSize(100, 20)
    frame.debuffsContainer.unit = unit
    frame.debuffsContainer.icons = {}
    frame.debuffsContainer.isBuff = false
    for i = 1, 8 do
        frame.debuffsContainer.icons[i] = CreateRaidAuraIcon(frame.debuffsContainer, i)
    end
    
    frame.unit = unit
    frame.index = index
    frame.sizeType = sizeType
    
    -- Tooltip
    frame:SetScript("OnEnter", function(self)
        GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
        local showTooltip = false
        
        local isTestMode = (self.sizeType == "small" and simulateRaidSmall) or 
                           (self.sizeType == "large" and simulateRaidLarge)
        if isTestMode then
            local simData = SIMULATED_RAID[self.index]
            if simData then
                local classColor = RAID_CLASS_COLORS[simData.class]
                if classColor then
                    GameTooltip:AddLine(simData.name, classColor.r, classColor.g, classColor.b)
                else
                    GameTooltip:AddLine(simData.name, 1, 1, 1)
                end
                GameTooltip:AddLine("Group " .. simData.group, 0.7, 0.7, 0.7)
                showTooltip = true
            end
        elseif UnitExists(self.unit) then
            local name = UnitName(self.unit) or "Unknown"
            local _, class = UnitClass(self.unit)
            local classColor = class and RAID_CLASS_COLORS[class]
            if classColor then
                GameTooltip:AddLine(name, classColor.r, classColor.g, classColor.b)
            else
                GameTooltip:AddLine(name, 1, 1, 1)
            end
            showTooltip = true
        end
        
        if showTooltip then
            GameTooltip:Show()
        end
    end)
    frame:SetScript("OnLeave", function() GameTooltip:Hide() end)
    
    frame:Hide()
    memberFrames[index] = frame
    return frame
end

function UnitFrames:UpdateRaidMemberFrame(sizeType, index)
    local memberFrames = sizeType == "small" and raidSmallMemberFrames or raidLargeMemberFrames
    local frame = memberFrames[index]
    if not frame then return end
    
    local rs = settings.raid
    if not rs then return end
    
    local layoutSettings = rs[sizeType]
    if not layoutSettings then return end
    
    -- Check the appropriate simulation flag for this size type
    local isTestMode = (sizeType == "small" and simulateRaidSmall) or 
                       (sizeType == "large" and simulateRaidLarge)
    local simData = isTestMode and SIMULATED_RAID[index] or nil
    local unit = frame.unit
    local unitExists = UnitExists(unit) or (isTestMode and simData)
    
    if not unitExists then
        if not InCombatLockdown() then
            frame:Hide()
        end
        return
    end
    
    if not InCombatLockdown() then
        frame:Show()
    end
    
    -- Update frame visual layout based on current settings
    local mf = layoutSettings.frame
    
    -- Update frame background/border
    if mf.showBackground then
        frame:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8x8",
            edgeFile = mf.showBorder and "Interface\\Buttons\\WHITE8x8" or nil,
            edgeSize = mf.borderSize or 1,
        })
        frame:SetBackdropColor(mf.bgColor[1], mf.bgColor[2], mf.bgColor[3], mf.bgColor[4])
        if mf.showBorder then
            frame:SetBackdropBorderColor(mf.borderColor[1], mf.borderColor[2], mf.borderColor[3], mf.borderColor[4])
        end
    else
        frame:SetBackdrop(nil)
    end
    
    -- Update health bar size and position
    frame.healthBar:ClearAllPoints()
    frame.healthBar:SetPoint("TOPLEFT", 1, -1)
    frame.healthBar:SetPoint("TOPRIGHT", -1, -1)
    frame.healthBar:SetHeight(layoutSettings.healthBar.height)
    
    -- Update power bar size and position
    frame.powerBar:ClearAllPoints()
    frame.powerBar:SetPoint("TOPLEFT", frame.healthBar, "BOTTOMLEFT", 0, -1)
    frame.powerBar:SetPoint("TOPRIGHT", frame.healthBar, "BOTTOMRIGHT", 0, -1)
    frame.powerBar:SetHeight(layoutSettings.powerBar.height)
    
    -- Update text fonts
    frame.nameText:SetFont(GetFontPath(DEFAULT_FONT), layoutSettings.nameText.fontSize, GetFontOutline(layoutSettings.nameText.fontOutline))
    frame.healthText:SetFont(GetFontPath(DEFAULT_FONT), layoutSettings.healthText.fontSize, GetFontOutline(layoutSettings.healthText.fontOutline))
    
    -- Get unit data
    local name, class, role, powerType
    
    if isTestMode and simData then
        name = simData.name or "Unknown"
        class = simData.class or "WARRIOR"
        role = simData.role or "NONE"
        powerType = simData.powerType or 0
    elseif UnitExists(unit) then
        name = UnitName(unit) or "Unknown"
        _, class = UnitClass(unit)
        class = class or "WARRIOR"
        role = UnitGroupRolesAssigned(unit) or "NONE"
        powerType = UnitPowerType(unit) or 0
    end
    
    -- Update health bar - just pass value straight through
    frame.healthBar:SetMinMaxValues(0, 100)
    local healthPct
    if isTestMode and simData then
        healthPct = (simData.maxHealth > 0) and ((simData.health / simData.maxHealth) * 100) or 100
    else
        -- Use SafeUnitHealthPercent for Midnight compatibility
        healthPct = SafeUnitHealthPercent(unit, true) or 100
    end
    -- Use smooth animation if available (Midnight Beta 3+)
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    -- Health bar color
    local classColor = RAID_CLASS_COLORS[class]
    if layoutSettings.healthBar.colorMode == "class" and classColor then
        frame.healthBar:SetStatusBarColor(classColor.r, classColor.g, classColor.b)
    elseif layoutSettings.healthBar.colorMode == "health" then
        -- Health-based color - use Midnight curve if available
        if isTestMode and simData and simData.maxHealth > 0 then
            local pct = simData.health / simData.maxHealth
            frame.healthBar:SetStatusBarColor(1 - pct, pct, 0)
        else
            -- Try using Midnight health gradient curve
            local r, g, b = GetHealthGradientColorMidnight(unit, nil)
            frame.healthBar:SetStatusBarColor(r, g, b)
        end
    else
        local c = layoutSettings.healthBar.customColor or {0.2, 0.8, 0.2, 1}
        frame.healthBar:SetStatusBarColor(c[1], c[2], c[3])
    end
    
    -- Update power bar - pass values directly to StatusBar
    if layoutSettings.powerBar.enabled then
        frame.powerBar:Show()
        local power, maxPower
        if isTestMode and simData then
            power = simData.power or 0
            maxPower = simData.maxPower or 1
        else
            power = UnitPower(unit)
            maxPower = UnitPowerMax(unit)
        end
        frame.powerBar:SetMinMaxValues(0, maxPower)
        -- Use smooth animation if available (Midnight Beta 3+)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
        
        local powerColor = PowerBarColor[powerType] or {r = 0.2, g = 0.2, b = 0.8}
        frame.powerBar:SetStatusBarColor(powerColor.r, powerColor.g, powerColor.b)
    else
        frame.powerBar:Hide()
    end
    
    -- Update name text
    if layoutSettings.nameText.enabled then
        local displayName = name
        if layoutSettings.nameText.maxLength and layoutSettings.nameText.maxLength > 0 and #displayName > layoutSettings.nameText.maxLength then
            displayName = displayName:sub(1, layoutSettings.nameText.maxLength)
        end
        frame.nameText:SetText(displayName)
        
        if layoutSettings.nameText.colorMode == "class" and classColor then
            frame.nameText:SetTextColor(classColor.r, classColor.g, classColor.b)
        else
            frame.nameText:SetTextColor(1, 1, 1)
        end
        frame.nameText:Show()
    else
        frame.nameText:Hide()
    end
    
    -- Update health text
    if layoutSettings.healthText.enabled then
        -- Use helper function for Midnight Beta compatibility
        local unit = frame.unit
        frame.healthText:SetText(FormatHealthTextMidnight(unit, layoutSettings.healthText.format, health, maxHealth))
        frame.healthText:Show()
    else
        frame.healthText:Hide()
    end
    
    -- Update role icon
    if layoutSettings.roleIcon.enabled and role and role ~= "NONE" then
        local atlasOptions = {
            TANK = {"roleicon-guardian", "roleicon-tank", "UI-LFG-RoleIcon-Tank"},
            HEALER = {"roleicon-healer", "UI-LFG-RoleIcon-Healer"},
            DAMAGER = {"roleicon-damage", "UI-LFG-RoleIcon-DPS"},
        }
        local options = atlasOptions[role]
        local atlasSet = false
        if options then
            for _, atlasName in ipairs(options) do
                local success = pcall(function()
                    frame.roleIcon:SetAtlas(atlasName, true)
                end)
                if success then
                    local currentAtlas = frame.roleIcon:GetAtlas()
                    if currentAtlas and currentAtlas ~= "" then
                        atlasSet = true
                        break
                    end
                end
            end
        end
        if atlasSet then
            frame.roleIcon:Show()
            if frame.roleIconFrame then frame.roleIconFrame:Show() end
        else
            frame.roleIcon:Hide()
            if frame.roleIconFrame then frame.roleIconFrame:Hide() end
        end
    else
        if frame.roleIcon then frame.roleIcon:Hide() end
        if frame.roleIconFrame then frame.roleIconFrame:Hide() end
    end
    
    -- Update raid target
    local raidTargetIndex = isTestMode and (index % 8 == 0 and (index / 8) or nil) or GetRaidTargetIndex(unit)
    if layoutSettings.raidTarget.enabled and raidTargetIndex then
        SetRaidTargetIconTexture(frame.raidTarget, raidTargetIndex)
        frame.raidTargetFrame:Show()
    else
        frame.raidTargetFrame:Hide()
    end
    
    -- Update debuff indicators (Midnight: colored boxes)
    -- Show during simulation even if disabled (so user can preview layout)
    local showDebuffIndicators = layoutSettings.debuffIndicators and (layoutSettings.debuffIndicators.enabled or isTestMode)
    if showDebuffIndicators then
        -- Hide legacy type-specific indicators
        for _, indicator in pairs(frame.debuffIndicators) do
            indicator:Hide()
        end
        
        local diSize = layoutSettings.debuffIndicators.size or 10
        
        if isTestMode and simData and simData.debuffType then
            -- Simulation mode - show simulated type indicator
            local indicator = frame.debuffIndicators[simData.debuffType]
            if indicator then
                local diStyle = layoutSettings.debuffIndicators.style or "squares"
                UpdateDebuffIndicatorStyle(indicator, diStyle, diSize)
                indicator:SetAlpha(1)
                indicator:ClearAllPoints()
                indicator:SetPoint("RIGHT", frame.debuffContainer, "RIGHT", 0, 0)
                indicator:Show()
            end
        else
            -- Use helper function for colored boxes
            UpdateDispelBoxes(frame, unit, diSize, 5, layoutSettings.debuffIndicators.onlyPlayerDispellable)
        end
    end
    
    -- Update cast bar
    local showRaidPreview = isTestMode and frame.castBar and layoutSettings.castBar
    if (frame.castBar and layoutSettings.castBar and layoutSettings.castBar.enabled) or showRaidPreview then
        local unitID = unit
        local cbs = layoutSettings.castBar
        
        -- Handle simulation mode
        if isTestMode and not UnitExists(unitID) then
            -- Show a simulated cast bar on the first frame only
            if frame.index == 1 then
                frame.castBar:SetMinMaxValues(0, 3)
                frame.castBar:SetValue(1.5)
                if frame.castText then 
                    if not cbs or cbs.showSpellName then
                        frame.castText:SetText("Simulated Cast")
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                if frame.castTimer then 
                    if not cbs or cbs.showTimer then
                        frame.castTimer:SetText("1.5")
                        frame.castTimer:Show()
                    else
                        frame.castTimer:Hide()
                    end
                end
                if frame.castIcon then 
                    if not cbs or cbs.showIcon then
                        frame.castIcon:SetTexture("Interface\\Icons\\Spell_Nature_Heal")
                        frame.castIcon:Show()
                    else
                        frame.castIcon:Hide()
                    end
                end
                frame.castBar:SetStatusBarColor(1, 0.7, 0, 1)
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        else
            -- Real cast bar update (v2.1.3 - SetTimerDuration for secrets)
            local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unitID)
            local isChannel = false
            local isEmpowered = false
            local numEmpowerStages = nil
            if not castName then
                -- Check for empowered spell using event-driven flag
                if frame.isEmpoweredCast and frame.empowerSpellID then
                    if C_Spell and C_Spell.GetSpellInfo then
                        local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                        if success and spellInfo and spellInfo.name then
                            local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unitID)
                            if chStart and chEnd then
                                castName = spellInfo.name
                                startTime = chStart
                                endTime = chEnd
                                spellID = frame.empowerSpellID
                                notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                                isEmpowered = true
                                isChannel = false
                                numEmpowerStages = GetEmpowerNumStages(unitID) or 3
                            end
                        end
                    end
                end
                
                if not isEmpowered then
                    castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unitID)
                    isChannel = true
                    frame.empowerSpellID = nil
                    frame.isEmpoweredCast = false
                end
            else
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
            
            -- Setup/hide empowered dividers
            if isEmpowered then
                local safeStages = numEmpowerStages or 3
                if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
                if safeStages >= 2 then
                    SetupEmpowerDividers(frame.castBar, unitID, safeStages)
                else
                    HideEmpowerDividers(frame.castBar)
                end
            else
                HideEmpowerDividers(frame.castBar)
            end
            
            local castBarSetup = false
            
            -- Try SetTimerDuration (handles secrets)
            if castName and HAS_TIMER_BARS then
                local durationObj = nil
                if isEmpowered and UnitEmpoweredChannelDuration then
                    local ok, obj = pcall(UnitEmpoweredChannelDuration, unitID, true)
                    if ok and obj then durationObj = obj end
                elseif isChannel and UnitChannelDuration then
                    local ok, obj = pcall(UnitChannelDuration, unitID)
                    if ok and obj then durationObj = obj end
                elseif not isChannel and UnitCastingDuration then
                    local ok, obj = pcall(UnitCastingDuration, unitID)
                    if ok and obj then durationObj = obj end
                end
                
                if durationObj then
                    frame.castBar:SetMinMaxValues(0, 1)
                    local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                    if ok then
                        castBarSetup = true
                        frame.castBarDurationObject = durationObj
                        frame.castBarUseTimerBar = true
                    end
                end
            end
            
            -- Traditional fallback
            if not castBarSetup then
                local safeCastName = SafeValue(castName)
                local safeStartTime = SafeNumber(startTime)
                local safeEndTime = SafeNumber(endTime)
                
                if safeCastName and safeStartTime and safeEndTime then
                    local duration = (safeEndTime - safeStartTime) / 1000
                    local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                    frame.castBar:SetMinMaxValues(0, duration)
                    
                    if isChannel then
                        frame.castBar:SetValue(duration - elapsed)
                    else
                        frame.castBar:SetValue(elapsed)
                    end
                    
                    if frame.castTimer and cbs.showTimer then
                        frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                        frame.castTimer:Show()
                    end
                    
                    castBarSetup = true
                end
            end
            
            if castBarSetup then
                -- Spell name
                if frame.castText then
                    if cbs.showSpellName then
                        local safeCastName = SafeValue(castName)
                        if safeCastName then
                            frame.castText:SetText(safeCastName)
                        elseif castName then
                            local ok, text = pcall(string.format, "%s", castName)
                            if ok and text then frame.castText:SetText(text) end
                        end
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                
                -- Icon
                if frame.castIcon then
                    if cbs.showIcon then
                        local safeSpellID = SafeNumber(spellID)
                        if safeSpellID then
                            local spellTexture = GetSpellTextureByID(safeSpellID)
                            if spellTexture then
                                frame.castIcon:SetTexture(spellTexture)
                                frame.castIcon:Show()
                            end
                        elseif spellID then
                            pcall(function()
                                local spellTexture = GetSpellTextureByID(spellID)
                                if spellTexture then
                                    frame.castIcon:SetTexture(spellTexture)
                                    frame.castIcon:Show()
                                end
                            end)
                        end
                    else
                        frame.castIcon:Hide()
                    end
                end
                
                -- Timer text for timer bar mode
                if frame.castBarUseTimerBar and frame.castTimer and cbs.showTimer then
                    local safeRemaining = nil
                    if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                        local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                        if ok and r then safeRemaining = r end
                    end
                    if safeRemaining then
                        local ok, text = pcall(string.format, "%.1f", safeRemaining)
                        if ok and text then frame.castTimer:SetText(text) end
                    end
                    frame.castTimer:Show()
                end
                
                -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
                local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
                local safeSpellID = SafeNumber(spellID)
                local isImportant = false
                if TweaksUI.SpellAPI and safeSpellID then
                    isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
                end
                if isImportant then
                    if isChannel then
                        baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                    else
                        baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                    end
                elseif isChannel then
                    baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
                end
                ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
                
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        end
    elseif frame.castBar then
        frame.castBar:Hide()
        if frame.castText then frame.castText:Hide() end
        if frame.castTimer then frame.castTimer:Hide() end
        if frame.castIcon then frame.castIcon:Hide() end
    end
    
    -- Update Summon Indicator
    local sumSettings = layoutSettings.summonIndicator
    if sumSettings and sumSettings.enabled and frame.summonFrame and frame.summonIndicator then
        local summonStatus
        
        if isTestMode then
            -- Simulate pending summon for preview (on first few frames)
            summonStatus = (index <= 2) and 1 or 0
        else
            summonStatus = C_IncomingSummon and C_IncomingSummon.IncomingSummonStatus and C_IncomingSummon.IncomingSummonStatus(unit) or 0
        end
        
        -- Enum.SummonStatus: None=0, Pending=1, Accepted=2, Declined=3
        if summonStatus == 1 then  -- Pending
            local r, g, b, a = unpack(sumSettings.pendingColor or {1, 0.8, 0, 1})
            frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonPending")
            frame.summonIndicator:SetVertexColor(r, g, b, a)
            frame.summonFrame:Show()
        elseif summonStatus == 2 then  -- Accepted
            local r, g, b, a = unpack(sumSettings.acceptedColor or {0, 1, 0, 1})
            frame.summonIndicator:SetTexture("Interface\\RaidFrame\\Raid-Icon-SummonAccepted")
            frame.summonIndicator:SetVertexColor(r, g, b, a)
            frame.summonFrame:Show()
        else
            frame.summonFrame:Hide()
        end
    elseif frame.summonFrame then
        frame.summonFrame:Hide()
    end
    
    -- Update defensive icon
    local DefensiveIcons = TweaksUI.DefensiveIcons
    if DefensiveIcons and layoutSettings.defensiveIcon then
        DefensiveIcons:UpdateDefensiveIcon(frame, layoutSettings.defensiveIcon)
    end
    
    -- Update dispel overlay
    local DispelOverlay = TweaksUI.DispelOverlay
    if DispelOverlay and layoutSettings.dispelOverlay then
        DispelOverlay:UpdateOverlay(frame, layoutSettings.dispelOverlay)
    end
    
    -- Update threat overlay
    local ThreatOverlay = TweaksUI.ThreatOverlay
    if ThreatOverlay and layoutSettings.threatOverlay then
        ThreatOverlay:UpdateOverlay(frame, layoutSettings.threatOverlay)
    end
    
    -- ========================================================================
    -- UPDATE AURAS (buffs/debuffs) - inline like party/target frames
    -- ========================================================================
    
    local function UpdateRaidAuraContainer(container, auraSettings, unitToken, isBuff)
        if not container or not auraSettings or not auraSettings.enabled then
            if container then container:Hide() end
            return
        end
        
        container:Show()
        container.unit = unitToken
        
        local maxAuras = auraSettings.maxAuras or 4
        local iconSize = auraSettings.size or 14
        local spacing = auraSettings.spacing or 1
        local growDir = auraSettings.growDirection or "RIGHT"
        local filter = auraSettings.filter or (isBuff and "HELPFUL" or "HARMFUL")
        local hidePermanent = auraSettings.hidePermanent
        
        for i, icon in ipairs(container.icons) do
            icon:Hide()
            icon.auraInstanceID = nil
        end
        
        -- In test mode, show placeholder auras
        if isTestMode and not UnitExists(unitToken) then
            local numSimAuras = isBuff and 2 or 1
            for i = 1, math.min(numSimAuras, maxAuras) do
                local icon = container.icons[i]
                if icon then
                    icon.texture:SetTexture(isBuff and "Interface\\Icons\\Spell_Holy_WordFortitude" or "Interface\\Icons\\Spell_Shadow_CurseOfTounges")
                    icon:SetSize(iconSize, iconSize)
                    icon:ClearAllPoints()
                    local offset = (i - 1) * (iconSize + spacing)
                    if growDir == "RIGHT" then
                        icon:SetPoint("LEFT", container, "LEFT", offset, 0)
                    elseif growDir == "LEFT" then
                        icon:SetPoint("RIGHT", container, "RIGHT", -offset, 0)
                    end
                    icon.cooldown:Hide()
                    icon.stackText:Hide()
                    icon.durationText:Hide()
                    icon:Show()
                end
            end
            return
        end
        
        -- Reuse cache table instead of allocating new one (PERFORMANCE)
        wipe(raidAuraCache)
        local auras = raidAuraCache
        
        if HAS_AURA_SORTING and C_UnitAuras.GetUnitAuraInstanceIDs then
            local sortRuleStr = auraSettings.sortRule or "Default"
            local sortDirStr = auraSettings.sortDirection or "Normal"
            local sortRule = Enum.UnitAuraSortRule[sortRuleStr] or Enum.UnitAuraSortRule.Default
            local sortDirection = Enum.UnitAuraSortDirection and Enum.UnitAuraSortDirection[sortDirStr] or nil
            
            local success, auraIDs = pcall(function()
                return C_UnitAuras.GetUnitAuraInstanceIDs(unitToken, filter, maxAuras, sortRule, sortDirection)
            end)
            
            if success and auraIDs then
                for _, auraID in ipairs(auraIDs) do
                    -- Direct API call - returns nil or aura data, no closure allocation
                    local auraData = C_UnitAuras.GetAuraDataByAuraInstanceID(unitToken, auraID)
                    if auraData then
                        table.insert(auras, auraData)
                    end
                end
            end
        end
        
        if #auras == 0 and AuraUtil and AuraUtil.ForEachAura then
            pcall(function()
                AuraUtil.ForEachAura(unitToken, filter, maxAuras, function(aura)
                    if aura then table.insert(auras, aura) end
                    if #auras >= maxAuras then return true end
                    return false
                end, true)
            end)
        end
        
        if #auras == 0 and C_UnitAuras and C_UnitAuras.GetAuraDataByIndex then
            for i = 1, maxAuras do
                local success, aura = pcall(function()
                    return C_UnitAuras.GetAuraDataByIndex(unitToken, i, filter)
                end)
                if success and aura then
                    table.insert(auras, aura)
                else
                    break
                end
            end
        end
        
        for i, auraData in ipairs(auras) do
            if i > maxAuras then break end
            
            local icon = container.icons[i]
            if icon and auraData then
                icon.auraInstanceID = auraData.auraInstanceID
                
                if hidePermanent and auraData.auraInstanceID and C_UnitAuras.DoesAuraHaveExpirationTime then
                    pcall(function()
                        local hasExpiration = C_UnitAuras.DoesAuraHaveExpirationTime(unitToken, auraData.auraInstanceID)
                        if icon.SetAlphaFromBoolean then
                            icon:SetAlphaFromBoolean(hasExpiration, 1.0, 0.0)
                        end
                    end)
                else
                    icon:SetAlpha(1.0)
                end
                
                local textureSet = false
                pcall(function()
                    icon.texture:SetTexture(auraData.icon)
                    icon.texture:SetVertexColor(1, 1, 1, 1)
                    textureSet = true
                end)
                
                if not textureSet then
                    icon:Hide()
                else
                    icon:SetSize(iconSize, iconSize)
                    
                    if auraSettings.showDuration ~= false then
                        local cooldownSet = false
                        if auraData.auraInstanceID then
                            cooldownSet = TweaksUI.API.SetCooldownFromAura(icon.cooldown, unitToken, auraData.auraInstanceID)
                        end
                        if cooldownSet then
                            icon.cooldown:Show()
                            local sweepAlpha = auraSettings.sweepAlpha or 1.0
                            icon.cooldown:SetAlpha(sweepAlpha)
                            -- Apply duration font size to Blizzard's countdown text
                            API.ApplyCooldownTextSettings(icon.cooldown, auraSettings.durationFontSize or 10, auraSettings.durationColor, auraSettings.durationAnchor, auraSettings.durationOffsetX, auraSettings.durationOffsetY)
                        else
                            icon.cooldown:Hide()
                        end
                    else
                        icon.cooldown:Hide()
                    end
                    
                    -- Duration text is now handled by Blizzard's CooldownFrameTemplate
                    -- with SetHideCountdownNumbers(false) - works with secret values
                    if icon.durationText then
                        icon.durationText:Hide()
                    end
                    
                    if auraSettings.showStacks then
                        local stackShown = false
                        -- Apply stack font size from settings
                        icon.stackText:SetFont(GetFontPath(DEFAULT_FONT), auraSettings.stackFontSize or 10, GetFontOutline())
                        if auraData.auraInstanceID and C_UnitAuras and C_UnitAuras.GetAuraApplicationDisplayCount then
                            pcall(function()
                                local countText = C_UnitAuras.GetAuraApplicationDisplayCount(unitToken, auraData.auraInstanceID, 2)
                                icon.stackText:SetText(countText or "")
                                icon.stackText:Show()
                                stackShown = true
                            end)
                        end
                        if not stackShown then
                            icon.stackText:Hide()
                        end
                    else
                        icon.stackText:Hide()
                    end
                    
                    icon:ClearAllPoints()
                    local offset = (i - 1) * (iconSize + spacing)
                    if growDir == "RIGHT" then
                        icon:SetPoint("LEFT", container, "LEFT", offset, 0)
                    elseif growDir == "LEFT" then
                        icon:SetPoint("RIGHT", container, "RIGHT", -offset, 0)
                    elseif growDir == "DOWN" then
                        icon:SetPoint("TOP", container, "TOP", 0, -offset)
                    elseif growDir == "UP" then
                        icon:SetPoint("BOTTOM", container, "BOTTOM", 0, offset)
                    end
                    
                    icon:Show()
                end
            end
        end
    end
    
    if frame.buffsContainer and layoutSettings.buffs then
        if layoutSettings.buffs.enabled then
            frame.buffsContainer:ClearAllPoints()
            local anchor = layoutSettings.buffs.anchor or "BOTTOMLEFT"
            local frameAnchor = layoutSettings.buffs.frameAnchor or "TOPLEFT"
            local xOff = layoutSettings.buffs.offsetX or 0
            local yOff = layoutSettings.buffs.offsetY or 1
            frame.buffsContainer:SetPoint(anchor, frame, frameAnchor, xOff, yOff)
            UpdateRaidAuraContainer(frame.buffsContainer, layoutSettings.buffs, unit, true)
        else
            frame.buffsContainer:Hide()
        end
    end
    
    if frame.debuffsContainer and layoutSettings.debuffs then
        if layoutSettings.debuffs.enabled then
            frame.debuffsContainer:ClearAllPoints()
            local anchor = layoutSettings.debuffs.anchor or "TOPLEFT"
            local frameAnchor = layoutSettings.debuffs.frameAnchor or "BOTTOMLEFT"
            local xOff = layoutSettings.debuffs.offsetX or 0
            local yOff = layoutSettings.debuffs.offsetY or -1
            frame.debuffsContainer:SetPoint(anchor, frame, frameAnchor, xOff, yOff)
            UpdateRaidAuraContainer(frame.debuffsContainer, layoutSettings.debuffs, unit, false)
        else
            frame.debuffsContainer:Hide()
        end
    end
end

-- ============================================================================
-- OPTIMIZED DATA-ONLY UPDATE FOR RAID FRAMES (Performance critical)
-- ============================================================================
-- This function ONLY updates dynamic data (health, power, debuffs, cast bars)
-- It does NOT update layout, fonts, backdrops, or positions
-- Called on frequent events like UNIT_HEALTH, UNIT_AURA
-- The full UpdateRaidMemberFrame should only be called on settings changes

function UnitFrames:UpdateRaidMemberDataOnly(sizeType, index)
    local memberFrames = sizeType == "small" and raidSmallMemberFrames or raidLargeMemberFrames
    local frame = memberFrames[index]
    if not frame then return end
    
    local rs = settings and settings.raid
    if not rs then return end
    
    local layoutSettings = rs[sizeType]
    if not layoutSettings then return end
    
    local unit = frame.unit
    
    -- Quick exit if unit doesn't exist
    if not UnitExists(unit) then
        return
    end
    
    -- ========================================================================
    -- HEALTH BAR UPDATE (most frequent)
    -- ========================================================================
    local healthPct = SafeUnitHealthPercent(unit, true) or 100
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    -- Health bar color (only gradient needs recalculation)
    if layoutSettings.healthBar.colorMode == "health" then
        local r, g, b = GetHealthGradientColorMidnight(unit, nil)
        frame.healthBar:SetStatusBarColor(r, g, b)
    end
    -- Class/custom colors don't change, skip them
    
    -- ========================================================================
    -- POWER BAR UPDATE
    -- ========================================================================
    if layoutSettings.powerBar.enabled then
        local power = UnitPower(unit)
        local maxPower = UnitPowerMax(unit)
        frame.powerBar:SetMinMaxValues(0, maxPower)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
    end
    
    -- ========================================================================
    -- HEALTH TEXT UPDATE
    -- ========================================================================
    if layoutSettings.healthText.enabled then
        frame.healthText:SetText(FormatHealthTextMidnight(unit, layoutSettings.healthText.format, nil, nil))
    end
    
    -- ========================================================================
    -- DEBUFF INDICATORS UPDATE (Midnight: colored boxes)
    -- ========================================================================
    if layoutSettings.debuffIndicators and layoutSettings.debuffIndicators.enabled then
        -- Hide legacy type-specific indicators
        if frame.debuffIndicators then
            for _, indicator in pairs(frame.debuffIndicators) do
                indicator:Hide()
            end
        end
        
        -- Use helper function for colored boxes
        local diSize = layoutSettings.debuffIndicators.size or 10
        UpdateDispelBoxes(frame, unit, diSize, 5, layoutSettings.debuffIndicators.onlyPlayerDispellable)
    end
    
    -- ========================================================================
    -- CAST BAR UPDATE (v2.1.3 - SetTimerDuration for secret values)
    -- ========================================================================
    if frame.castBar and layoutSettings.castBar and layoutSettings.castBar.enabled then
        local cbs = layoutSettings.castBar
        local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unit)
        local isChannel = false
        local isEmpowered = false
        local numEmpowerStages = nil
        if not castName then
            -- Check for empowered spell using event-driven flag
            if frame.isEmpoweredCast and frame.empowerSpellID then
                if C_Spell and C_Spell.GetSpellInfo then
                    local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                    if success and spellInfo and spellInfo.name then
                        local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unit)
                        if chStart and chEnd then
                            castName = spellInfo.name
                            startTime = chStart
                            endTime = chEnd
                            spellID = frame.empowerSpellID
                            isEmpowered = true
                            notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                            isChannel = false
                            numEmpowerStages = GetEmpowerNumStages(unit) or 3
                        end
                    end
                end
            end
            
            if not isEmpowered then
                castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unit)
                isChannel = true
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
        else
            frame.empowerSpellID = nil
            frame.isEmpoweredCast = false
        end
        
        -- Setup/hide empowered dividers
        if isEmpowered then
            local safeStages = numEmpowerStages or 3
            if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
            if safeStages >= 2 then
                SetupEmpowerDividers(frame.castBar, unit, safeStages)
            else
                HideEmpowerDividers(frame.castBar)
            end
        else
            HideEmpowerDividers(frame.castBar)
        end
        
        local castBarSetup = false
        
        -- Try SetTimerDuration for raid members (handles secrets)
        if castName and HAS_TIMER_BARS then
            local durationObj = nil
            if isEmpowered and UnitEmpoweredChannelDuration then
                local ok, obj = pcall(UnitEmpoweredChannelDuration, unit, true)
                if ok and obj then durationObj = obj end
            elseif isChannel and UnitChannelDuration then
                local ok, obj = pcall(UnitChannelDuration, unit)
                if ok and obj then durationObj = obj end
            elseif not isChannel and UnitCastingDuration then
                local ok, obj = pcall(UnitCastingDuration, unit)
                if ok and obj then durationObj = obj end
            end
            
            if durationObj then
                frame.castBar:SetMinMaxValues(0, 1)
                local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                if ok then
                    castBarSetup = true
                    frame.castBarDurationObject = durationObj
                    frame.castBarUseTimerBar = true
                end
            end
        end
        
        -- Traditional fallback
        if not castBarSetup then
            local safeCastName = SafeValue(castName)
            local safeStartTime = SafeNumber(startTime)
            local safeEndTime = SafeNumber(endTime)
            
            if safeCastName and safeStartTime and safeEndTime then
                local duration = (safeEndTime - safeStartTime) / 1000
                local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                frame.castBar:SetMinMaxValues(0, duration)
                
                if isChannel then
                    frame.castBar:SetValue(duration - elapsed)
                else
                    frame.castBar:SetValue(elapsed)
                end
                
                if frame.castTimer and cbs.showTimer then
                    frame.castTimer:SetText(format("%.1f", duration - elapsed))
                end
                
                castBarSetup = true
            end
        end
        
        if castBarSetup then
            -- Spell name
            if frame.castText and cbs.showSpellName then
                local safeCastName = SafeValue(castName)
                if safeCastName then
                    frame.castText:SetText(safeCastName)
                elseif castName then
                    local ok, text = pcall(string.format, "%s", castName)
                    if ok and text then frame.castText:SetText(text) end
                end
            end
            
            -- Timer text for timer bar mode
            if frame.castBarUseTimerBar and frame.castTimer and cbs.showTimer then
                local safeRemaining = nil
                if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                    local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                    if ok and r then safeRemaining = r end
                end
                if safeRemaining then
                    local ok, text = pcall(string.format, "%.1f", safeRemaining)
                    if ok and text then frame.castTimer:SetText(text) end
                end
            end
            
            -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
            local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
            local safeSpellID = SafeNumber(spellID)
            local isImportant = false
            if TweaksUI.SpellAPI and safeSpellID then
                isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
            end
            if isImportant then
                if isChannel then
                    baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                else
                    baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                end
            elseif isChannel then
                baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
            end
            ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
            
            frame.castBar:Show()
        else
            frame.castBar:Hide()
            if frame.castText then frame.castText:Hide() end
            if frame.castTimer then frame.castTimer:Hide() end
        end
    end
    
    -- ========================================================================
    -- OVERLAY UPDATES (only if modules exist)
    -- ========================================================================
    -- Defensive icon
    local DefensiveIcons = TweaksUI.DefensiveIcons
    if DefensiveIcons and layoutSettings.defensiveIcon then
        DefensiveIcons:UpdateDefensiveIcon(frame, layoutSettings.defensiveIcon)
    end
    
    -- Dispel overlay
    local DispelOverlay = TweaksUI.DispelOverlay
    if DispelOverlay and layoutSettings.dispelOverlay then
        DispelOverlay:UpdateOverlay(frame, layoutSettings.dispelOverlay)
    end
    
    -- Threat overlay
    local ThreatOverlay = TweaksUI.ThreatOverlay
    if ThreatOverlay and layoutSettings.threatOverlay then
        ThreatOverlay:UpdateOverlay(frame, layoutSettings.threatOverlay)
    end
end

-- Update all visible raid members (data only, no layout)
function UnitFrames:UpdateAllRaidMemberData()
    if not settings or not settings.raid or not settings.raid.enabled then return end
    if not IsInRaid() then return end
    
    local raidSize = GetNumGroupMembers()
    local threshold = settings.raid.sizeThreshold or 20
    local sizeType = raidSize <= threshold and "small" or "large"
    local memberFrames = sizeType == "small" and raidSmallMemberFrames or raidLargeMemberFrames
    
    for i = 1, raidSize do
        local frame = memberFrames[i]
        if frame and frame:IsShown() then
            self:UpdateRaidMemberDataOnly(sizeType, i)
        end
    end
end

function UnitFrames:UpdateRaidFrames()
    if not settings then return end
    local rs = settings.raid
    if not rs then return end
    
    -- Check if any simulation/preview is active
    local anySimulating = simulateRaidSmall or simulateRaidLarge
    
    -- If not enabled AND not simulating, hide both containers and return
    if not rs.enabled and not anySimulating then
        if not InCombatLockdown() then
            if raidSmallContainer then raidSmallContainer:Hide() end
            if raidLargeContainer then raidLargeContainer:Hide() end
        end
        return
    end
    
    UnitFrames.HideBlizzardRaidFrames()
    
    -- Show preview frames if simulating (even when not in raid)
    if simulateRaidSmall then
        if not raidSmallContainer then
            self:CreateRaidContainer("small")
        end
        if raidSmallContainer and not InCombatLockdown() then
            raidSmallContainer:Show()
        end
        self:UpdateRaidLayoutForSize("small", 20)
    elseif raidSmallContainer and not IsInRaid() then
        if not InCombatLockdown() then
            raidSmallContainer:Hide()
        end
    end
    
    if simulateRaidLarge then
        if not raidLargeContainer then
            self:CreateRaidContainer("large")
        end
        if raidLargeContainer and not InCombatLockdown() then
            raidLargeContainer:Show()
        end
        self:UpdateRaidLayoutForSize("large", 40)
    elseif raidLargeContainer and not IsInRaid() then
        if not InCombatLockdown() then
            raidLargeContainer:Hide()
        end
    end
    
    -- If simulating, we're done
    if anySimulating then
        return
    end
    
    -- Normal operation: only show when in raid
    if not IsInRaid() then
        if not InCombatLockdown() then
            if raidSmallContainer then raidSmallContainer:Hide() end
            if raidLargeContainer then raidLargeContainer:Hide() end
        end
        return
    end
    
    -- Determine raid size and which layout to use
    local raidSize = GetNumGroupMembers()
    local threshold = rs.sizeThreshold or 20
    local sizeType = raidSize <= threshold and "small" or "large"
    
    -- Normal operation: show only the appropriate container
    local activeContainer = sizeType == "small" and raidSmallContainer or raidLargeContainer
    local inactiveContainer = sizeType == "small" and raidLargeContainer or raidSmallContainer
    
    if not InCombatLockdown() then
        if inactiveContainer then inactiveContainer:Hide() end
    end
    
    self:UpdateRaidLayoutForSize(sizeType, raidSize)
end

-- Update layout for a specific size type (small or large)
function UnitFrames:UpdateRaidLayoutForSize(sizeType, raidSize)
    if not settings then return end
    local rs = settings.raid
    if not rs then return end
    
    local layoutSettings = rs[sizeType]
    if not layoutSettings then return end
    
    local container = sizeType == "small" and raidSmallContainer or raidLargeContainer
    local memberFrames = sizeType == "small" and raidSmallMemberFrames or raidLargeMemberFrames
    
    if not container then
        container = self:CreateRaidContainer(sizeType)
        if not container then return end
    end
    
    if not InCombatLockdown() then
        container:Show()
    end
    
    local mf = layoutSettings.frame
    local layout = layoutSettings.layout
    local containerSettings = layoutSettings.container
    
    local spacing = layout.spacing or 2
    local scale = containerSettings.scale or 1.0
    local wrapperKey = "raid_" .. sizeType
    
    if not InCombatLockdown() then
        -- If managed by Layout, only update scale on wrapper, not container position
        if containerWrappers[wrapperKey] then
            container:SetScale(1.0)
            containerWrappers[wrapperKey].frame:SetScale(scale)
        else
            -- Not yet registered with Layout (or Layout not available)
            -- Apply scale and position directly from settings
            container:SetScale(scale)
            container:ClearAllPoints()
            container:SetPoint(containerSettings.anchor or "CENTER", UIParent, containerSettings.anchor or "CENTER", containerSettings.x or 0, containerSettings.y or 0)
        end
    end
    
    local totalWidth, totalHeight = 0, 0
    local maxFrames = sizeType == "small" and 20 or 40
    local displayCount = math.min(raidSize, maxFrames)
    
    -- Handle group-based layouts (GROUP_ROWS, GROUP_COLUMNS, or legacy GROUPS)
    local isGroupMode = (layout.mode == "GROUP_ROWS" or layout.mode == "GROUP_COLUMNS" or layout.mode == "GROUPS")
    
    if isGroupMode then
        local groupSpacing = layout.groupSpacing or 8
        local membersPerRow = layout.membersPerRow or 5
        local memberGrowth = layout.memberGrowth or layout.growthDirection or "DOWN"
        
        -- Determine if we're doing rows of groups or columns of groups
        local isColumnMode = (layout.mode == "GROUP_COLUMNS") or 
                            (layout.mode == "GROUPS" and (layout.groupGrowthDirection == "DOWN" or layout.groupGrowthDirection == "UP"))
        
        local groupsBeforeWrap
        if isColumnMode then
            groupsBeforeWrap = layout.groupsPerColumn or layout.groupsPerRow or 4
        else
            groupsBeforeWrap = layout.groupsPerRow or 4
        end
        
        local numGroups = math.ceil(displayCount / 5)
        
        -- Calculate group dimensions based on member arrangement
        local groupWidth, groupHeight
        if memberGrowth == "DOWN" or memberGrowth == "UP" then
            -- Members arranged in rows within group
            local membersWide = math.min(membersPerRow, 5)
            local membersHigh = math.ceil(5 / membersPerRow)
            groupWidth = membersWide * (mf.width + spacing)
            groupHeight = membersHigh * (mf.height + spacing)
        else
            -- Members arranged in columns within group (RIGHT/LEFT)
            local membersHigh = math.min(membersPerRow, 5)
            local membersWide = math.ceil(5 / membersPerRow)
            groupWidth = membersWide * (mf.width + spacing)
            groupHeight = membersHigh * (mf.height + spacing)
        end
        
        for g = 1, 8 do
            local groupStartIndex = (g - 1) * 5 + 1
            local groupEndIndex = math.min(g * 5, displayCount)
            
            if groupStartIndex <= displayCount then
                -- Calculate group position
                local groupRow, groupCol
                
                if isColumnMode then
                    -- GROUP_COLUMNS: fill vertically first, then wrap to next column
                    -- G1 G3 G5 G7
                    -- G2 G4 G6 G8
                    groupCol = math.floor((g - 1) / groupsBeforeWrap)
                    groupRow = (g - 1) % groupsBeforeWrap
                else
                    -- GROUP_ROWS: fill horizontally first, then wrap to next row
                    -- G1 G2 G3 G4
                    -- G5 G6 G7 G8
                    groupRow = math.floor((g - 1) / groupsBeforeWrap)
                    groupCol = (g - 1) % groupsBeforeWrap
                end
                
                local groupOffsetX = groupCol * (groupWidth + groupSpacing)
                local groupOffsetY = -groupRow * (groupHeight + groupSpacing)
                
                -- Position members within group
                for i = groupStartIndex, groupEndIndex do
                    local frame = memberFrames[i]
                    if frame and not InCombatLockdown() then
                        local memberIndex = i - groupStartIndex
                        local memberRow, memberCol
                        
                        if memberGrowth == "DOWN" or memberGrowth == "UP" then
                            memberRow = math.floor(memberIndex / membersPerRow)
                            memberCol = memberIndex % membersPerRow
                        else
                            memberCol = math.floor(memberIndex / membersPerRow)
                            memberRow = memberIndex % membersPerRow
                        end
                        
                        local x = groupOffsetX + (memberCol * (mf.width + spacing))
                        local y = groupOffsetY - (memberRow * (mf.height + spacing))
                        
                        frame:ClearAllPoints()
                        frame:SetPoint("TOPLEFT", container, "TOPLEFT", x + 2, y - 2)
                        frame:SetSize(mf.width, mf.height)
                    end
                end
            end
        end
        
        -- Calculate total container size
        local groupsAcross, groupsDown
        if isColumnMode then
            groupsDown = math.min(numGroups, groupsBeforeWrap)
            groupsAcross = math.ceil(numGroups / groupsBeforeWrap)
        else
            groupsAcross = math.min(numGroups, groupsBeforeWrap)
            groupsDown = math.ceil(numGroups / groupsBeforeWrap)
        end
        totalWidth = groupsAcross * (groupWidth + groupSpacing)
        totalHeight = groupsDown * (groupHeight + groupSpacing)
    else
        -- GRID mode: arrange all players in a simple grid
        local columns = layout.columns or 5
        local rows = layout.rows  -- nil means auto-calculate
        local growthDir = layout.growthDirection or "DOWN"
        
        -- Auto-calculate rows/columns if one is nil
        if not rows then
            rows = math.ceil(displayCount / columns)
        elseif not columns then
            columns = math.ceil(displayCount / rows)
        end
        
        for i = 1, displayCount do
            local frame = memberFrames[i]
            if frame and not InCombatLockdown() then
                local idx = i - 1
                local row, col
                
                -- Fill direction based on growth
                if growthDir == "DOWN" or growthDir == "UP" then
                    -- Fill columns first, then move to next row
                    row = math.floor(idx / columns)
                    col = idx % columns
                else
                    -- Fill rows first, then move to next column
                    col = math.floor(idx / rows)
                    row = idx % rows
                end
                
                local x, y = 0, 0
                
                if growthDir == "DOWN" then
                    y = -(row * (mf.height + spacing))
                    x = col * (mf.width + spacing)
                elseif growthDir == "UP" then
                    y = row * (mf.height + spacing)
                    x = col * (mf.width + spacing)
                elseif growthDir == "RIGHT" then
                    x = col * (mf.width + spacing)
                    y = -(row * (mf.height + spacing))
                elseif growthDir == "LEFT" then
                    x = -(col * (mf.width + spacing))
                    y = -(row * (mf.height + spacing))
                end
                
                frame:ClearAllPoints()
                frame:SetPoint("TOPLEFT", container, "TOPLEFT", x + 2, y - 2)
                frame:SetSize(mf.width, mf.height)
            end
        end
        
        -- Calculate total container size for GRID mode
        local actualCols = math.min(displayCount, columns)
        local actualRows = math.ceil(displayCount / columns)
        totalWidth = actualCols * (mf.width + spacing) + 4
        totalHeight = actualRows * (mf.height + spacing) + 4
    end
    
    -- Update container size
    if not InCombatLockdown() then
        container:SetSize(math.max(totalWidth, mf.width + 4), math.max(totalHeight, mf.height + 4))
    end
    
    -- Hide frames beyond display count
    for i = displayCount + 1, maxFrames do
        local frame = memberFrames[i]
        if frame and not InCombatLockdown() then
            frame:Hide()
        end
    end
    
    -- Update each visible frame
    for i = 1, displayCount do
        self:UpdateRaidMemberFrame(sizeType, i)
    end
end

function UnitFrames:DestroyRaidContainer()
    if InCombatLockdown() then return end
    
    -- Clean up small container Layout registration
    if containerWrappers["raid_small"] then
        if Layout and Layout.UnregisterElement then
            Layout:UnregisterElement("container_raid_small")
        end
        if containerWrappers["raid_small"].frame then
            containerWrappers["raid_small"].frame:Hide()
        end
        if containerWrappers["raid_small"].Destroy then
            containerWrappers["raid_small"]:Destroy()
        end
        containerWrappers["raid_small"] = nil
    end
    
    -- Clean up large container Layout registration
    if containerWrappers["raid_large"] then
        if Layout and Layout.UnregisterElement then
            Layout:UnregisterElement("container_raid_large")
        end
        if containerWrappers["raid_large"].frame then
            containerWrappers["raid_large"].frame:Hide()
        end
        if containerWrappers["raid_large"].Destroy then
            containerWrappers["raid_large"]:Destroy()
        end
        containerWrappers["raid_large"] = nil
    end
    
    -- Destroy small container
    if raidSmallContainer then
        raidSmallContainer:Hide()
        raidSmallContainer = nil
    end
    for i, frame in pairs(raidSmallMemberFrames) do
        if frame then
            frame:Hide()
            frame:SetParent(nil)
        end
    end
    raidSmallMemberFrames = {}
    
    -- Destroy large container
    if raidLargeContainer then
        raidLargeContainer:Hide()
        raidLargeContainer = nil
    end
    for i, frame in pairs(raidLargeMemberFrames) do
        if frame then
            frame:Hide()
            frame:SetParent(nil)
        end
    end
    raidLargeMemberFrames = {}
    
    UnitFrames.ShowBlizzardRaidFrames()
end

-- ============================================================================
-- TANK FRAMES
-- ============================================================================

function UnitFrames:CreateTankContainer()
    if tankContainer then return tankContainer end
    if InCombatLockdown() then return end
    
    local ts = settings.tanks
    if not ts then return end
    
    local containerSettings = ts.container
    local scale = containerSettings.scale or 1.0
    
    -- Create main container (no backdrop - Layout overlays provide visual feedback)
    local container = CreateFrame("Frame", "TweaksUI_TankContainer", UIParent)
    
    -- Position from settings initially - Layout will take over when registered
    container:SetPoint(containerSettings.anchor or "CENTER", UIParent, containerSettings.anchor or "CENTER", containerSettings.x or 0, containerSettings.y or 0)
    container:SetScale(scale)
    container:SetMovable(true)
    container:SetClampedToScreen(true)
    
    -- Drag handling is done by Layout system now
    container:EnableMouse(false)
    
    -- Initial size will be calculated by UpdateTankFrames
    container:SetSize(ts.frame.width + 4, (ts.frame.height + ts.layout.spacing) * ts.maxTanks)
    
    tankContainer = container
    
    -- Create member frames for max tanks
    for i = 1, ts.maxTanks do
        self:CreateTankMemberFrame(i)
    end
    
    -- Register with Layout system
    local regContainer = container
    local regSettings = containerSettings
    
    local wrapper = UnitFrames:RegisterContainerWithLayout("tank", regContainer, regSettings)
    
    if not wrapper then
        C_Timer.After(0.2, function()
            if regContainer and not containerWrappers["tank"] then
                UnitFrames:RegisterContainerWithLayout("tank", regContainer, regSettings)
            end
        end)
    end
    
    return container
end

function UnitFrames:CreateTankMemberFrame(index)
    local ts = settings.tanks
    if not ts then return end
    if not tankContainer then return end
    
    -- Ensure castBar settings exist
    if not ts.castBar then
        ts.castBar = {
            enabled = false,
            height = 8,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
        }
    end
    
    local mf = ts.frame
    
    -- Create secure button for click interactions
    local frameName = "TweaksUI_TankMember_" .. index
    local frame = CreateFrame("Button", frameName, tankContainer, "SecureUnitButtonTemplate, BackdropTemplate")
    frame:SetSize(mf.width, mf.height)
    
    -- Unit will be set dynamically
    frame:SetAttribute("type1", "target")
    frame:SetAttribute("type2", "togglemenu")
    frame:RegisterForClicks("AnyUp")
    frame.unit = nil
    frame.index = index
    
    -- Background
    if mf.showBackground then
        frame:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8x8",
            edgeFile = mf.showBorder and "Interface\\Buttons\\WHITE8x8" or nil,
            edgeSize = mf.borderSize or 1,
        })
        frame:SetBackdropColor(mf.bgColor[1], mf.bgColor[2], mf.bgColor[3], mf.bgColor[4])
        if mf.showBorder then
            frame:SetBackdropBorderColor(mf.borderColor[1], mf.borderColor[2], mf.borderColor[3], mf.borderColor[4])
        end
    end
    
    -- Health bar
    local healthBar = CreateFrame("StatusBar", nil, frame)
    healthBar:SetPoint("TOPLEFT", 1, -1)
    healthBar:SetPoint("TOPRIGHT", -1, -1)
    healthBar:SetHeight(ts.healthBar.height)
    healthBar:SetStatusBarTexture(GetTexturePath(ts.healthBar.texture))
    healthBar:SetStatusBarColor(0.2, 0.8, 0.2)
    -- Apply bar masking
    if TweaksUI.BarMasking and ts.healthBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(healthBar, ts.healthBar.maskShape)
    end
    frame.healthBar = healthBar
    
    local healthBg = healthBar:CreateTexture(nil, "BACKGROUND")
    healthBg:SetAllPoints()
    healthBg:SetColorTexture(0.1, 0.1, 0.1, 0.8)
    
    -- Power bar
    local powerBar = CreateFrame("StatusBar", nil, frame)
    powerBar:SetPoint("TOPLEFT", healthBar, "BOTTOMLEFT", 0, -1)
    powerBar:SetPoint("TOPRIGHT", healthBar, "BOTTOMRIGHT", 0, -1)
    powerBar:SetHeight(ts.powerBar.height)
    powerBar:SetStatusBarTexture(GetTexturePath(ts.powerBar.texture))
    powerBar:SetStatusBarColor(0.2, 0.2, 0.8)
    -- Apply bar masking
    if TweaksUI.BarMasking and ts.powerBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(powerBar, ts.powerBar.maskShape)
    end
    frame.powerBar = powerBar
    
    local powerBg = powerBar:CreateTexture(nil, "BACKGROUND")
    powerBg:SetAllPoints()
    powerBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
    
    -- Name text
    local nameText = healthBar:CreateFontString(nil, "OVERLAY")
    nameText:SetFont(GetFontPath(DEFAULT_FONT), ts.nameText.fontSize, GetFontOutline(ts.nameText.fontOutline))
    nameText:SetPoint("LEFT", healthBar, "LEFT", 2, 0)
    nameText:SetJustifyH("LEFT")
    frame.nameText = nameText
    
    -- Health text
    local healthText = healthBar:CreateFontString(nil, "OVERLAY")
    healthText:SetFont(GetFontPath(DEFAULT_FONT), ts.healthText.fontSize, GetFontOutline(ts.healthText.fontOutline))
    healthText:SetPoint("RIGHT", healthBar, "RIGHT", -2, 0)
    healthText:SetJustifyH("RIGHT")
    frame.healthText = healthText
    
    -- Role icon
    local roleIconFrame = CreateFrame("Frame", nil, frame)
    roleIconFrame:SetSize(ts.roleIcon.size, ts.roleIcon.size)
    roleIconFrame:SetPoint(ts.roleIcon.position, frame, ts.roleIcon.position, ts.roleIcon.offsetX, ts.roleIcon.offsetY)
    roleIconFrame:SetFrameLevel(frame:GetFrameLevel() + 5)
    local roleIcon = roleIconFrame:CreateTexture(nil, "OVERLAY")
    roleIcon:SetAllPoints()
    frame.roleIcon = roleIcon
    frame.roleIconFrame = roleIconFrame
    
    -- Raid target icon
    local raidTargetFrame = CreateFrame("Frame", nil, frame)
    raidTargetFrame:SetSize(ts.raidTarget.size, ts.raidTarget.size)
    raidTargetFrame:SetPoint(ts.raidTarget.position, frame, ts.raidTarget.position, ts.raidTarget.offsetX, ts.raidTarget.offsetY)
    raidTargetFrame:SetFrameLevel(frame:GetFrameLevel() + 5)
    local raidTarget = raidTargetFrame:CreateTexture(nil, "OVERLAY")
    raidTarget:SetAllPoints()
    raidTarget:SetTexture("Interface\\TargetingFrame\\UI-RaidTargetingIcons")
    frame.raidTarget = raidTarget
    frame.raidTargetFrame = raidTargetFrame
    
    -- Debuff indicators
    local debuffContainer = CreateFrame("Frame", nil, frame)
    debuffContainer:SetFrameLevel(frame:GetFrameLevel() + 10)
    local diSize = ts.debuffIndicators.size or 8
    debuffContainer:SetSize(diSize * 4, diSize)
    debuffContainer:SetPoint(ts.debuffIndicators.position or "BOTTOMRIGHT", frame, ts.debuffIndicators.position or "BOTTOMRIGHT", ts.debuffIndicators.offsetX or -1, ts.debuffIndicators.offsetY or 1)
    frame.debuffContainer = debuffContainer
    
    local DEBUFF_TYPE_COLORS = {
        Magic = {0.2, 0.6, 1.0},
        Curse = {0.6, 0.0, 1.0},
        Disease = {0.6, 0.4, 0.0},
        Poison = {0.0, 0.6, 0.0},
    }
    
    frame.debuffIndicators = {}
    local debuffTypes = {"Magic", "Curse", "Disease", "Poison"}
    for j, debuffType in ipairs(debuffTypes) do
        local indicator = CreateFrame("Frame", nil, debuffContainer, "BackdropTemplate")
        indicator:SetSize(diSize, diSize)
        indicator:SetPoint("RIGHT", debuffContainer, "RIGHT", -((j-1) * (diSize + 1)), 0)
        indicator:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8X8",
            edgeFile = "Interface\\Buttons\\WHITE8X8",
            edgeSize = 1,
        })
        local color = DEBUFF_TYPE_COLORS[debuffType]
        indicator:SetBackdropColor(color[1], color[2], color[3], 1)
        indicator:SetBackdropBorderColor(0, 0, 0, 1)
        indicator:Hide()
        
        -- Square texture (for colored square style)
        local square = indicator:CreateTexture(nil, "ARTWORK")
        square:SetAllPoints()
        square:SetColorTexture(color[1], color[2], color[3], 1)
        indicator.square = square
        
        -- Icon texture (for Blizzard icon style)
        local icon = indicator:CreateTexture(nil, "ARTWORK")
        icon:SetAllPoints()
        icon:Hide()
        indicator.icon = icon
        
        -- Load atlas for icon
        local atlasName = Constants.DEBUFF_TYPE_ATLASES[debuffType]
        if atlasName then
            local success = pcall(function() icon:SetAtlas(atlasName) end)
            if not success then
                local texturePath = Constants.DEBUFF_TYPE_TEXTURES[debuffType]
                if texturePath then
                    icon:SetTexture(texturePath)
                end
            end
        end
        
        frame.debuffIndicators[debuffType] = indicator
    end
    
    -- Cast Bar (always create, visibility controlled by enabled setting)
    if ts.castBar then
        local cbHeight = ts.castBar.height or 8
        local castBar = CreateFrame("StatusBar", nil, frame)
        castBar:SetStatusBarTexture(GetTexturePath(ts.castBar.texture))
        castBar:SetStatusBarColor(1, 0.7, 0, 1)
        castBar:SetHeight(cbHeight)
        castBar:SetPoint("TOPLEFT", frame, "BOTTOMLEFT", 1, -1)
        castBar:SetPoint("TOPRIGHT", frame, "BOTTOMRIGHT", -1, -1)
        castBar:SetMinMaxValues(0, 1)
        castBar:SetValue(0)
        castBar:Hide()
        frame.castBar = castBar
        
        local castBg = castBar:CreateTexture(nil, "BACKGROUND")
        castBg:SetAllPoints()
        castBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
        
        -- Always create text/icon/timer elements
        local castText = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        castText:SetPoint("LEFT", castBar, "LEFT", cbHeight + 2, 0)
        frame.castText = castText
        
        local castIcon = castBar:CreateTexture(nil, "OVERLAY")
        castIcon:SetSize(cbHeight, cbHeight)
        castIcon:SetPoint("LEFT", castBar, "LEFT", 1, 0)
        frame.castIcon = castIcon
        
        local castTimer = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        castTimer:SetPoint("RIGHT", castBar, "RIGHT", -2, 0)
        frame.castTimer = castTimer
    end
    
    -- Highlight
    local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
    highlight:SetAllPoints()
    highlight:SetColorTexture(1, 1, 1, 0.1)
    
    -- Tooltip
    frame:SetScript("OnEnter", function(self)
        if self.unit and UnitExists(self.unit) then
            GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
            GameTooltip:SetUnit(self.unit)
            GameTooltip:Show()
        elseif simulateTanks or (currentOpenPanel == "tanks") then
            GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
            GameTooltip:AddLine("Simulated Tank " .. self.index, 1, 1, 1)
            GameTooltip:Show()
        end
    end)
    frame:SetScript("OnLeave", function() GameTooltip:Hide() end)
    
    frame:Hide()
    tankMemberFrames[index] = frame
    return frame
end

-- ============================================================================
-- PUBLIC API - For Layout module integration
-- ============================================================================

-- Check if a unit type's custom frame is enabled
function UnitFrames:IsUnitEnabled(unitType)
    if not settings or not settings[unitType] then return false end
    return settings[unitType].enabled == true
end

-- Get the custom frame for a unit type (returns nil if not created or not enabled)
function UnitFrames:GetCustomFrame(unitType)
    if not self:IsUnitEnabled(unitType) then return nil end
    return customFrames[unitType]
end

-- Get all active custom frames
function UnitFrames:GetAllCustomFrames()
    local result = {}
    for unit, frame in pairs(customFrames) do
        if settings[unit] and settings[unit].enabled then
            result[unit] = frame
        end
    end
    return result
end

-- Get the configured size for a unit type
function UnitFrames:GetUnitSize(unitType)
    if not settings or not settings[unitType] then return nil, nil end
    local fs = settings[unitType].frame
    if fs and fs.width and fs.height then
        return fs.width, fs.height
    end
    return nil, nil
end

-- ============================================================================
-- LAYOUT MODULE INTEGRATION
-- ============================================================================

local TUIFrame = nil
local Layout = nil

-- Initialize Layout integration (called after modules are ready)
local function InitLayoutIntegration()
    if layoutIntegrationEnabled then return end
    
    TUIFrame = TweaksUI.TUIFrame
    Layout = TweaksUI.Layout
    
    if not TUIFrame or not Layout then
        TweaksUI:PrintDebug("UnitFrames: Layout or TUIFrame not available yet")
        return false
    end
    
    layoutIntegrationEnabled = true
    TweaksUI:PrintDebug("UnitFrames: Layout integration initialized")
    return true
end

-- Create TUIFrame wrapper for a unit frame and register with Layout
local function RegisterUnitFrameWithLayout(unit)
    -- Cannot modify frame parents during combat (causes taint)
    if InCombatLockdown() then
        return nil
    end
    
    if not layoutIntegrationEnabled then
        if not InitLayoutIntegration() then
            return nil
        end
    end
    
    local frame = customFrames[unit]
    if not frame then
        return nil
    end
    
    -- Already registered?
    if unitFrameWrappers[unit] then
        return unitFrameWrappers[unit]
    end
    
    local unitSettings = settings[unit]
    if not unitSettings then return nil end
    
    local fs = unitSettings.frame
    
    -- Calculate actual frame size (same logic as UpdateFrameLayout)
    local width, height
    if fs.autoSize then
        width, height = CalculateFrameSize(unit)
    else
        width = fs.width or 200
        height = fs.height or 50
    end
    
    -- Create TUIFrame wrapper
    local wrapper = TUIFrame:New("unitframe_" .. unit, {
        width = width,
        height = height,
        name = "TUI " .. unit:gsub("^%l", string.upper) .. " Frame",
    })
    
    if not wrapper then
        return nil
    end
    
    -- Parent the unit frame to the wrapper
    frame:SetParent(wrapper.frame)
    frame:ClearAllPoints()
    frame:SetPoint("TOPLEFT", wrapper.frame, "TOPLEFT", 0, 0)
    frame:SetPoint("BOTTOMRIGHT", wrapper.frame, "BOTTOMRIGHT", 0, 0)
    
    -- Position wrapper from settings (initial position or saved Layout position)
    local layoutSettings = Layout:GetSettings()
    local savedPos = layoutSettings and layoutSettings.elements and layoutSettings.elements["unitframe_" .. unit]
    
    if savedPos and savedPos.x and savedPos.y then
        -- Use Layout saved position (will handle fade-in)
        wrapper:LoadSaveData(savedPos)
    else
        -- Use settings position (legacy or default) - use wrapper method for fade-in
        local anchor = fs.anchor or "CENTER"
        local posX = fs.x or 0
        local posY = fs.y or 0
        wrapper:SetPosition(anchor, UIParent, anchor, posX, posY)
    end
    
    -- Store wrapper
    unitFrameWrappers[unit] = wrapper
    
    -- Register with Layout module
    Layout:RegisterElement("unitframe_" .. unit, {
        name = unit:gsub("^%l", string.upper) .. " Frame",
        category = Layout.CATEGORIES.UNIT_FRAMES,
        tuiFrame = wrapper,
        defaultPosition = { point = fs.anchor or "CENTER", x = fs.x or 0, y = fs.y or 0 },
        onPositionChanged = function(id, saveData)
            -- Update settings to keep them in sync (for export/import)
            if saveData and settings[unit] and settings[unit].frame then
                settings[unit].frame.x = saveData.x
                settings[unit].frame.y = saveData.y
                -- Convert BOTTOMLEFT to stored anchor format
                settings[unit].frame.anchor = saveData.point or "BOTTOMLEFT"
            end
        end,
        -- Handle size changes from Layout size matching
        -- options.widthTarget and options.heightTarget can be "healthBar" or "frame"
        onSizeChanged = function(id, newWidth, newHeight, options)
            if not settings[unit] then return end
            
            options = options or {}
            local heightTarget = options.heightTarget or "frame"
            local widthTarget = options.widthTarget or "frame"
            
            if TweaksUI.PrintDebug then
                TweaksUI:PrintDebug(string.format("UnitFrames: onSizeChanged for %s: %.0fx%.0f (hTarget=%s, wTarget=%s)", 
                    unit, newWidth, newHeight, heightTarget, widthTarget))
            end
            
            local needsRelayout = false
            
            -- Handle height target
            if heightTarget == "healthBar" then
                -- Set the health bar height directly
                if settings[unit].healthBar then
                    settings[unit].healthBar.height = newHeight
                    needsRelayout = true
                    if TweaksUI.PrintDebug then
                        TweaksUI:PrintDebug(string.format("UnitFrames: Set %s healthBar.height = %.0f", unit, newHeight))
                    end
                end
            else
                -- Default: set the frame height
                if settings[unit].frame then
                    settings[unit].frame.height = newHeight
                end
            end
            
            -- Handle width target
            if widthTarget == "healthBar" then
                -- For width, we still need to set frame width because health bar stretches
                -- But we use the matched width directly
                if settings[unit].frame then
                    settings[unit].frame.width = newWidth
                    needsRelayout = true
                end
            else
                -- Default: set the frame width
                if settings[unit].frame then
                    settings[unit].frame.width = newWidth
                end
            end
            
            -- If using healthBar target, trigger a full re-layout
            -- This recalculates the frame size based on the new health bar height
            if needsRelayout then
                -- Update the wrapper size to match new calculated size
                local frame = customFrames[unit]
                if frame and wrapper then
                    -- Calculate the new auto-size if enabled
                    local fs = settings[unit].frame
                    local newFrameWidth, newFrameHeight
                    
                    if fs.autoSize then
                        newFrameWidth, newFrameHeight = CalculateFrameSize(unit)
                    else
                        newFrameWidth = fs.width or 200
                        newFrameHeight = fs.height or 50
                    end
                    
                    -- Update wrapper size
                    wrapper:ForceSetSize(newFrameWidth, newFrameHeight)
                    
                    -- Update frame layout (local function)
                    UpdateFrameLayout(unit)
                    
                    if TweaksUI.PrintDebug then
                        TweaksUI:PrintDebug(string.format("UnitFrames: Relayout %s to %.0fx%.0f", 
                            unit, newFrameWidth, newFrameHeight))
                    end
                end
            end
        end,
    })
    
    return wrapper
end

-- Get TUIFrame wrapper for a unit
function UnitFrames:GetUnitFrameWrapper(unit)
    return unitFrameWrappers[unit]
end

-- Register a container (party/raid/tank/boss) with Layout system
function UnitFrames:RegisterContainerWithLayout(containerType, container, containerSettings)
    if not container then 
        return nil 
    end
    
    if not layoutIntegrationEnabled then
        if not InitLayoutIntegration() then
            return nil
        end
    end
    
    -- Already registered?
    if containerWrappers[containerType] then
        return containerWrappers[containerType]
    end
    
    -- Calculate size based on settings rather than current frame size
    local width, height = self:CalculateContainerSize(containerType)
    if not width or width == 0 then
        width = container:GetWidth()
    end
    if not height or height == 0 then
        height = container:GetHeight()
    end
    
    -- Ensure minimum size
    if width < 50 then width = 150 end
    if height < 20 then height = 100 end
    
    -- Get scale and position from SETTINGS (authoritative source)
    local containerScale = containerSettings and containerSettings.scale or 1.0
    local point = containerSettings and containerSettings.anchor or "CENTER"
    local xOfs = containerSettings and containerSettings.x or 0
    local yOfs = containerSettings and containerSettings.y or 0
    
    local displayName = containerType:gsub("_", " "):gsub("(%a)([%w_']*)", function(a,b) return a:upper()..b:lower() end)
    
    -- Create TUIFrame wrapper
    local wrapper = TUIFrame:New("container_" .. containerType, {
        width = width,
        height = height,
        name = displayName .. " Container",
    })
    
    if not wrapper then
        return nil
    end
    
    -- Apply scale to wrapper
    wrapper.frame:SetScale(containerScale)
    
    -- Position wrapper from settings (authoritative source)
    wrapper.frame:ClearAllPoints()
    wrapper.frame:SetPoint(point, UIParent, point, xOfs, yOfs)
    
    -- Reset container's scale since wrapper now handles it
    container:SetScale(1.0)
    
    -- Parent the container to the wrapper
    container:SetParent(wrapper.frame)
    container:ClearAllPoints()
    container:SetPoint("TOPLEFT", wrapper.frame, "TOPLEFT", 0, 0)
    container:SetPoint("BOTTOMRIGHT", wrapper.frame, "BOTTOMRIGHT", 0, 0)
    
    -- Disable container's own drag handlers (Layout handles positioning now)
    container:SetScript("OnDragStart", nil)
    container:SetScript("OnDragStop", nil)
    container:EnableMouse(false)  -- Let wrapper handle mouse
    
    -- Store wrapper
    containerWrappers[containerType] = wrapper
    
    -- Register with Layout module
    Layout:RegisterElement("container_" .. containerType, {
        name = displayName .. " Container",
        category = Layout.CATEGORIES.UNIT_FRAMES,
        tuiFrame = wrapper,
        defaultPosition = { point = point, x = xOfs, y = yOfs },
        onPositionChanged = function(id, saveData)
            -- Update settings to keep them in sync
            if saveData and containerSettings then
                containerSettings.x = saveData.x
                containerSettings.y = saveData.y
                containerSettings.anchor = saveData.point or "BOTTOMLEFT"
            end
        end,
        -- NEW: Handle size changes from Layout size matching
        onSizeChanged = function(id, newWidth, newHeight)
            if containerSettings then
                containerSettings.width = newWidth
                containerSettings.height = newHeight
                
                if TweaksUI.PrintDebug then
                    TweaksUI:PrintDebug(string.format("UnitFrames: Saved matched size for container %s: %.0fx%.0f", 
                        containerType, newWidth, newHeight))
                end
            end
        end,
    })
    
    return wrapper
end

-- Calculate container size based on settings
function UnitFrames:CalculateContainerSize(containerType)
    local width, height = 0, 0
    
    if containerType == "party" then
        local ps = settings.party
        if ps then
            local spacing = ps.container.spacing or 2
            local growthDir = ps.container.growthDirection or "DOWN"
            if growthDir == "DOWN" or growthDir == "UP" then
                width = ps.frame.width + 4
                height = (ps.frame.height + spacing) * 5 + 4
            else
                width = (ps.frame.width + spacing) * 5 + 4
                height = ps.frame.height + 4
            end
        end
    elseif containerType == "raid_small" then
        local rs = settings.raid
        if rs and rs.small then
            local ls = rs.small
            local cols = ls.layout.columns or 4
            local rows = math.ceil(20 / cols)
            local spacing = ls.layout.spacing or 2
            width = (ls.frame.width + spacing) * cols + 4
            height = (ls.frame.height + spacing) * rows + 4
        end
    elseif containerType == "raid_large" then
        local rs = settings.raid
        if rs and rs.large then
            local ls = rs.large
            local cols = ls.layout.columns or 5
            local rows = math.ceil(40 / cols)
            local spacing = ls.layout.spacing or 2
            width = (ls.frame.width + spacing) * cols + 4
            height = (ls.frame.height + spacing) * rows + 4
        end
    elseif containerType == "tank" then
        local ts = settings.tanks
        if ts then
            local spacing = ts.layout.spacing or 2
            local maxTanks = ts.maxTanks or 3
            width = ts.frame.width + 4
            height = (ts.frame.height + spacing) * maxTanks + 4
        end
    elseif containerType == "boss" then
        local bs = settings.boss
        if bs then
            local spacing = bs.layout.spacing or 2
            local maxBosses = bs.maxBosses or 5
            width = bs.frame.width + 4
            height = (bs.frame.height + spacing) * maxBosses + 4
        end
    end
    
    return width, height
end

-- Setup Layout mode callbacks (show/hide simulations)
local function SetupLayoutModeCallbacks()
    if not Layout then
        Layout = TweaksUI.Layout
    end
    
    if not Layout or not Layout.RegisterCallback then
        return
    end
    
    Layout:RegisterCallback("OnLayoutModeEnter", function()
        if not InCombatLockdown() then
            local registered = false
            
            -- Register any unit frames that exist but don't have wrappers yet
            for unit, frame in pairs(customFrames) do
                if frame and not unitFrameWrappers[unit] then
                    RegisterUnitFrameWithLayout(unit)
                    registered = true
                end
            end
            
            -- If we registered new elements, force Layout to recreate overlays
            if registered then
                C_Timer.After(0.1, function()
                    if TweaksUI.LayoutUI and TweaksUI.LayoutUI.ShowOverlays then
                        TweaksUI.LayoutUI:ShowOverlays()
                    end
                end)
            end
            
            -- Show wrappers for frames that exist
            for unit, wrapper in pairs(unitFrameWrappers) do
                if wrapper and wrapper.frame then
                    wrapper.frame:Show()
                end
            end
            
            -- Hide individual unit frame content (keep wrappers visible for overlays)
            for unit, frame in pairs(customFrames) do
                if frame then
                    frame:Hide()
                end
            end
            
            -- Hide container content (party/raid/tank/boss member frames)
            -- The containers themselves stay visible but empty
            for i, memberFrame in ipairs(partyMemberFrames or {}) do
                if memberFrame then memberFrame:Hide() end
            end
            for i, memberFrame in ipairs(raidSmallMemberFrames or {}) do
                if memberFrame then memberFrame:Hide() end
            end
            for i, memberFrame in ipairs(raidLargeMemberFrames or {}) do
                if memberFrame then memberFrame:Hide() end
            end
            for i, memberFrame in ipairs(tankMemberFrames or {}) do
                if memberFrame then memberFrame:Hide() end
            end
            for i, memberFrame in ipairs(bossMemberFrames or {}) do
                if memberFrame then memberFrame:Hide() end
            end
            
            -- Lower unit frame wrapper strata
            for unit, wrapper in pairs(unitFrameWrappers) do
                if wrapper and wrapper.frame then
                    wrapper.frame._layoutModeOriginalStrata = wrapper.frame:GetFrameStrata()
                    wrapper.frame:SetFrameStrata("BACKGROUND")
                end
            end
            
            -- Lower container wrapper strata
            for containerType, wrapper in pairs(containerWrappers) do
                if wrapper and wrapper.frame then
                    wrapper.frame._layoutModeOriginalStrata = wrapper.frame:GetFrameStrata()
                    wrapper.frame:SetFrameStrata("BACKGROUND")
                end
            end
        end
    end)
    
    Layout:RegisterCallback("OnLayoutModeExit", function()
        TweaksUI:PrintDebug("UnitFrames: Layout mode exited")
        
        if not InCombatLockdown() then
            -- Restore individual unit frame visibility
            for unit, frame in pairs(customFrames) do
                if frame then
                    frame:Show()
                end
            end
            
            -- Restore container member frame visibility
            for i, memberFrame in ipairs(partyMemberFrames or {}) do
                if memberFrame then memberFrame:Show() end
            end
            for i, memberFrame in ipairs(raidSmallMemberFrames or {}) do
                if memberFrame then memberFrame:Show() end
            end
            for i, memberFrame in ipairs(raidLargeMemberFrames or {}) do
                if memberFrame then memberFrame:Show() end
            end
            for i, memberFrame in ipairs(tankMemberFrames or {}) do
                if memberFrame then memberFrame:Show() end
            end
            for i, memberFrame in ipairs(bossMemberFrames or {}) do
                if memberFrame then memberFrame:Show() end
            end
            
            -- Restore unit frame wrapper strata
            for unit, wrapper in pairs(unitFrameWrappers) do
                if wrapper and wrapper.frame then
                    if wrapper.frame._layoutModeOriginalStrata then
                        wrapper.frame:SetFrameStrata(wrapper.frame._layoutModeOriginalStrata)
                    else
                        wrapper.frame:SetFrameStrata("LOW")
                    end
                end
            end
            
            -- Restore container wrapper strata
            for containerType, wrapper in pairs(containerWrappers) do
                if wrapper and wrapper.frame then
                    if wrapper.frame._layoutModeOriginalStrata then
                        wrapper.frame:SetFrameStrata(wrapper.frame._layoutModeOriginalStrata)
                    else
                        wrapper.frame:SetFrameStrata("LOW")
                    end
                end
            end
        end
    end)
end

function UnitFrames:GetTankUnits()
    local tanks = {}
    if not settings then return tanks end
    local ts = settings.tanks
    if not ts then return tanks end
    
    local panelOpen = currentOpenPanel == "tanks"
    
    -- In simulation mode or panel is open, return fake tanks
    if simulateTanks or panelOpen then
        for i = 1, ts.maxTanks do
            tanks[i] = {
                unit = "raid" .. i,
                name = SIMULATED_RAID[i] and SIMULATED_RAID[i].name or ("Tank" .. i),
                class = SIMULATED_RAID[i] and SIMULATED_RAID[i].class or "WARRIOR",
                isMainTank = (i == 1),
                isMainAssist = (i == 2),
                simulated = true,
                simIndex = i,
            }
        end
        return tanks
    end
    
    -- Not in a group
    if not IsInGroup() then return tanks end
    
    local seen = {}
    
    -- Check for Main Tank assignments first
    if ts.showMainTank then
        for i = 1, MAX_RAID_MEMBERS do
            local unit = "raid" .. i
            if UnitExists(unit) then
                local name = GetRaidRosterInfo(i)
                if name then
                    local _, _, _, _, _, _, _, _, _, role = GetRaidRosterInfo(i)
                    if role == "MAINTANK" and not seen[unit] then
                        table.insert(tanks, {
                            unit = unit,
                            name = UnitName(unit),
                            class = select(2, UnitClass(unit)),
                            isMainTank = true,
                            isMainAssist = false,
                        })
                        seen[unit] = true
                    end
                end
            end
        end
    end
    
    -- Check for Main Assist assignments
    if ts.showMainAssist then
        for i = 1, MAX_RAID_MEMBERS do
            local unit = "raid" .. i
            if UnitExists(unit) and not seen[unit] then
                local name = GetRaidRosterInfo(i)
                if name then
                    local _, _, _, _, _, _, _, _, _, role = GetRaidRosterInfo(i)
                    if role == "MAINASSIST" then
                        table.insert(tanks, {
                            unit = unit,
                            name = UnitName(unit),
                            class = select(2, UnitClass(unit)),
                            isMainTank = false,
                            isMainAssist = true,
                        })
                        seen[unit] = true
                    end
                end
            end
        end
    end
    
    -- Check for players with Tank role
    if ts.showRoleTanks then
        for i = 1, GetNumGroupMembers() do
            local unit = IsInRaid() and ("raid" .. i) or (i == 1 and "player" or ("party" .. (i - 1)))
            if UnitExists(unit) and not seen[unit] then
                local role = UnitGroupRolesAssigned(unit)
                if role == "TANK" then
                    table.insert(tanks, {
                        unit = unit,
                        name = UnitName(unit),
                        class = select(2, UnitClass(unit)),
                        isMainTank = false,
                        isMainAssist = false,
                    })
                    seen[unit] = true
                end
            end
        end
    end
    
    -- Limit to maxTanks
    while #tanks > ts.maxTanks do
        table.remove(tanks)
    end
    
    return tanks
end

function UnitFrames:UpdateTankFrames()
    if not settings then return end
    local ts = settings.tanks
    if not ts then return end
    
    local panelOpen = currentOpenPanel == "tanks"
    
    -- If not enabled and not simulating and panel not open, hide container and return
    if not ts.enabled and not simulateTanks and not panelOpen then
        if tankContainer and not InCombatLockdown() then
            tankContainer:Hide()
        end
        return
    end
    
    if not tankContainer then
        self:CreateTankContainer()
        if not tankContainer then return end
    end
    
    local tanks = self:GetTankUnits()
    local layout = ts.layout
    local mf = ts.frame
    local spacing = layout.spacing or 2
    local direction = layout.direction or "DOWN"
    
    -- Position and show tank frames
    for i = 1, ts.maxTanks do
        local frame = tankMemberFrames[i]
        if frame then
            local tankData = tanks[i]
            if tankData then
                -- Set unit
                frame.unit = tankData.unit
                frame.tankData = tankData
                if not InCombatLockdown() then
                    frame:SetAttribute("unit", tankData.unit)
                end
                
                -- Position frame
                local x, y = 0, 0
                if direction == "DOWN" then
                    y = -((i - 1) * (mf.height + spacing))
                elseif direction == "UP" then
                    y = (i - 1) * (mf.height + spacing)
                elseif direction == "RIGHT" then
                    x = (i - 1) * (mf.width + spacing)
                elseif direction == "LEFT" then
                    x = -((i - 1) * (mf.width + spacing))
                end
                
                if not InCombatLockdown() then
                    frame:ClearAllPoints()
                    frame:SetPoint("TOPLEFT", tankContainer, "TOPLEFT", x + 2, y - 2)
                    frame:SetSize(mf.width, mf.height)
                    frame:Show()
                end
                
                -- Update frame data
                self:UpdateTankMemberFrame(i)
            else
                -- No tank for this slot
                if not InCombatLockdown() then
                    frame:Hide()
                end
                frame.unit = nil
                frame.tankData = nil
            end
        end
    end
    
    -- Update container size
    local numTanks = #tanks
    if numTanks > 0 and not InCombatLockdown() then
        local totalWidth, totalHeight
        if direction == "DOWN" or direction == "UP" then
            totalWidth = mf.width + 4
            totalHeight = numTanks * (mf.height + spacing) + 4
        else
            totalWidth = numTanks * (mf.width + spacing) + 4
            totalHeight = mf.height + 4
        end
        tankContainer:SetSize(totalWidth, totalHeight)
        tankContainer:Show()
    elseif not InCombatLockdown() and not simulateTanks then
        tankContainer:Hide()
    end
end

function UnitFrames:UpdateTankMemberFrame(index)
    local frame = tankMemberFrames[index]
    if not frame then return end
    
    local ts = settings.tanks
    if not ts then return end
    
    local tankData = frame.tankData
    local unit = frame.unit
    local panelOpen = currentOpenPanel == "tanks"
    local isTestMode = (simulateTanks or panelOpen) and tankData and tankData.simulated
    
    local unitExists = (unit and UnitExists(unit)) or isTestMode
    if not unitExists then
        if not InCombatLockdown() then
            frame:Hide()
        end
        return
    end
    
    -- Update frame visual layout
    local mf = ts.frame
    
    if mf.showBackground then
        frame:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8x8",
            edgeFile = mf.showBorder and "Interface\\Buttons\\WHITE8x8" or nil,
            edgeSize = mf.borderSize or 1,
        })
        frame:SetBackdropColor(mf.bgColor[1], mf.bgColor[2], mf.bgColor[3], mf.bgColor[4])
        if mf.showBorder then
            frame:SetBackdropBorderColor(mf.borderColor[1], mf.borderColor[2], mf.borderColor[3], mf.borderColor[4])
        end
    end
    
    frame.healthBar:ClearAllPoints()
    frame.healthBar:SetPoint("TOPLEFT", 1, -1)
    frame.healthBar:SetPoint("TOPRIGHT", -1, -1)
    frame.healthBar:SetHeight(ts.healthBar.height)
    
    frame.powerBar:ClearAllPoints()
    frame.powerBar:SetPoint("TOPLEFT", frame.healthBar, "BOTTOMLEFT", 0, -1)
    frame.powerBar:SetPoint("TOPRIGHT", frame.healthBar, "BOTTOMRIGHT", 0, -1)
    frame.powerBar:SetHeight(ts.powerBar.height)
    
    frame.nameText:SetFont(GetFontPath(DEFAULT_FONT), ts.nameText.fontSize, GetFontOutline(ts.nameText.fontOutline))
    frame.healthText:SetFont(GetFontPath(DEFAULT_FONT), ts.healthText.fontSize, GetFontOutline(ts.healthText.fontOutline))
    
    -- Get unit data (non-secret values only)
    local name, class, powerType
    local simData
    
    if isTestMode then
        simData = SIMULATED_RAID[tankData.simIndex]
        powerType = simData.powerType or 0
        name = simData.name
        class = simData.class
    else
        powerType = UnitPowerType(unit) or 0
        name = UnitName(unit) or "Unknown"
        _, class = UnitClass(unit)
        class = class or "WARRIOR"
    end
    
    -- Update health bar - just pass value straight through
    frame.healthBar:SetMinMaxValues(0, 100)
    local healthPct
    if isTestMode and simData then
        healthPct = (simData.maxHealth > 0) and ((simData.health / simData.maxHealth) * 100) or 100
    else
        -- Use SafeUnitHealthPercent for Midnight compatibility
        healthPct = SafeUnitHealthPercent(unit, true) or 100
    end
    -- Use smooth animation if available (Midnight Beta 3+)
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    local classColor = RAID_CLASS_COLORS[class]
    if ts.healthBar.colorMode == "class" and classColor then
        frame.healthBar:SetStatusBarColor(classColor.r, classColor.g, classColor.b)
    elseif ts.healthBar.colorMode == "health" then
        -- Health-based color - use Midnight curve if available
        if isTestMode and simData and simData.maxHealth > 0 then
            local pct = simData.health / simData.maxHealth
            frame.healthBar:SetStatusBarColor(1 - pct, pct, 0)
        else
            -- Try using Midnight health gradient curve
            local r, g, b = GetHealthGradientColorMidnight(unit, nil)
            frame.healthBar:SetStatusBarColor(r, g, b)
        end
    else
        local c = ts.healthBar.customColor or {0.2, 0.8, 0.2, 1}
        frame.healthBar:SetStatusBarColor(c[1], c[2], c[3])
    end
    
    -- Update power bar - pass values directly to StatusBar
    if ts.powerBar.enabled then
        frame.powerBar:Show()
        local power, maxPower
        if isTestMode and simData then
            power = simData.power or 0
            maxPower = simData.maxPower or 1
        else
            power = UnitPower(unit)
            maxPower = UnitPowerMax(unit)
        end
        frame.powerBar:SetMinMaxValues(0, maxPower)
        -- Use smooth animation if available (Midnight Beta 3+)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
        local powerColor = PowerBarColor[powerType] or {r = 0.2, g = 0.2, b = 0.8}
        frame.powerBar:SetStatusBarColor(powerColor.r, powerColor.g, powerColor.b)
    else
        frame.powerBar:Hide()
    end
    
    -- Update name text
    if ts.nameText.enabled then
        local displayName = name or "Unknown"
        if ts.nameText.maxLength and ts.nameText.maxLength > 0 and #displayName > ts.nameText.maxLength then
            displayName = displayName:sub(1, ts.nameText.maxLength)
        end
        frame.nameText:SetText(displayName)
        if ts.nameText.colorMode == "class" and classColor then
            frame.nameText:SetTextColor(classColor.r, classColor.g, classColor.b)
        else
            frame.nameText:SetTextColor(1, 1, 1)
        end
        frame.nameText:Show()
    else
        frame.nameText:Hide()
    end
    
    -- Update health text
    if ts.healthText.enabled then
        frame.healthText:SetText(FormatHealthTextMidnight(unit, ts.healthText.format, health, maxHealth))
        frame.healthText:Show()
    else
        frame.healthText:Hide()
    end
    
    -- Update role icon (always show tank icon for tank frames)
    if ts.roleIcon.enabled then
        local atlasOptions = {"roleicon-guardian", "roleicon-tank", "UI-LFG-RoleIcon-Tank"}
        local atlasSet = false
        for _, atlasName in ipairs(atlasOptions) do
            local success = pcall(function()
                frame.roleIcon:SetAtlas(atlasName, true)
            end)
            if success then
                local currentAtlas = frame.roleIcon:GetAtlas()
                if currentAtlas and currentAtlas ~= "" then
                    atlasSet = true
                    break
                end
            end
        end
        if atlasSet then
            frame.roleIcon:Show()
            frame.roleIconFrame:Show()
        else
            frame.roleIcon:Hide()
            frame.roleIconFrame:Hide()
        end
    else
        frame.roleIcon:Hide()
        frame.roleIconFrame:Hide()
    end
    
    -- Update raid target
    local raidTargetIndex = isTestMode and nil or GetRaidTargetIndex(unit)
    if ts.raidTarget.enabled and raidTargetIndex then
        SetRaidTargetIconTexture(frame.raidTarget, raidTargetIndex)
        frame.raidTargetFrame:Show()
    else
        frame.raidTargetFrame:Hide()
    end
    
    -- Update debuff indicators (Midnight: colored boxes)
    -- Show during simulation even if disabled (so user can preview layout)
    local showDebuffIndicators = frame.debuffIndicators and (ts.debuffIndicators.enabled or isTestMode)
    if showDebuffIndicators then
        local di = ts.debuffIndicators
        local diSize = di.size or 8
        
        -- Update container position and size
        if frame.debuffContainer then
            frame.debuffContainer:ClearAllPoints()
            frame.debuffContainer:SetSize(diSize * 4, diSize)
            frame.debuffContainer:SetPoint(di.position or "BOTTOMRIGHT", frame, di.position or "BOTTOMRIGHT", di.offsetX or -1, di.offsetY or 1)
        end
        
        -- Hide legacy type-specific indicators
        for _, indicator in pairs(frame.debuffIndicators) do
            indicator:Hide()
        end
        
        if isTestMode and frame.index == 1 then
            -- Simulation mode - show simulated type indicator on first tank
            local indicator = frame.debuffIndicators["Magic"]
            if indicator then
                local style = di.style or "squares"
                UpdateDebuffIndicatorStyle(indicator, style, diSize)
                indicator:SetAlpha(1)
                indicator:ClearAllPoints()
                indicator:SetPoint("RIGHT", frame.debuffContainer, "RIGHT", 0, 0)
                indicator:Show()
            end
        else
            -- Use helper function for colored boxes
            UpdateDispelBoxes(frame, unit, diSize, 4, di.onlyPlayerDispellable)
        end
    elseif frame.debuffIndicators then
        -- Hide all indicators when disabled
        for _, indicator in pairs(frame.debuffIndicators) do
            if indicator.Hide then indicator:Hide() end
        end
    end
    
    -- Update cast bar
    local showTankPreview = isTestMode and frame.castBar and ts.castBar
    if (frame.castBar and ts.castBar and ts.castBar.enabled) or showTankPreview then
        local unitID = unit
        local cbs = ts.castBar
        
        -- Handle simulation mode
        if isTestMode then
            -- Show a simulated cast bar on the first tank only
            if frame.index == 1 then
                frame.castBar:SetMinMaxValues(0, 3)
                frame.castBar:SetValue(1.5)
                if frame.castText then 
                    if not cbs or cbs.showSpellName then
                        frame.castText:SetText("Simulated Cast")
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                if frame.castTimer then 
                    if not cbs or cbs.showTimer then
                        frame.castTimer:SetText("1.5")
                        frame.castTimer:Show()
                    else
                        frame.castTimer:Hide()
                    end
                end
                if frame.castIcon then 
                    if not cbs or cbs.showIcon then
                        frame.castIcon:SetTexture("Interface\\Icons\\Spell_Holy_ShieldOfTheRighteous")
                        frame.castIcon:Show()
                    else
                        frame.castIcon:Hide()
                    end
                end
                frame.castBar:SetStatusBarColor(1, 0.7, 0, 1)
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        else
            -- Real cast bar update (v2.1.3 - SetTimerDuration for secrets)
            local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unitID)
            local isChannel = false
            local isEmpowered = false
            local numEmpowerStages = nil
            if not castName then
                -- Check for empowered spell using event-driven flag
                if frame.isEmpoweredCast and frame.empowerSpellID then
                    if C_Spell and C_Spell.GetSpellInfo then
                        local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                        if success and spellInfo and spellInfo.name then
                            local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unitID)
                            if chStart and chEnd then
                                castName = spellInfo.name
                                startTime = chStart
                                endTime = chEnd
                                spellID = frame.empowerSpellID
                                isEmpowered = true
                                notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                                isChannel = false
                                numEmpowerStages = GetEmpowerNumStages(unitID) or 3
                            end
                        end
                    end
                end
                
                if not isEmpowered then
                    castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unitID)
                    isChannel = true
                    frame.empowerSpellID = nil
                    frame.isEmpoweredCast = false
                end
            else
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
            
            -- Setup/hide empowered dividers
            if isEmpowered then
                local safeStages = numEmpowerStages or 3
                if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
                if safeStages >= 2 then
                    SetupEmpowerDividers(frame.castBar, unitID, safeStages)
                else
                    HideEmpowerDividers(frame.castBar)
                end
            else
                HideEmpowerDividers(frame.castBar)
            end
            
            local castBarSetup = false
            
            -- Try SetTimerDuration (handles secrets)
            if castName and HAS_TIMER_BARS then
                local durationObj = nil
                if isEmpowered and UnitEmpoweredChannelDuration then
                    local ok, obj = pcall(UnitEmpoweredChannelDuration, unitID, true)
                    if ok and obj then durationObj = obj end
                elseif isChannel and UnitChannelDuration then
                    local ok, obj = pcall(UnitChannelDuration, unitID)
                    if ok and obj then durationObj = obj end
                elseif not isChannel and UnitCastingDuration then
                    local ok, obj = pcall(UnitCastingDuration, unitID)
                    if ok and obj then durationObj = obj end
                end
                
                if durationObj then
                    frame.castBar:SetMinMaxValues(0, 1)
                    local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                    if ok then
                        castBarSetup = true
                        frame.castBarDurationObject = durationObj
                        frame.castBarUseTimerBar = true
                    end
                end
            end
            
            -- Traditional fallback
            if not castBarSetup then
                local safeCastName = SafeValue(castName)
                local safeStartTime = SafeNumber(startTime)
                local safeEndTime = SafeNumber(endTime)
                
                if safeCastName and safeStartTime and safeEndTime then
                    local duration = (safeEndTime - safeStartTime) / 1000
                    local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                    frame.castBar:SetMinMaxValues(0, duration)
                    
                    if isChannel then
                        frame.castBar:SetValue(duration - elapsed)
                    else
                        frame.castBar:SetValue(elapsed)
                    end
                    
                    if frame.castTimer and cbs.showTimer then
                        frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                        frame.castTimer:Show()
                    end
                    
                    castBarSetup = true
                end
            end
            
            if castBarSetup then
                -- Spell name
                if frame.castText then
                    if cbs.showSpellName then
                        local safeCastName = SafeValue(castName)
                        if safeCastName then
                            frame.castText:SetText(safeCastName)
                        elseif castName then
                            local ok, text = pcall(string.format, "%s", castName)
                            if ok and text then frame.castText:SetText(text) end
                        end
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                
                -- Icon
                if frame.castIcon then
                    if cbs.showIcon then
                        local safeSpellID = SafeNumber(spellID)
                        if safeSpellID then
                            local spellTexture = GetSpellTextureByID(safeSpellID)
                            if spellTexture then
                                frame.castIcon:SetTexture(spellTexture)
                                frame.castIcon:Show()
                            end
                        elseif spellID then
                            pcall(function()
                                local spellTexture = GetSpellTextureByID(spellID)
                                if spellTexture then
                                    frame.castIcon:SetTexture(spellTexture)
                                    frame.castIcon:Show()
                                end
                            end)
                        end
                    else
                        frame.castIcon:Hide()
                    end
                end
                
                -- Timer text for timer bar mode
                if frame.castBarUseTimerBar and frame.castTimer and cbs.showTimer then
                    local safeRemaining = nil
                    if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                        local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                        if ok and r then safeRemaining = r end
                    end
                    if safeRemaining then
                        local ok, text = pcall(string.format, "%.1f", safeRemaining)
                        if ok and text then frame.castTimer:SetText(text) end
                    end
                    frame.castTimer:Show()
                end
                
                -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
                local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
                local safeSpellID = SafeNumber(spellID)
                local isImportant = false
                if TweaksUI.SpellAPI and safeSpellID then
                    isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
                end
                if isImportant then
                    if isChannel then
                        baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                    else
                        baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                    end
                elseif isChannel then
                    baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
                end
                ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
                
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        end
    elseif frame.castBar then
        frame.castBar:Hide()
        if frame.castText then frame.castText:Hide() end
        if frame.castTimer then frame.castTimer:Hide() end
        if frame.castIcon then frame.castIcon:Hide() end
    end
end

function UnitFrames:DestroyTankContainer()
    if InCombatLockdown() then return end
    
    -- Clean up Layout registration
    if containerWrappers["tank"] then
        if Layout and Layout.UnregisterElement then
            Layout:UnregisterElement("container_tank")
        end
        if containerWrappers["tank"].frame then
            containerWrappers["tank"].frame:Hide()
        end
        if containerWrappers["tank"].Destroy then
            containerWrappers["tank"]:Destroy()
        end
        containerWrappers["tank"] = nil
    end
    
    if tankContainer then
        tankContainer:Hide()
        tankContainer = nil
    end
    for i, frame in pairs(tankMemberFrames) do
        if frame then
            frame:Hide()
            frame:SetParent(nil)
        end
    end
    tankMemberFrames = {}
end

-- ============================================================================
-- BOSS FRAMES
-- ============================================================================

function UnitFrames:CreateBossContainer()
    if bossContainer then return bossContainer end
    if InCombatLockdown() then return end
    
    local bs = settings.boss
    if not bs then return end
    
    local containerSettings = bs.container
    local scale = containerSettings.scale or 1.0
    
    -- Create main container (no backdrop - Layout overlays provide visual feedback)
    local container = CreateFrame("Frame", "TweaksUI_BossContainer", UIParent)
    
    -- Position from settings initially - Layout will take over when registered
    container:SetPoint(containerSettings.anchor or "CENTER", UIParent, containerSettings.anchor or "CENTER", containerSettings.x or 0, containerSettings.y or 0)
    container:SetScale(scale)
    container:SetMovable(true)
    container:SetClampedToScreen(true)
    
    -- Drag handling is done by Layout system now
    container:EnableMouse(false)
    
    -- Set size to accommodate maximum possible bosses
    -- IMPORTANT: Never resize this container after creation - it inherits protected
    -- status from its SecureUnitButtonTemplate children and can't be modified during combat
    container:SetSize(bs.frame.width + 4, (bs.frame.height + bs.layout.spacing) * bs.maxBosses + 4)
    
    -- Show the container now - it will stay visible always
    -- Individual boss frames handle their own visibility via RegisterUnitWatch
    container:Show()
    
    bossContainer = container
    
    -- Create member frames for max bosses
    for i = 1, bs.maxBosses do
        self:CreateBossMemberFrame(i)
    end
    
    -- Register with Layout system
    local regContainer = container
    local regSettings = containerSettings
    
    local wrapper = UnitFrames:RegisterContainerWithLayout("boss", regContainer, regSettings)
    
    if not wrapper then
        C_Timer.After(0.2, function()
            if regContainer and not containerWrappers["boss"] then
                UnitFrames:RegisterContainerWithLayout("boss", regContainer, regSettings)
            end
        end)
    end
    
    return container
end

function UnitFrames:CreateBossMemberFrame(index)
    if InCombatLockdown() then return end
    if not bossContainer then return end
    
    local bs = settings.boss
    if not bs then return end
    
    -- Ensure castBar settings exist
    if not bs.castBar then
        bs.castBar = {
            enabled = true,
            height = 10,
            showIcon = true,
            showTimer = true,
            showSpellName = true,
        }
    end
    
    local frameName = "TweaksUI_BossFrame" .. index
    local frame = CreateFrame("Button", frameName, bossContainer, "SecureUnitButtonTemplate, BackdropTemplate")
    
    local unitID = "boss" .. index
    frame:SetAttribute("unit", unitID)
    frame:SetAttribute("type1", "target")
    frame:SetAttribute("type2", "menu")
    -- Note: RegisterUnitWatch is managed in UpdateBossFrames based on simulation state
    
    -- Frame size
    frame:SetSize(bs.frame.width, bs.frame.height)
    
    -- Initial positioning based on index (will be refined in UpdateBossFrames when not in combat)
    -- This ensures the frame has a valid position from creation
    local direction = bs.layout.direction or "DOWN"
    local spacing = bs.layout.spacing or 2
    local frameWidth = bs.frame.width
    local frameHeight = bs.frame.height
    local x, y = 2, -2
    
    if direction == "DOWN" then
        y = -2 - ((index - 1) * (frameHeight + spacing))
        frame:SetPoint("TOPLEFT", bossContainer, "TOPLEFT", x, y)
    elseif direction == "UP" then
        y = 2 + ((index - 1) * (frameHeight + spacing))
        frame:SetPoint("BOTTOMLEFT", bossContainer, "BOTTOMLEFT", x, y)
    elseif direction == "RIGHT" then
        x = 2 + ((index - 1) * (frameWidth + spacing))
        frame:SetPoint("TOPLEFT", bossContainer, "TOPLEFT", x, y)
    elseif direction == "LEFT" then
        x = -2 - ((index - 1) * (frameWidth + spacing))
        frame:SetPoint("TOPRIGHT", bossContainer, "TOPRIGHT", x, y)
    end
    
    -- Background
    if bs.frame.showBackground then
        frame:SetBackdrop({
            bgFile = "Interface\\Buttons\\WHITE8x8",
            edgeFile = bs.frame.showBorder and "Interface\\Buttons\\WHITE8x8" or nil,
            edgeSize = bs.frame.borderSize or 1,
        })
        local bgColor = bs.frame.bgColor or {0.05, 0.05, 0.05, 0.9}
        frame:SetBackdropColor(bgColor[1], bgColor[2], bgColor[3], bgColor[4])
        local borderColor = bs.frame.borderColor or {0.5, 0.1, 0.1, 1}
        frame:SetBackdropBorderColor(borderColor[1], borderColor[2], borderColor[3], borderColor[4])
    end
    
    -- Health bar
    local healthBar = CreateFrame("StatusBar", nil, frame)
    healthBar:SetStatusBarTexture(GetTexturePath(bs.healthBar.texture))
    healthBar:SetPoint("TOPLEFT", frame, "TOPLEFT", 1, -1)
    healthBar:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -1, -1)
    healthBar:SetHeight(bs.healthBar.height)
    healthBar:SetMinMaxValues(0, 1)
    healthBar:SetValue(1)
    -- Apply bar masking
    if TweaksUI.BarMasking and bs.healthBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(healthBar, bs.healthBar.maskShape)
    end
    frame.healthBar = healthBar
    
    local healthBg = healthBar:CreateTexture(nil, "BACKGROUND")
    healthBg:SetAllPoints()
    healthBg:SetColorTexture(unpack(bs.healthBar.bgColor or {0.1, 0.1, 0.1, 0.8}))
    frame.healthBg = healthBg
    
    -- Power bar
    local powerBar = CreateFrame("StatusBar", nil, frame)
    powerBar:SetStatusBarTexture(GetTexturePath(bs.powerBar.texture))
    powerBar:SetPoint("TOPLEFT", healthBar, "BOTTOMLEFT", 0, -1)
    powerBar:SetPoint("TOPRIGHT", healthBar, "BOTTOMRIGHT", 0, -1)
    powerBar:SetHeight(bs.powerBar.height)
    powerBar:SetMinMaxValues(0, 1)
    powerBar:SetValue(1)
    -- Apply bar masking
    if TweaksUI.BarMasking and bs.powerBar.maskShape then
        TweaksUI.BarMasking:ApplyToStatusBar(powerBar, bs.powerBar.maskShape)
    end
    frame.powerBar = powerBar
    
    local powerBg = powerBar:CreateTexture(nil, "BACKGROUND")
    powerBg:SetAllPoints()
    powerBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
    
    -- Name text
    local nameText = healthBar:CreateFontString(nil, "OVERLAY")
    nameText:SetFont(GetFontPath(DEFAULT_FONT), bs.nameText and bs.nameText.fontSize or 10, GetFontOutline())
    nameText:SetPoint("LEFT", healthBar, "LEFT", 3, 0)
    nameText:SetJustifyH("LEFT")
    frame.nameText = nameText
    
    -- Health text
    local healthText = healthBar:CreateFontString(nil, "OVERLAY")
    healthText:SetFont(GetFontPath(DEFAULT_FONT), bs.healthText and bs.healthText.fontSize or 10, GetFontOutline())
    healthText:SetPoint("RIGHT", healthBar, "RIGHT", -3, 0)
    healthText:SetJustifyH("RIGHT")
    frame.healthText = healthText
    
    -- Raid target icon
    local raidTarget = frame:CreateTexture(nil, "OVERLAY")
    raidTarget:SetSize(bs.raidTarget.size, bs.raidTarget.size)
    raidTarget:SetPoint(bs.raidTarget.position, frame, bs.raidTarget.position, bs.raidTarget.offsetX, bs.raidTarget.offsetY)
    raidTarget:Hide()
    frame.raidTarget = raidTarget
    
    -- Cast bar (always create, visibility controlled by enabled setting)
    if bs.castBar then
        local castBar = CreateFrame("StatusBar", nil, frame)
        castBar:SetStatusBarTexture(GetTexturePath(bs.castBar.texture))
        castBar:SetStatusBarColor(1, 0.7, 0, 1)
        castBar:SetPoint("TOPLEFT", powerBar, "BOTTOMLEFT", 0, -1)
        castBar:SetPoint("TOPRIGHT", powerBar, "BOTTOMRIGHT", 0, -1)
        castBar:SetHeight(bs.castBar.height or 10)
        castBar:SetMinMaxValues(0, 1)
        castBar:SetValue(0)
        castBar:Hide()
        frame.castBar = castBar
        
        local castBg = castBar:CreateTexture(nil, "BACKGROUND")
        castBg:SetAllPoints()
        castBg:SetColorTexture(0.05, 0.05, 0.05, 0.8)
        
        -- Always create text/icon/timer elements
        local castText = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        castText:SetPoint("CENTER", castBar, "CENTER", 0, 0)
        frame.castText = castText
        
        local cbHeight = bs.castBar.height or 10
        local castIcon = castBar:CreateTexture(nil, "OVERLAY")
        castIcon:SetSize(cbHeight, cbHeight)
        castIcon:SetPoint("LEFT", castBar, "LEFT", 1, 0)
        frame.castIcon = castIcon
        
        local castTimer = castBar:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        castTimer:SetPoint("RIGHT", castBar, "RIGHT", -2, 0)
        frame.castTimer = castTimer
    end
    
    -- Store index
    frame.bossIndex = index
    frame.unitID = unitID
    
    -- Register unit watch for automatic visibility handling
    -- This needs to be done during creation so the frame shows automatically when a boss appears
    -- Note: RegisterUnitWatch is protected and can only be called outside of combat
    if not InCombatLockdown() then
        RegisterUnitWatch(frame)
    else
        -- Queue for later registration when combat ends
        pendingBossUnitWatchUpdate = true
        -- Can't register unit watch during combat, so hide the frame for now
        -- It will be properly registered after combat ends
        frame:Hide()
    end
    
    -- Note: Don't call frame:Hide() here after RegisterUnitWatch
    -- The state driver will automatically hide the frame if the unit doesn't exist
    
    bossMemberFrames[index] = frame
    return frame
end

-- Hide Blizzard's boss frames ALWAYS (user preference to avoid double display)
local function HideBlizzardBossFrames()
    -- IMPORTANT: Don't modify Blizzard secure frames during combat to avoid taint
    if InCombatLockdown() then return end
    
    -- CRITICAL: Don't modify frames during Edit Mode
    if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
        return
    end
    
    -- ALWAYS hide Blizzard boss frames - user doesn't want them visible even if TUI boss frames disabled
    -- This avoids the double-display issue entirely
    
    -- Hide BossTargetFrameContainer (parent container) using off-screen positioning
    if BossTargetFrameContainer then
        MoveFrameOffScreen(BossTargetFrameContainer, "BossTargetFrameContainer")
    end
    
    -- Hide individual Boss1-5TargetFrame frames using off-screen positioning
    for i = 1, 5 do
        local frameName = "Boss" .. i .. "TargetFrame"
        local frame = _G[frameName]
        if frame then
            MoveFrameOffScreen(frame, frameName)
            
            -- Hook to keep hidden ALWAYS (only once)
            if not frame._tweaksBossHooked then
                hooksecurefunc(frame, "Show", function(self)
                    -- ALWAYS hide Blizzard boss frames
                    if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                        -- Use C_Timer to defer and check combat state
                        C_Timer.After(0, function()
                            if not InCombatLockdown() and self and self.SetAlpha then
                                self:SetAlpha(0)
                                self:SetScale(0.001)
                                pcall(function() self:EnableMouse(false) end)
                            end
                        end)
                    end
                end)
                hooksecurefunc(frame, "SetAlpha", function(self, alpha)
                    -- ALWAYS hide - use pcall to safely compare alpha (may be secret in Midnight)
                    local isPositive = true
                    pcall(function() isPositive = alpha > 0 end)
                    if isPositive then
                        if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                            C_Timer.After(0, function()
                                if not InCombatLockdown() and self and self.SetAlpha then
                                    self:SetAlpha(0)
                                end
                            end)
                        end
                    end
                end)
                -- Also hook SetScale to prevent it being restored
                hooksecurefunc(frame, "SetScale", function(self, scale)
                    -- ALWAYS hide
                    if scale > 0.01 then
                        if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                            C_Timer.After(0, function()
                                if not InCombatLockdown() and self and self.SetScale then
                                    self:SetScale(0.001)
                                end
                            end)
                        end
                    end
                end)
                frame._tweaksBossHooked = true
            end
        end
    end
    
    -- Also hook BossTargetFrameContainer
    if BossTargetFrameContainer and not BossTargetFrameContainer._tweaksBossHooked then
        hooksecurefunc(BossTargetFrameContainer, "Show", function(self)
            -- ALWAYS hide
            if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                C_Timer.After(0, function()
                    if not InCombatLockdown() then
                        HideBlizzardBossFrames()
                    end
                end)
            end
        end)
        hooksecurefunc(BossTargetFrameContainer, "SetAlpha", function(self, alpha)
            -- ALWAYS hide - use pcall to safely compare alpha (may be secret in Midnight)
            local isPositive = true
            pcall(function() isPositive = alpha > 0 end)
            if isPositive then
                if not EditModeManagerFrame or not EditModeManagerFrame:IsShown() then
                    C_Timer.After(0, function()
                        if self and self.SetAlpha then
                            self:SetAlpha(0)
                        end
                    end)
                end
            end
        end)
        BossTargetFrameContainer._tweaksBossHooked = true
    end
end

-- Re-apply boss frame hiding after combat ends and on zone changes - ALWAYS hide
local bossFrameRegenFrame = CreateFrame("Frame")
bossFrameRegenFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
bossFrameRegenFrame:RegisterEvent("INSTANCE_ENCOUNTER_ENGAGE_UNIT")
bossFrameRegenFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
bossFrameRegenFrame:RegisterEvent("ZONE_CHANGED_NEW_AREA")
bossFrameRegenFrame:SetScript("OnEvent", function(self, event)
    -- ALWAYS hide Blizzard boss frames
    -- Use short delay to let frames settle, then hide
    C_Timer.After(0.1, function()
        if not InCombatLockdown() then
            HideBlizzardBossFrames()
        end
    end)
    -- Also try again after longer delay in case frames were created late
    C_Timer.After(0.5, function()
        if not InCombatLockdown() then
            HideBlizzardBossFrames()
        end
    end)
end)

function UnitFrames:UpdateBossFrames()
    if not settings then return end
    local bs = settings.boss
    if not bs then return end
    
    local panelOpen = currentOpenPanel == "boss"
    
    -- Hide/show Blizzard boss frames based on our enabled state
    HideBlizzardBossFrames()
    
    -- If not enabled and not simulating and panel not open, hide container and return
    if not bs.enabled and not simulateBoss and not panelOpen then
        if bossContainer and not InCombatLockdown() then
            bossContainer:Hide()
        end
        return
    end
    
    if not bossContainer then
        self:CreateBossContainer()
        if not bossContainer then return end
    end
    
    -- Simulation mode check
    local isTestMode = simulateBoss or panelOpen
    local visibleCount = 0
    
    for i = 1, bs.maxBosses do
        local frame = bossMemberFrames[i]
        if not frame then
            self:CreateBossMemberFrame(i)
            frame = bossMemberFrames[i]
        end
        
        if frame then
            -- Handle RegisterUnitWatch based on simulation state
            -- IMPORTANT: RegisterUnitWatch/UnregisterUnitWatch are protected and cannot be called in combat
            if not InCombatLockdown() then
                if isTestMode then
                    -- Unregister unit watch so we can manually control visibility
                    UnregisterUnitWatch(frame)
                    visibleCount = visibleCount + 1
                    self:UpdateBossMemberFrame(i, isTestMode)
                else
                    -- Re-register unit watch for normal operation
                    RegisterUnitWatch(frame)
                    local unitID = "boss" .. i
                    if UnitExists(unitID) then
                        visibleCount = visibleCount + 1
                        self:UpdateBossMemberFrame(i, isTestMode)
                    end
                end
            else
                -- In combat - skip protected calls but still update visuals
                -- Queue update for after combat ends
                pendingBossUnitWatchUpdate = true
                local unitID = "boss" .. i
                if isTestMode or UnitExists(unitID) then
                    visibleCount = visibleCount + 1
                    self:UpdateBossMemberFrame(i, isTestMode)
                end
            end
        end
    end
    
    -- Position visible frames
    -- IMPORTANT: ClearAllPoints, SetPoint, SetSize are protected on secure frames AND their parent containers
    -- Skip ALL positioning during combat - frames will use their positions set during creation
    if visibleCount > 0 and not InCombatLockdown() then
        local direction = bs.layout.direction or "DOWN"
        local spacing = bs.layout.spacing or 2
        local frameWidth = bs.frame.width
        local frameHeight = bs.frame.height
        
        local x, y = 2, -2
        local visIndex = 0
        
        for i = 1, bs.maxBosses do
            local frame = bossMemberFrames[i]
            if frame then
                -- Check if this frame should be visible
                local shouldShow = isTestMode or UnitExists("boss" .. i)
                if shouldShow then
                    visIndex = visIndex + 1
                    
                    frame:ClearAllPoints()
                    if direction == "DOWN" then
                        y = -2 - ((visIndex - 1) * (frameHeight + spacing))
                        frame:SetPoint("TOPLEFT", bossContainer, "TOPLEFT", x, y)
                    elseif direction == "UP" then
                        y = 2 + ((visIndex - 1) * (frameHeight + spacing))
                        frame:SetPoint("BOTTOMLEFT", bossContainer, "BOTTOMLEFT", x, y)
                    elseif direction == "RIGHT" then
                        x = 2 + ((visIndex - 1) * (frameWidth + spacing))
                        frame:SetPoint("TOPLEFT", bossContainer, "TOPLEFT", x, y)
                    elseif direction == "LEFT" then
                        x = -2 - ((visIndex - 1) * (frameWidth + spacing))
                        frame:SetPoint("TOPRIGHT", bossContainer, "TOPRIGHT", x, y)
                    end
                end
            end
        end
        
        -- NOTE: Container size is set during creation to max possible size
        -- We don't resize it here to avoid protected function issues
    elseif visibleCount > 0 and InCombatLockdown() then
        -- In combat with visible bosses - queue layout update for after combat
        -- IMPORTANT: Cannot modify container or child frame positions during combat
        -- The frames should already be positioned from creation, and RegisterUnitWatch
        -- handles their visibility automatically
        pendingBossUnitWatchUpdate = true
    end
end

function UnitFrames:UpdateBossMemberFrame(index, isTestMode)
    local frame = bossMemberFrames[index]
    if not frame then return end
    
    local bs = settings.boss
    if not bs then return end
    
    local unitID = "boss" .. index
    
    -- Get unit data (real or simulated)
    local name, powerType
    local simData
    
    if isTestMode then
        -- Simulated boss data
        local simBosses = {
            { name = "Raid Boss", health = 85, maxHealth = 100, power = 100, maxPower = 100, powerType = 0 },
            { name = "Boss Add 1", health = 60, maxHealth = 100, power = 50, maxPower = 100, powerType = 0 },
            { name = "Boss Add 2", health = 45, maxHealth = 100, power = 30, maxPower = 100, powerType = 0 },
            { name = "Mini Boss", health = 90, maxHealth = 100, power = 80, maxPower = 100, powerType = 0 },
            { name = "Boss Pet", health = 30, maxHealth = 100, power = 100, maxPower = 100, powerType = 0 },
        }
        simData = simBosses[index] or simBosses[1]
        name = simData.name
        powerType = simData.powerType
        -- In test mode, RegisterUnitWatch is disabled so we can safely show
        -- Test mode only happens outside combat (checked in UpdateBossFrames)
        if not InCombatLockdown() then
            frame:Show()
        end
    else
        if not UnitExists(unitID) then
            -- Don't call Hide() directly - RegisterUnitWatch handles visibility
            -- Just bail out since there's nothing to update
            return
        end
        name = UnitName(unitID)
        powerType = UnitPowerType(unitID)
        -- Don't call Show() - RegisterUnitWatch handles visibility automatically
        -- The frame is already visible if we got here (UnitExists returned true)
    end
    
    -- Update health bar - just pass value straight through
    frame.healthBar:SetMinMaxValues(0, 100)
    local healthPct
    if isTestMode and simData then
        healthPct = (simData.maxHealth > 0) and ((simData.health / simData.maxHealth) * 100) or 100
    else
        -- Use SafeUnitHealthPercent for Midnight compatibility
        healthPct = SafeUnitHealthPercent(unitID, true) or 100
    end
    -- Use smooth animation if available (Midnight Beta 3+)
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    if bs.healthBar.colorMode == "health" then
        -- Health-based color - use Midnight curve if available
        if isTestMode and simData then
            local pct = healthPct / 100
            frame.healthBar:SetStatusBarColor(1 - pct, pct, 0)
        else
            -- Try using Midnight health gradient curve
            local r, g, b = GetHealthGradientColorMidnight(unitID, nil)
            frame.healthBar:SetStatusBarColor(r, g, b)
        end
    else
        local c = bs.healthBar.customColor or {0.8, 0.2, 0.2, 1}
        frame.healthBar:SetStatusBarColor(c[1], c[2], c[3])
    end
    
    -- Update power bar - pass values directly to StatusBar
    if bs.powerBar.enabled then
        frame.powerBar:Show()
        local power, maxPower
        if isTestMode and simData then
            power = simData.power * 1000
            maxPower = simData.maxPower * 1000
        else
            power = UnitPower(unitID)
            maxPower = UnitPowerMax(unitID)
        end
        frame.powerBar:SetMinMaxValues(0, maxPower)
        -- Use smooth animation if available (Midnight Beta 3+)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
        local powerColor = PowerBarColor[powerType] or {r = 0.2, g = 0.2, b = 0.8}
        frame.powerBar:SetStatusBarColor(powerColor.r, powerColor.g, powerColor.b)
    else
        frame.powerBar:Hide()
    end
    
    -- Update name text
    if bs.nameText.enabled then
        -- For real units, name may be a secret value - pass it directly to SetText
        -- Don't do string operations (length, sub, etc.) on potentially secret values
        if isTestMode and simData then
            -- Test mode: we can manipulate the string
            local displayName = name or "Boss"
            if bs.nameText.maxLength and bs.nameText.maxLength > 0 and #displayName > bs.nameText.maxLength then
                displayName = displayName:sub(1, bs.nameText.maxLength)
            end
            frame.nameText:SetText(displayName)
        else
            -- Real unit: name may be secret, pass directly to SetText (handles secrets natively)
            if name then
                frame.nameText:SetText(name)
            else
                frame.nameText:SetText("Boss")
            end
        end
        if bs.nameText.colorMode == "custom" then
            local c = bs.nameText.customColor or {1, 0.8, 0.2, 1}
            frame.nameText:SetTextColor(c[1], c[2], c[3])
        else
            frame.nameText:SetTextColor(1, 1, 1)
        end
        frame.nameText:Show()
    else
        frame.nameText:Hide()
    end
    
    -- Update health text
    if bs.healthText.enabled then
        local healthStr = ""
        local shouldAbbreviate = bs.healthText.abbreviate ~= false  -- Default to true
        if isTestMode and simData then
            local health = simData.health * 10000000
            local maxHealth = simData.maxHealth * 10000000
            if bs.healthText.format == "percent" then
                local pct = maxHealth > 0 and math.floor((health / maxHealth) * 100) or 0
                healthStr = pct .. "%"
            elseif bs.healthText.format == "current" then
                healthStr = shouldAbbreviate and AbbreviateNumber(health) or FormatNumber(health)
            elseif bs.healthText.format == "deficit" then
                local deficit = maxHealth - health
                if deficit > 0 then
                    healthStr = "-" .. (shouldAbbreviate and AbbreviateNumber(deficit) or FormatNumber(deficit))
                end
            elseif bs.healthText.format == "deficit_percent" then
                local pct = maxHealth > 0 and math.floor((health / maxHealth) * 100) or 0
                if pct < 100 then
                    healthStr = string.format("-%.0f%%", 100 - pct)
                end
            end
        else
            -- Helper to safely format health values
            -- Respects the abbreviate setting
            local function SafeFormatNumber(value)
                if value == nil then return "" end
                local success, result = pcall(function()
                    if shouldAbbreviate then
                        return AbbreviateLargeNumbers(value) or ""
                    else
                        return BreakUpLargeNumbers(value) or ""
                    end
                end)
                return success and result or ""
            end
            
            if bs.healthText.format == "percent" then
                local pct = SafeUnitHealthPercent(unitID, true) or SafeUnitHealthPercent(unitID, false)
                if pct then
                    healthStr = string.format("%.0f%%", pct)
                else
                    healthStr = "?%"
                end
            elseif bs.healthText.format == "current" then
                healthStr = SafeFormatNumber(UnitHealth(unitID))
            elseif bs.healthText.format == "deficit" then
                if UnitHealthMissing then
                    healthStr = "-" .. SafeFormatNumber(UnitHealthMissing(unitID))
                else
                    healthStr = SafeFormatNumber(UnitHealth(unitID))
                end
            elseif bs.healthText.format == "deficit_percent" then
                local pct = SafeUnitHealthPercent(unitID, true) or SafeUnitHealthPercent(unitID, false)
                if pct and pct < 100 then
                    healthStr = string.format("-%.0f%%", 100 - pct)
                end
            end
        end
        frame.healthText:SetText(healthStr)
        frame.healthText:Show()
    else
        frame.healthText:Hide()
    end
    
    -- Update raid target
    if bs.raidTarget.enabled then
        local raidTargetIndex = isTestMode and (index <= 2 and index or 0) or GetRaidTargetIndex(unitID)
        if raidTargetIndex and raidTargetIndex > 0 then
            frame.raidTarget:SetTexture("Interface\\TargetingFrame\\UI-RaidTargetingIcon_" .. raidTargetIndex)
            frame.raidTarget:Show()
        else
            frame.raidTarget:Hide()
        end
    else
        frame.raidTarget:Hide()
    end
    
    -- Update cast bar (if enabled and not simulating)
    local showBossPreview = isTestMode and frame.castBar and bs.castBar
    if (frame.castBar and bs.castBar and bs.castBar.enabled) or showBossPreview then
        local cbs = bs.castBar
        if not isTestMode then
            -- Real cast bar update (v2.1.3 - SetTimerDuration for secrets)
            local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unitID)
            local isChannel = false
            local isEmpowered = false
            local numEmpowerStages = nil
            if not castName then
                -- Check for empowered spell using event-driven flag
                if frame.isEmpoweredCast and frame.empowerSpellID then
                    if C_Spell and C_Spell.GetSpellInfo then
                        local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                        if success and spellInfo and spellInfo.name then
                            local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unitID)
                            if chStart and chEnd then
                                castName = spellInfo.name
                                startTime = chStart
                                endTime = chEnd
                                spellID = frame.empowerSpellID
                                isEmpowered = true
                                notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                                isChannel = false
                                numEmpowerStages = GetEmpowerNumStages(unitID) or 3
                            end
                        end
                    end
                end
                
                if not isEmpowered then
                    castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unitID)
                    isChannel = true
                    frame.empowerSpellID = nil
                    frame.isEmpoweredCast = false
                end
            else
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
            
            -- Setup/hide empowered dividers
            if isEmpowered then
                local safeStages = numEmpowerStages or 3
                if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
                if safeStages >= 2 then
                    SetupEmpowerDividers(frame.castBar, unitID, safeStages)
                else
                    HideEmpowerDividers(frame.castBar)
                end
            else
                HideEmpowerDividers(frame.castBar)
            end
            
            local castBarSetup = false
            
            -- Try SetTimerDuration (handles secrets)
            if castName and HAS_TIMER_BARS then
                local durationObj = nil
                if isEmpowered and UnitEmpoweredChannelDuration then
                    local ok, obj = pcall(UnitEmpoweredChannelDuration, unitID, true)
                    if ok and obj then durationObj = obj end
                elseif isChannel and UnitChannelDuration then
                    local ok, obj = pcall(UnitChannelDuration, unitID)
                    if ok and obj then durationObj = obj end
                elseif not isChannel and UnitCastingDuration then
                    local ok, obj = pcall(UnitCastingDuration, unitID)
                    if ok and obj then durationObj = obj end
                end
                
                if durationObj then
                    frame.castBar:SetMinMaxValues(0, 1)
                    local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                    if ok then
                        castBarSetup = true
                        frame.castBarDurationObject = durationObj
                        frame.castBarUseTimerBar = true
                    end
                end
            end
            
            -- Traditional fallback
            if not castBarSetup then
                local safeCastName = SafeValue(castName)
                local safeStartTime = SafeNumber(startTime)
                local safeEndTime = SafeNumber(endTime)
                
                if safeCastName and safeStartTime and safeEndTime then
                    local duration = (safeEndTime - safeStartTime) / 1000
                    local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                    frame.castBar:SetMinMaxValues(0, duration)
                    
                    if isChannel then
                        frame.castBar:SetValue(duration - elapsed)
                    else
                        frame.castBar:SetValue(elapsed)
                    end
                    
                    if frame.castTimer and (not cbs or cbs.showTimer) then
                        frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                        frame.castTimer:Show()
                    end
                    
                    castBarSetup = true
                end
            end
            
            if castBarSetup then
                -- Spell name
                if frame.castText then
                    if not cbs or cbs.showSpellName then
                        local safeCastName = SafeValue(castName)
                        if safeCastName then
                            frame.castText:SetText(safeCastName)
                        elseif castName then
                            local ok, text = pcall(string.format, "%s", castName)
                            if ok and text then frame.castText:SetText(text) end
                        end
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                
                -- Icon
                if frame.castIcon then
                    if not cbs or cbs.showIcon then
                        local safeSpellID = SafeNumber(spellID)
                        if safeSpellID then
                            local spellTexture = GetSpellTextureByID(safeSpellID)
                            if spellTexture then
                                frame.castIcon:SetTexture(spellTexture)
                                frame.castIcon:Show()
                            end
                        elseif spellID then
                            pcall(function()
                                local spellTexture = GetSpellTextureByID(spellID)
                                if spellTexture then
                                    frame.castIcon:SetTexture(spellTexture)
                                    frame.castIcon:Show()
                                end
                            end)
                        end
                    else
                        frame.castIcon:Hide()
                    end
                end
                
                -- Timer text for timer bar mode
                if frame.castBarUseTimerBar and frame.castTimer and (not cbs or cbs.showTimer) then
                    local safeRemaining = nil
                    if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                        local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                        if ok and r then safeRemaining = r end
                    end
                    if safeRemaining then
                        local ok, text = pcall(string.format, "%.1f", safeRemaining)
                        if ok and text then frame.castTimer:SetText(text) end
                    end
                    frame.castTimer:Show()
                end
                
                -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
                local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
                local safeSpellID = SafeNumber(spellID)
                local isImportant = false
                if TweaksUI.SpellAPI and safeSpellID then
                    isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
                end
                if isImportant then
                    if isChannel then
                        baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                    else
                        baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                    end
                elseif isChannel then
                    baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
                end
                ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
                
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        else
            -- Show a simulated cast bar
            if index == 1 then
                frame.castBar:SetMinMaxValues(0, 3)
                frame.castBar:SetValue(1.5)
                if frame.castText then 
                    if not cbs or cbs.showSpellName then
                        frame.castText:SetText("Simulated Cast")
                        frame.castText:Show()
                    else
                        frame.castText:Hide()
                    end
                end
                if frame.castTimer then 
                    if not cbs or cbs.showTimer then
                        frame.castTimer:SetText("1.5")
                        frame.castTimer:Show()
                    else
                        frame.castTimer:Hide()
                    end
                end
                if frame.castIcon then 
                    if not cbs or cbs.showIcon then
                        frame.castIcon:SetTexture("Interface\\Icons\\Spell_Shadow_UnholyFrenzy")
                        frame.castIcon:Show()
                    else
                        frame.castIcon:Hide()
                    end
                end
                frame.castBar:SetStatusBarColor(1, 0.7, 0, 1)
                frame.castBar:Show()
            else
                frame.castBar:Hide()
                if frame.castText then frame.castText:Hide() end
                if frame.castTimer then frame.castTimer:Hide() end
                if frame.castIcon then frame.castIcon:Hide() end
            end
        end
    end
end

-- ============================================================================
-- BOSS FRAME DATA-ONLY UPDATE (Performance optimization)
-- ============================================================================
-- Lightweight update function for frequent events (UNIT_HEALTH, UNIT_SPELLCAST)
-- Only updates dynamic data: health, power, health text, cast bar
-- Does NOT update layout, fonts, positions, etc.
-- The full UpdateBossMemberFrame should only be called on settings changes

function UnitFrames:UpdateBossMemberDataOnly(index)
    local frame = bossMemberFrames[index]
    if not frame then return end
    
    local bs = settings and settings.boss
    if not bs then return end
    
    local unitID = "boss" .. index
    
    -- Quick exit if unit doesn't exist
    if not UnitExists(unitID) then
        return
    end
    
    -- ========================================================================
    -- HEALTH BAR UPDATE
    -- ========================================================================
    local healthPct = SafeUnitHealthPercent(unitID, true) or 100
    SetBarValueSmooth(frame.healthBar, healthPct, HAS_MIDNIGHT_APIS, settings.general)
    
    -- Health bar color (only health mode needs recalculation)
    if bs.healthBar.colorMode == "health" then
        local r, g, b = GetHealthGradientColorMidnight(unitID, nil)
        frame.healthBar:SetStatusBarColor(r, g, b)
    end
    -- Custom colors don't change, skip them
    
    -- ========================================================================
    -- POWER BAR UPDATE
    -- ========================================================================
    if bs.powerBar.enabled and frame.powerBar then
        local power = UnitPower(unitID)
        local maxPower = UnitPowerMax(unitID)
        frame.powerBar:SetMinMaxValues(0, maxPower)
        SetBarValueSmooth(frame.powerBar, power, HAS_MIDNIGHT_APIS, settings.general)
    end
    
    -- ========================================================================
    -- HEALTH TEXT UPDATE
    -- ========================================================================
    if bs.healthText.enabled and frame.healthText then
        local healthStr = ""
        local format = bs.healthText.format
        
        if format == "percent" then
            healthStr = string.format("%.0f%%", healthPct)
        elseif format == "current" then
            local health = UnitHealth(unitID)
            if bs.healthText.abbreviate ~= false then
                local success, result = pcall(AbbreviateLargeNumbers, health)
                healthStr = success and result or ""
            else
                local success, result = pcall(BreakUpLargeNumbers, health)
                healthStr = success and result or ""
            end
        elseif format == "deficit" then
            if UnitHealthMissing then
                local missing = UnitHealthMissing(unitID)
                if bs.healthText.abbreviate ~= false then
                    local success, result = pcall(AbbreviateLargeNumbers, missing)
                    healthStr = success and ("-" .. result) or ""
                else
                    local success, result = pcall(BreakUpLargeNumbers, missing)
                    healthStr = success and ("-" .. result) or ""
                end
            end
        elseif format == "deficit_percent" then
            if healthPct < 100 then
                healthStr = string.format("-%.0f%%", 100 - healthPct)
            end
        end
        
        frame.healthText:SetText(healthStr)
    end
    
    -- ========================================================================
    -- CAST BAR UPDATE (v2.1.3 - SetTimerDuration for secret values)
    -- ========================================================================
    if frame.castBar and bs.castBar and bs.castBar.enabled then
        local cbs = bs.castBar
        local castName, _, _, startTime, endTime, _, _, notInterruptible, spellID = UnitCastingInfo(unitID)
        local isChannel = false
        local isEmpowered = false
        local numEmpowerStages = nil
        if not castName then
            -- Check for empowered spell using event-driven flag
            if frame.isEmpoweredCast and frame.empowerSpellID then
                if C_Spell and C_Spell.GetSpellInfo then
                    local success, spellInfo = pcall(function() return C_Spell.GetSpellInfo(frame.empowerSpellID) end)
                    if success and spellInfo and spellInfo.name then
                        local chName, _, _, chStart, chEnd, _, chNotInterruptible = UnitChannelInfo(unitID)
                        if chStart and chEnd then
                            castName = spellInfo.name
                            startTime = chStart
                            endTime = chEnd
                            spellID = frame.empowerSpellID
                            isEmpowered = true
                            notInterruptible = chNotInterruptible  -- Capture notInterruptible for empowered
                            isChannel = false
                            numEmpowerStages = GetEmpowerNumStages(unitID) or 3
                        end
                    end
                end
            end
            
            if not isEmpowered then
                castName, _, _, startTime, endTime, _, notInterruptible, spellID = UnitChannelInfo(unitID)
                isChannel = true
                frame.empowerSpellID = nil
                frame.isEmpoweredCast = false
            end
        else
            frame.empowerSpellID = nil
            frame.isEmpoweredCast = false
        end
        
        -- Setup/hide empowered dividers
        if isEmpowered then
            local safeStages = numEmpowerStages or 3
            if type(safeStages) ~= "number" then safeStages = SafeNumber(safeStages) or 3 end
            if safeStages >= 2 then
                SetupEmpowerDividers(frame.castBar, unitID, safeStages)
            else
                HideEmpowerDividers(frame.castBar)
            end
        else
            HideEmpowerDividers(frame.castBar)
        end
        
        local castBarSetup = false
        
        -- Try SetTimerDuration for boss frames (handles secrets)
        if castName and HAS_TIMER_BARS then
            local durationObj = nil
            if isEmpowered and UnitEmpoweredChannelDuration then
                local ok, obj = pcall(UnitEmpoweredChannelDuration, unitID, true)
                if ok and obj then durationObj = obj end
            elseif isChannel and UnitChannelDuration then
                local ok, obj = pcall(UnitChannelDuration, unitID)
                if ok and obj then durationObj = obj end
            elseif not isChannel and UnitCastingDuration then
                local ok, obj = pcall(UnitCastingDuration, unitID)
                if ok and obj then durationObj = obj end
            end
            
            if durationObj then
                frame.castBar:SetMinMaxValues(0, 1)
                local ok = pcall(frame.castBar.SetTimerDuration, frame.castBar, durationObj, BAR_INTERPOLATION)
                if ok then
                    castBarSetup = true
                    frame.castBarDurationObject = durationObj
                    frame.castBarUseTimerBar = true
                end
            end
        end
        
        -- Traditional fallback
        if not castBarSetup then
            local safeCastName = SafeValue(castName)
            local safeStartTime = SafeNumber(startTime)
            local safeEndTime = SafeNumber(endTime)
            
            if safeCastName and safeStartTime and safeEndTime then
                local duration = (safeEndTime - safeStartTime) / 1000
                local elapsed = (GetTime() * 1000 - safeStartTime) / 1000
                frame.castBar:SetMinMaxValues(0, duration)
                
                if isChannel then
                    frame.castBar:SetValue(duration - elapsed)
                else
                    frame.castBar:SetValue(elapsed)
                end
                
                if frame.castTimer and cbs.showTimer then
                    frame.castTimer:SetText(string.format("%.1f", duration - elapsed))
                    frame.castTimer:Show()
                end
                
                castBarSetup = true
            end
        end
        
        if castBarSetup then
            -- Spell name
            if frame.castText then
                if cbs.showSpellName then
                    local safeCastName = SafeValue(castName)
                    if safeCastName then
                        frame.castText:SetText(safeCastName)
                    elseif castName then
                        local ok, text = pcall(string.format, "%s", castName)
                        if ok and text then frame.castText:SetText(text) end
                    end
                    frame.castText:Show()
                else
                    frame.castText:Hide()
                end
            end
            
            -- Icon
            if frame.castIcon and cbs.showIcon then
                local safeSpellID = SafeNumber(spellID)
                if safeSpellID then
                    local spellTexture = GetSpellTextureByID(safeSpellID)
                    if spellTexture then
                        frame.castIcon:SetTexture(spellTexture)
                        frame.castIcon:Show()
                    end
                elseif spellID then
                    pcall(function()
                        local spellTexture = GetSpellTextureByID(spellID)
                        if spellTexture then
                            frame.castIcon:SetTexture(spellTexture)
                            frame.castIcon:Show()
                        end
                    end)
                end
            end
            
            -- Timer text for timer bar mode
            if frame.castBarUseTimerBar and frame.castTimer and cbs.showTimer then
                local safeRemaining = nil
                if frame.castBarDurationObject and frame.castBarDurationObject.GetRemainingDuration then
                    local ok, r = pcall(frame.castBarDurationObject.GetRemainingDuration, frame.castBarDurationObject)
                    if ok and r then safeRemaining = r end
                end
                if safeRemaining then
                    local ok, text = pcall(string.format, "%.1f", safeRemaining)
                    if ok and text then frame.castTimer:SetText(text) end
                end
                frame.castTimer:Show()
            end
            
            -- Color (v2.1.6 - handles secret notInterruptible, empowered, important)
            local baseR, baseG, baseB = 1, 0.7, 0  -- Cast color
            local safeSpellID = SafeNumber(spellID)
            local isImportant = false
            if TweaksUI.SpellAPI and safeSpellID then
                isImportant = TweaksUI.SpellAPI:IsImportant(safeSpellID)
            end
            if isImportant then
                if isChannel then
                    baseR, baseG, baseB = 0.8, 0.2, 1  -- Important channel (purple)
                else
                    baseR, baseG, baseB = 1, 0.4, 0  -- Important cast (red-orange)
                end
            elseif isChannel then
                baseR, baseG, baseB = 0, 0.7, 1  -- Channel color (blue)
            end
            ApplyCastBarColor(frame.castBar, notInterruptible, baseR, baseG, baseB, false)
            
            frame.castBar:Show()
        else
            frame.castBar:Hide()
            if frame.castText then frame.castText:Hide() end
            if frame.castTimer then frame.castTimer:Hide() end
            if frame.castIcon then frame.castIcon:Hide() end
        end
    end
end

function UnitFrames:DestroyBossContainer()
    if InCombatLockdown() then return end
    
    -- Clean up Layout registration
    if containerWrappers["boss"] then
        if Layout and Layout.UnregisterElement then
            Layout:UnregisterElement("container_boss")
        end
        if containerWrappers["boss"].frame then
            containerWrappers["boss"].frame:Hide()
        end
        if containerWrappers["boss"].Destroy then
            containerWrappers["boss"]:Destroy()
        end
        containerWrappers["boss"] = nil
    end
    
    if bossContainer and not InCombatLockdown() then
        bossContainer:Hide()
        bossContainer = nil
    end
    for i, frame in pairs(bossMemberFrames) do
        if frame and not InCombatLockdown() then
            frame:Hide()
            frame:SetParent(nil)
        end
    end
    if not InCombatLockdown() then
        bossMemberFrames = {}
    end
end

function UnitFrames:OnEnable()
    TweaksUI:PrintDebug("Unit Frames module enabling...")
    
    self.enabled = true
    
    -- If we're in combat, defer most initialization until after combat
    if InCombatLockdown() then
        TweaksUI:PrintDebug("Unit Frames: In combat, deferring frame creation...")
        local deferFrame = CreateFrame("Frame")
        deferFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
        deferFrame:SetScript("OnEvent", function(self)
            self:UnregisterAllEvents()
            TweaksUI:PrintDebug("Unit Frames: Combat ended, completing initialization...")
            UnitFrames:CompleteEnableAfterCombat()
        end)
        
        -- Still setup events so we're ready when combat ends
        SetupEventFrame()
        return
    end
    
    self:CompleteEnableAfterCombat()
    
    -- Delayed refresh to pick up global media settings after all modules have initialized
    C_Timer.After(0.5, function()
        if self.enabled and TweaksUI.Media then
            -- Check if global settings are enabled and refresh if so
            if TweaksUI.Media:IsUsingGlobalTexture() or TweaksUI.Media:IsUsingGlobalFont() then
                self:RefreshAllFrames()
            end
        end
    end)
end

function UnitFrames:CompleteEnableAfterCombat()
    TweaksUI:PrintDebug("CompleteEnableAfterCombat starting")
    
    -- Create and show frames for individual units
    for _, unit in ipairs(INDIVIDUAL_UNITS) do
        if settings[unit] and settings[unit].enabled then
            CreateCustomUnitFrame(unit)
            UpdateFrameLayout(unit)
            UpdateFrameData(unit)  -- Initialize data after layout
            MaskBlizzardFrame(unit)
        end
    end
    
    -- Initialize stagger ticker for Brewmaster Monks (after player frame is created)
    InitStaggerTicker()
    
    -- Initialize Maelstrom Weapon ticker for Enhancement Shamans
    InitMaelstromWeaponTicker()
    
    -- Initialize party/raid health update ticker
    InitPartyHealthTicker()
    
    -- Initialize individual frame range ticker (for target, focus, etc.)
    IndividualRangeFade:Start()
    
    -- Register individual unit frames with Layout system (after a brief delay to ensure Layout is ready)
    C_Timer.After(0.2, function()
        -- Setup Layout mode callbacks for simulations
        SetupLayoutModeCallbacks()
        
        for _, unit in ipairs(INDIVIDUAL_UNITS) do
            if settings[unit] and settings[unit].enabled and customFrames[unit] then
                RegisterUnitFrameWithLayout(unit)
                -- Re-run layout to properly parent to wrapper
                UpdateFrameLayout(unit)
                UpdateFrameData(unit)  -- Ensure data is updated after layout
            end
        end
    end)
    
    -- Always create party container for Edit Mode support (hidden if not enabled/in group)
    if settings.party then
        TweaksUI:PrintDebug("Creating party container for Edit Mode support")
        self:CreatePartyContainer()
        
        -- Initialize submodules (Sorting, RangeFade, HealPrediction, TestMode)
        if TweaksUI.UnitFramesSorting and TweaksUI.UnitFramesSorting.Init then
            TweaksUI.UnitFramesSorting:Init(self)
        end
        if TweaksUI.UnitFramesRangeFade and TweaksUI.UnitFramesRangeFade.Init then
            TweaksUI.UnitFramesRangeFade:Init(self)
            -- Start RangeFade ticker if enabled
            local rfSettings = settings.party.rangeFade
            if rfSettings and rfSettings.enabled then
                TweaksUI.UnitFramesRangeFade:Start(rfSettings.checkInterval or 0.2)
            end
        end
        if TweaksUI.UnitFramesHealPrediction and TweaksUI.UnitFramesHealPrediction.Init then
            TweaksUI.UnitFramesHealPrediction:Init(self)
            -- Start HealPrediction if enabled
            local hpSettings = settings.party.healPrediction
            if hpSettings and hpSettings.enabled then
                TweaksUI.UnitFramesHealPrediction:RegisterEvents()
                TweaksUI.UnitFramesHealPrediction:Start(0.05)
            end
        end
        if TweaksUI.UnitFramesTestMode and TweaksUI.UnitFramesTestMode.Init then
            TweaksUI.UnitFramesTestMode:Init(self)
        end
        
        if settings.party.enabled then
            HookBlizzardPartyFrames()
            self:UpdatePartyFrames()
            -- Show if in group, otherwise hide
            if partyContainer and not IsInGroup() then
                partyContainer:Hide()
            end
        else
            -- Not enabled, keep hidden
            if partyContainer then
                partyContainer:Hide()
            end
        end
        TweaksUI:PrintDebug("Party container created: " .. tostring(partyContainer))
    end
    
    -- Always create BOTH raid containers for Edit Mode support (hidden if not enabled/in raid)
    if settings.raid then
        TweaksUI:PrintDebug("Creating raid containers for Edit Mode support")
        self:CreateRaidContainer("small")
        self:CreateRaidContainer("large")
        
        if settings.raid.enabled then
            self:UpdateRaidFrames()
            -- Hide containers if not in raid
            if not IsInRaid() then
                if raidSmallContainer then raidSmallContainer:Hide() end
                if raidLargeContainer then raidLargeContainer:Hide() end
            end
        else
            -- Not enabled, keep hidden
            if raidSmallContainer then raidSmallContainer:Hide() end
            if raidLargeContainer then raidLargeContainer:Hide() end
        end
        TweaksUI:PrintDebug("Raid containers created: small=" .. tostring(raidSmallContainer) .. ", large=" .. tostring(raidLargeContainer))
    end
    
    -- Always create tank container for Layout support (hidden if not enabled/no tanks)
    if settings.tanks then
        TweaksUI:PrintDebug("Creating tank container for Layout support")
        self:CreateTankContainer()
        
        if settings.tanks.enabled then
            self:UpdateTankFrames()
        end
        -- Hide by default - will show when tanks exist
        if tankContainer then
            tankContainer:Hide()
        end
        TweaksUI:PrintDebug("Tank container created: " .. tostring(tankContainer))
    end
    
    -- Always create boss container for Layout support (hidden if not enabled/no bosses)
    if settings.boss then
        TweaksUI:PrintDebug("Creating boss container for Layout support")
        self:CreateBossContainer()
        
        if settings.boss.enabled then
            self:UpdateBossFrames()
        end
        -- IMPORTANT: Keep container ALWAYS visible - individual frames handle their own
        -- visibility via RegisterUnitWatch. We can't show/hide container during combat
        -- because it inherits protected status from its SecureUnitButtonTemplate children.
        if bossContainer and not InCombatLockdown() then
            bossContainer:Show()
        end
        TweaksUI:PrintDebug("Boss container created: " .. tostring(bossContainer))
    end
    
    -- Setup events (if not already set up)
    SetupEventFrame()
    
    -- Initial data update - this populates the frames with current unit data
    C_Timer.After(0.3, function()
        TweaksUI:PrintDebug("C_Timer.After 0.3 running - registering frames with Edit Mode")
        
        for unit, _ in pairs(customFrames) do
            UpdateFrameData(unit)
            RegisterWithEditMode(unit)
        end
        
        -- Register party container with Edit Mode
        if partyContainer then
            TweaksUI:PrintDebug("Registering party container with Edit Mode")
            self:RegisterContainerWithEditMode("party")
        else
            TweaksUI:PrintDebug("Party container is nil, skipping registration")
        end
        
        -- Register raid containers with Edit Mode
        if raidSmallContainer then
            TweaksUI:PrintDebug("Registering small raid container with Edit Mode")
            self:RegisterContainerWithEditMode("raid_small")
        else
            TweaksUI:PrintDebug("Small raid container is nil, skipping registration")
        end
        
        if raidLargeContainer then
            TweaksUI:PrintDebug("Registering large raid container with Edit Mode")
            self:RegisterContainerWithEditMode("raid_large")
        else
            TweaksUI:PrintDebug("Large raid container is nil, skipping registration")
        end
        
        -- Update party frames if enabled
        if settings.party and settings.party.enabled then
            self:UpdatePartyFrames()
            
            -- Initialize range checker if enabled
            if settings.party.rangeCheck and settings.party.rangeCheck.enabled then
                InitRangeChecker()
            end
        end
        
        -- Update raid frames if enabled
        if settings.raid and settings.raid.enabled then
            self:UpdateRaidFrames()
            
            -- Initialize range checker if enabled for raid
            local shouldStartRangeChecker = false
            if settings.raid.small and settings.raid.small.rangeCheck and settings.raid.small.rangeCheck.enabled then
                shouldStartRangeChecker = true
            end
            if settings.raid.large and settings.raid.large.rangeCheck and settings.raid.large.rangeCheck.enabled then
                shouldStartRangeChecker = true
            end
            if shouldStartRangeChecker then
                InitRangeChecker()
            end
        end
        
        -- Update tank frames if enabled
        if settings.tanks and settings.tanks.enabled then
            self:CreateTankContainer()
            self:UpdateTankFrames()
            
            -- Initialize range checker if enabled for tanks
            if settings.tanks.rangeCheck and settings.tanks.rangeCheck.enabled then
                InitRangeChecker()
            end
        end
        
        -- Update boss frames if enabled
        if settings.boss and settings.boss.enabled then
            self:CreateBossContainer()
            self:UpdateBossFrames()
        end
        
        -- If Edit Mode is currently active, hide Blizzard unit frame selections
        if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
            HideAllCustomUnitFramesFromEditMode()
        end
        
        -- Initialize visibility manager
        VisibilityManager:Initialize()
    end)
end

function UnitFrames:OnDisable()
    TweaksUI:PrintDebug("Unit Frames module disabling...")
    
    -- Can't modify secure frames during combat
    if InCombatLockdown() then
        -- Queue for after combat
        local f = CreateFrame("Frame")
        f:RegisterEvent("PLAYER_REGEN_ENABLED")
        f:SetScript("OnEvent", function(self)
            self:UnregisterAllEvents()
            UnitFrames:OnDisable()
        end)
        return
    end
    
    self.enabled = false
    
    -- Stop range checker
    StopRangeChecker()
    
    -- Stop stagger ticker
    StopStaggerTicker()
    
    -- Stop Maelstrom Weapon ticker
    StopMaelstromWeaponTicker()
    
    -- Stop party health ticker
    StopPartyHealthTicker()
    
    -- Hide custom frames and unregister state drivers
    for _, frame in pairs(customFrames) do
        if frame._stateDriverRegistered then
            UnregisterStateDriver(frame, "visibility")
            frame._stateDriverRegistered = nil
        end
        frame:Hide()
    end
    
    -- Destroy group containers
    self:DestroyPartyContainer()
    self:DestroyRaidContainer()
    self:DestroyTankContainer()
    self:DestroyBossContainer()
    
    -- Unmask Blizzard frames
    for unit, _ in pairs(UnitFrames.BlizzState.framesMasked) do
        UnmaskBlizzardFrame(unit)
    end
end

-- Handle profile changes
function UnitFrames:OnProfileChanged(profileName)
    TweaksUI:PrintDebug("UnitFrames OnProfileChanged:", profileName)
    
    -- Invalidate settings cache
    settings = nil
    
    -- Reload settings from new profile
    settings = TweaksUI.Database:GetModuleSettings(TweaksUI.MODULE_IDS.UNIT_FRAMES) or {}
    
    -- Ensure defaults are applied
    InitializeSettings()
    
    -- If module is enabled, refresh everything
    if self.enabled then
        -- Refresh all individual unit frames
        for unit, frame in pairs(customFrames) do
            self:RefreshFrame(unit)
        end
        
        -- Refresh party frames
        if partyContainer then
            self:UpdatePartyFrames()
        end
        
        -- Refresh raid frames
        if raidSmallContainer or raidLargeContainer then
            self:UpdateRaidFrames()
        end
        
        -- Refresh tank frames
        if tankContainer then
            self:UpdateTankFrames()
        end
        
        -- Refresh boss frames
        if bossContainer then
            self:UpdateBossFrames()
        end
        
        TweaksUI:PrintDebug("Profile change applied to UnitFrames module")
    end
end

-- Refresh all active unit frames
function UnitFrames:RefreshAllFrames()
    if not settings then return end
    
    -- Refresh individual unit frames
    local individualUnits = {"player", "target", "focus", "targettarget", "pet"}
    for _, unit in ipairs(individualUnits) do
        if customFrames[unit] and settings[unit] and settings[unit].enabled then
            UpdateFrameLayout(unit)
            UpdateFrameData(unit)
        end
    end
    
    -- Refresh party frames
    if settings.party and settings.party.enabled then
        pcall(function() self:UpdatePartyFrames() end)
    end
    
    -- Refresh raid frames
    if settings.raid_small and settings.raid_small.enabled then
        pcall(function() self:UpdateRaidFrames() end)
    end
    if settings.raid_large and settings.raid_large.enabled then
        pcall(function() self:UpdateRaidFrames() end)
    end
    
    -- Refresh tank frames
    if settings.tanks and settings.tanks.enabled then
        pcall(function() self:UpdateTankFrames() end)
    end
    
    -- Refresh boss frames
    if settings.boss and settings.boss.enabled then
        pcall(function() self:UpdateBossFrames() end)
    end
end

function UnitFrames:RefreshFrame(unit)
    -- Handle raid_small and raid_large by refreshing the appropriate raid container
    if unit == "raid_small" or unit == "raid_large" then
        local sizeType = unit == "raid_small" and "small" or "large"
        local container = sizeType == "small" and raidSmallContainer or raidLargeContainer
        local isTestMode = (sizeType == "small" and simulateRaidSmall) or (sizeType == "large" and simulateRaidLarge)
        local displayCount = sizeType == "small" and 20 or 40
        
        if container then
            -- Update the layout and all frames
            self:UpdateRaidLayoutForSize(sizeType, displayCount)
        end
        return
    end
    
    -- Handle tank frames
    if unit == "tanks" then
        if settings.tanks and settings.tanks.enabled then
            if not tankContainer then
                self:CreateTankContainer()
            end
            if tankContainer then
                self:UpdateTankFrames()
                self:RegisterContainerWithEditMode("tanks")
            end
        end
        return
    end
    
    -- Handle boss frames
    if unit == "boss" then
        if settings.boss and settings.boss.enabled then
            if not bossContainer then
                self:CreateBossContainer()
            end
            if bossContainer then
                self:UpdateBossFrames()
                self:RegisterContainerWithEditMode("boss")
            end
        end
        return
    end
    
    if not settings or not settings[unit] then return end
    
    -- Special handling for party frames
    if unit == "party" then
        if settings.party.enabled then
            if partyContainer then
                -- Light-weight refresh: just update existing frames
                self:UpdatePartyFrames()
            else
                -- Container doesn't exist, create it
                self:CreatePartyContainer()
                self:UpdatePartyFrames()
                self:RegisterContainerWithEditMode("party")
            end
            -- Hide if not in group (unless Edit Mode is open, panel is open, or previewing)
            if partyContainer and not IsInGroup() and not previewParty then
                if not (EditModeManagerFrame and EditModeManagerFrame:IsShown()) and currentOpenPanel ~= "party" then
                    partyContainer:Hide()
                end
            end
        else
            -- Party disabled, destroy container
            self:DestroyPartyContainer()
        end
        return
    end
    
    -- Special handling for raid frames
    if unit == "raid" then
        if settings.raid.enabled then
            -- Ensure both containers exist
            if not raidSmallContainer then
                self:CreateRaidContainer("small")
                self:RegisterContainerWithEditMode("raid_small")
            end
            if not raidLargeContainer then
                self:CreateRaidContainer("large")
                self:RegisterContainerWithEditMode("raid_large")
            end
            self:UpdateRaidFrames()
            
            -- Hide if not in raid (unless Edit Mode is open, panel is open, or simulating)
            if not IsInRaid() then
                local editModeOpen = EditModeManagerFrame and EditModeManagerFrame:IsShown()
                if not editModeOpen then
                    if raidSmallContainer and not simulateRaidSmall and currentOpenPanel ~= "raid_small" then 
                        raidSmallContainer:Hide() 
                    end
                    if raidLargeContainer and not simulateRaidLarge and currentOpenPanel ~= "raid_large" then 
                        raidLargeContainer:Hide() 
                    end
                end
            end
        else
            -- Raid disabled, destroy containers
            self:DestroyRaidContainer()
        end
        return
    end
    
    if settings[unit].enabled then
        if not customFrames[unit] then
            CreateCustomUnitFrame(unit)
        end
        UpdateFrameLayout(unit)
        UpdateFrameData(unit)
        MaskBlizzardFrame(unit)
        
        -- Hide Edit Mode selection if Edit Mode is active
        if EditModeManagerFrame and EditModeManagerFrame:IsShown() then
            HideUnitFrameFromEditMode(unit)
        end
        
        -- Update Blizzard cast bar visibility based on custom cast bar settings
        UpdateBlizzardCastBarVisibility()
    else
        if customFrames[unit] then
            -- Unregister state driver before hiding
            if customFrames[unit]._stateDriverRegistered then
                UnregisterStateDriver(customFrames[unit], "visibility")
                customFrames[unit]._stateDriverRegistered = nil
            end
            if not InCombatLockdown() then
                customFrames[unit]:Hide()
            end
        end
        UnmaskBlizzardFrame(unit)
        
        -- Update Blizzard cast bar visibility
        UpdateBlizzardCastBarVisibility()
    end
end

function UnitFrames:CopySettings(fromUnit, toUnit)
    if not settings[fromUnit] or not settings[toUnit] then return end
    
    local function DeepCopy(orig)
        if type(orig) ~= "table" then return orig end
        local copy = {}
        for k, v in pairs(orig) do
            copy[k] = DeepCopy(v)
        end
        return copy
    end
    
    -- Save position
    local savedPos = {
        x = settings[toUnit].frame.x,
        y = settings[toUnit].frame.y,
        anchor = settings[toUnit].frame.anchor,
    }
    
    -- Copy
    settings[toUnit] = DeepCopy(settings[fromUnit])
    
    -- Restore position
    settings[toUnit].frame.x = savedPos.x
    settings[toUnit].frame.y = savedPos.y
    settings[toUnit].frame.anchor = savedPos.anchor
    
    self:RefreshFrame(toUnit)
    TweaksUI:Print("Settings copied from " .. fromUnit .. " to " .. toUnit)
end

-- ============================================================================
-- PROFILE IMPORT/EXPORT
-- ============================================================================

-- JSON-like serialization
local function serializeValue(val)
    local t = type(val)
    if t == "string" then
        return "\"" .. val:gsub("\\", "\\\\"):gsub("\"", "\\\""):gsub("\n", "\\n") .. "\""
    elseif t == "number" then
        return tostring(val)
    elseif t == "boolean" then
        return val and "true" or "false"
    elseif t == "table" then
        local parts = {}
        -- Check if it's an array
        local isArray = true
        local maxIndex = 0
        for k, v in pairs(val) do
            if type(k) ~= "number" or k < 1 or k ~= math.floor(k) then
                isArray = false
                break
            end
            maxIndex = math.max(maxIndex, k)
        end
        
        if isArray and maxIndex > 0 then
            for i = 1, maxIndex do
                table.insert(parts, serializeValue(val[i]))
            end
            return "[" .. table.concat(parts, ",") .. "]"
        else
            for k, v in pairs(val) do
                table.insert(parts, serializeValue(tostring(k)) .. ":" .. serializeValue(v))
            end
            return "{" .. table.concat(parts, ",") .. "}"
        end
    end
    return "null"
end

local function deserializeValue(str, pos)
    pos = pos or 1
    while pos <= #str and str:sub(pos, pos):match("%s") do
        pos = pos + 1
    end
    
    if pos > #str then return nil, pos end
    
    local char = str:sub(pos, pos)
    
    -- String
    if char == '"' then
        local endPos = pos + 1
        local result = ""
        while endPos <= #str do
            local c = str:sub(endPos, endPos)
            if c == "\\" and endPos < #str then
                local next = str:sub(endPos + 1, endPos + 1)
                if next == "\\" or next == '"' then
                    result = result .. next
                    endPos = endPos + 2
                elseif next == "n" then
                    result = result .. "\n"
                    endPos = endPos + 2
                else
                    endPos = endPos + 1
                end
            elseif c == '"' then
                return result, endPos + 1
            else
                result = result .. c
                endPos = endPos + 1
            end
        end
        return nil, pos
    end
    
    -- Number
    if char:match("[%-0-9]") then
        local numStr = str:match("^%-?[0-9]+%.?[0-9]*", pos)
        if numStr then
            return tonumber(numStr), pos + #numStr
        end
    end
    
    -- Boolean/null
    if str:sub(pos, pos + 3) == "true" then
        return true, pos + 4
    elseif str:sub(pos, pos + 4) == "false" then
        return false, pos + 5
    elseif str:sub(pos, pos + 3) == "null" then
        return nil, pos + 4
    end
    
    -- Array
    if char == "[" then
        local arr = {}
        pos = pos + 1
        while pos <= #str do
            while pos <= #str and str:sub(pos, pos):match("%s") do
                pos = pos + 1
            end
            if str:sub(pos, pos) == "]" then
                return arr, pos + 1
            end
            local val
            val, pos = deserializeValue(str, pos)
            table.insert(arr, val)
            while pos <= #str and str:sub(pos, pos):match("[%s,]") do
                pos = pos + 1
            end
        end
        return arr, pos
    end
    
    -- Object
    if char == "{" then
        local obj = {}
        pos = pos + 1
        while pos <= #str do
            while pos <= #str and str:sub(pos, pos):match("%s") do
                pos = pos + 1
            end
            if str:sub(pos, pos) == "}" then
                return obj, pos + 1
            end
            local key
            key, pos = deserializeValue(str, pos)
            while pos <= #str and str:sub(pos, pos):match("[%s:]") do
                pos = pos + 1
            end
            local val
            val, pos = deserializeValue(str, pos)
            if key then
                -- Convert numeric string keys back to numbers
                local numKey = tonumber(key)
                if numKey then
                    obj[numKey] = val
                else
                    obj[key] = val
                end
            end
            while pos <= #str and str:sub(pos, pos):match("[%s,]") do
                pos = pos + 1
            end
        end
        return obj, pos
    end
    
    return nil, pos + 1
end

function UnitFrames:SerializeSettings()
    -- Build export data
    -- Note: visibility settings are included in each unit's settings automatically
    local exportData = {
        version = 1,
        player = settings.player and CopyTable(settings.player) or nil,
        target = settings.target and CopyTable(settings.target) or nil,
        focus = settings.focus and CopyTable(settings.focus) or nil,
        targettarget = settings.targettarget and CopyTable(settings.targettarget) or nil,
        pet = settings.pet and CopyTable(settings.pet) or nil,
        party = settings.party and CopyTable(settings.party) or nil,
        raid = settings.raid and CopyTable(settings.raid) or nil,
        tanks = settings.tanks and CopyTable(settings.tanks) or nil,
        boss = settings.boss and CopyTable(settings.boss) or nil,
    }
    
    local json = serializeValue(exportData)
    
    -- Try to use LibDeflate if available
    local LibDeflate = LibStub and LibStub("LibDeflate", true)
    if LibDeflate then
        local compressed = LibDeflate:CompressDeflate(json)
        local encoded = LibDeflate:EncodeForPrint(compressed)
        return "TUI_UF1:" .. encoded
    else
        -- Fallback: just base64-ish encode
        return "TUI_UF1:" .. json
    end
end

function UnitFrames:DeserializeSettings(encoded)
    if not encoded or not encoded:match("^TUI_UF1:") then
        return nil, "Invalid format: String must start with TUI_UF1:"
    end
    
    local data = encoded:sub(9) -- Remove "TUI_UF1:" prefix
    
    -- Try to use LibDeflate if available
    local LibDeflate = LibStub and LibStub("LibDeflate", true)
    local json
    if LibDeflate then
        local decoded = LibDeflate:DecodeForPrint(data)
        if decoded then
            json = LibDeflate:DecompressDeflate(decoded)
        end
    end
    
    -- Fallback if not compressed or LibDeflate unavailable
    if not json then
        json = data
    end
    
    if not json or json == "" then
        return nil, "Failed to decode profile string"
    end
    
    local result, _ = deserializeValue(json, 1)
    if not result then
        return nil, "Failed to parse profile data"
    end
    
    if not result.version then
        return nil, "Invalid profile: missing version"
    end
    
    return result, nil
end

-- ============================================================================
-- DISPEL COLOR LEGEND POPUP
-- ============================================================================

function UnitFrames:ShowDispelColorLegend(parentPanel)
    -- Create popup if it doesn't exist
    if not self.dispelLegendPopup then
        local popup = CreateFrame("Frame", "TweaksUI_DispelLegendPopup", UIParent, "BackdropTemplate")
        popup:SetSize(220, 220)
        popup:SetFrameStrata("DIALOG")
        popup:SetBackdrop({
            bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background-Dark",
            edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
            tile = true, tileSize = 32, edgeSize = 32,
            insets = { left = 8, right = 8, top = 8, bottom = 8 }
        })
        popup:SetBackdropColor(0.08, 0.08, 0.08, 0.95)
        popup:SetBackdropBorderColor(0.4, 0.4, 0.4, 1)
        popup:SetMovable(true)
        popup:EnableMouse(true)
        popup:RegisterForDrag("LeftButton")
        popup:SetScript("OnDragStart", popup.StartMoving)
        popup:SetScript("OnDragStop", popup.StopMovingOrSizing)
        popup:SetClampedToScreen(true)
        
        -- Title
        local title = popup:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
        title:SetPoint("TOP", 0, -15)
        title:SetText("|cffffd100Dispel Type Colors|r")
        
        -- Close button
        local closeBtn = CreateFrame("Button", nil, popup, "UIPanelCloseButton")
        closeBtn:SetPoint("TOPRIGHT", -5, -5)
        closeBtn:SetScript("OnClick", function() popup:Hide() end)
        
        -- Color entries
        local dispelTypes = {
            { name = "Magic", color = {0.3, 0.7, 1.0}, desc = "Dispelled by: Priest, Paladin, Shaman, Druid, Monk, Evoker, Warlock" },
            { name = "Curse", color = {0.7, 0.2, 1.0}, desc = "Dispelled by: Shaman, Druid, Mage" },
            { name = "Disease", color = {0.8, 0.5, 0.1}, desc = "Dispelled by: Priest, Paladin, Monk" },
            { name = "Poison", color = {0.2, 0.8, 0.2}, desc = "Dispelled by: Paladin, Druid, Monk, Evoker" },
            { name = "Bleed", color = {1.0, 0.2, 0.2}, desc = "Cannot be dispelled (physical)" },
        }
        
        local yOffset = -45
        for _, dispelInfo in ipairs(dispelTypes) do
            -- Color box
            local box = CreateFrame("Frame", nil, popup, "BackdropTemplate")
            box:SetSize(20, 20)
            box:SetPoint("TOPLEFT", 15, yOffset)
            box:SetBackdrop({
                bgFile = "Interface\\BUTTONS\\WHITE8X8",
                edgeFile = "Interface\\BUTTONS\\WHITE8X8",
                edgeSize = 1,
            })
            box:SetBackdropColor(dispelInfo.color[1], dispelInfo.color[2], dispelInfo.color[3], 1)
            box:SetBackdropBorderColor(0, 0, 0, 1)
            
            -- Name
            local nameText = popup:CreateFontString(nil, "OVERLAY", "GameFontNormal")
            nameText:SetPoint("LEFT", box, "RIGHT", 8, 0)
            nameText:SetText(dispelInfo.name)
            nameText:SetTextColor(1, 1, 1)
            
            -- Tooltip for classes
            box:EnableMouse(true)
            box:SetScript("OnEnter", function(self)
                GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
                GameTooltip:SetText(dispelInfo.name, dispelInfo.color[1], dispelInfo.color[2], dispelInfo.color[3])
                GameTooltip:AddLine(dispelInfo.desc, 1, 1, 1, true)
                GameTooltip:Show()
            end)
            box:SetScript("OnLeave", function() GameTooltip:Hide() end)
            
            yOffset = yOffset - 28
        end
        
        -- Note at bottom
        local note = popup:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        note:SetPoint("BOTTOM", 0, 15)
        note:SetWidth(190)
        note:SetText("|cff888888Hover over a color for dispel info|r")
        note:SetJustifyH("CENTER")
        
        self.dispelLegendPopup = popup
        tinsert(UISpecialFrames, "TweaksUI_DispelLegendPopup")
    end
    
    -- Position relative to parent panel if provided
    self.dispelLegendPopup:ClearAllPoints()
    if parentPanel and parentPanel:IsShown() then
        self.dispelLegendPopup:SetPoint("TOPLEFT", parentPanel, "TOPRIGHT", 0, 0)
    else
        self.dispelLegendPopup:SetPoint("CENTER")
    end
    
    self.dispelLegendPopup:Show()
end

function UnitFrames:ImportSettings(importData)
    if not importData then return false, "No data to import" end
    
    -- Import each unit type if present
    -- Note: visibility settings are included in each unit's settings automatically
    local units = {"player", "target", "focus", "targettarget", "pet", "party", "raid", "tanks", "boss"}
    local imported = {}
    
    for _, unit in ipairs(units) do
        if importData[unit] then
            if unit == "raid" then
                settings.raid = CopyTable(importData.raid)
            elseif unit == "tanks" then
                settings.tanks = CopyTable(importData.tanks)
            elseif unit == "boss" then
                settings.boss = CopyTable(importData.boss)
            else
                settings[unit] = CopyTable(importData[unit])
            end
            table.insert(imported, unit)
        end
    end
    
    -- Refresh all frames
    for _, unit in ipairs(imported) do
        if unit == "raid" then
            self:RefreshFrame("raid_small")
            self:RefreshFrame("raid_large")
        elseif unit == "tanks" then
            self:RefreshFrame("tanks")
        elseif unit == "boss" then
            self:RefreshFrame("boss")
        else
            self:RefreshFrame(unit)
        end
    end
    
    -- Apply all visibility settings (they're now per-frame in each unit's settings)
    VisibilityManager:ApplyAllVisibility(true)
    VisibilityManager:UpdateAllMouseover()
    
    return true, "Imported: " .. table.concat(imported, ", ")
end

-- Export window (stored in module to avoid local variable limit)
function UnitFrames:ShowExportWindow()
    if self.exportFrame then
        self.exportFrame:Show()
        -- Update the export string
        local editBox = self.exportFrame.editBox
        editBox:SetText(self:SerializeSettings())
        return
    end
    
    local frame = CreateFrame("Frame", "TweaksUI_UF_ExportFrame", UIParent, "BasicFrameTemplateWithInset")
    frame:SetSize(500, 350)
    frame:SetPoint("CENTER")
    frame:SetMovable(true)
    frame:EnableMouse(true)
    frame:RegisterForDrag("LeftButton")
    frame:SetScript("OnDragStart", frame.StartMoving)
    frame:SetScript("OnDragStop", frame.StopMovingOrSizing)
    frame:SetFrameStrata("DIALOG")
    
    frame.title = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
    frame.title:SetPoint("TOP", 0, -5)
    frame.title:SetText("Export Unit Frames Settings")
    
    local info = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    info:SetPoint("TOPLEFT", 15, -35)
    info:SetText("Copy this string to share your settings:")
    
    local scrollFrame = CreateFrame("ScrollFrame", nil, frame, "UIPanelScrollFrameTemplate")
    scrollFrame:SetPoint("TOPLEFT", 10, -55)
    scrollFrame:SetPoint("BOTTOMRIGHT", -30, 45)
    
    local editBox = CreateFrame("EditBox", nil, scrollFrame)
    editBox:SetMultiLine(true)
    editBox:SetFontObject("ChatFontNormal")
    editBox:SetWidth(scrollFrame:GetWidth())
    editBox:SetText(self:SerializeSettings())
    editBox:SetAutoFocus(false)
    editBox:SetScript("OnEscapePressed", function() frame:Hide() end)
    scrollFrame:SetScrollChild(editBox)
    frame.editBox = editBox
    
    local selectBtn = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
    selectBtn:SetSize(100, 22)
    selectBtn:SetPoint("BOTTOMLEFT", 10, 10)
    selectBtn:SetText("Select All")
    selectBtn:SetScript("OnClick", function()
        editBox:SetFocus()
        editBox:HighlightText()
    end)
    
    local closeBtn = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
    closeBtn:SetSize(80, 22)
    closeBtn:SetPoint("BOTTOMRIGHT", -10, 10)
    closeBtn:SetText("Close")
    closeBtn:SetScript("OnClick", function() frame:Hide() end)
    
    self.exportFrame = frame
    frame:Show()
end

-- Import window (stored in module to avoid local variable limit)
function UnitFrames:ShowImportWindow()
    if self.importFrame then
        self.importFrame:Show()
        self.importFrame.editBox:SetText("")
        self.importFrame.statusText:SetText("")
        return
    end
    
    local frame = CreateFrame("Frame", "TweaksUI_UF_ImportFrame", UIParent, "BasicFrameTemplateWithInset")
    frame:SetSize(500, 380)
    frame:SetPoint("CENTER")
    frame:SetMovable(true)
    frame:EnableMouse(true)
    frame:RegisterForDrag("LeftButton")
    frame:SetScript("OnDragStart", frame.StartMoving)
    frame:SetScript("OnDragStop", frame.StopMovingOrSizing)
    frame:SetFrameStrata("DIALOG")
    
    frame.title = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
    frame.title:SetPoint("TOP", 0, -5)
    frame.title:SetText("Import Unit Frames Settings")
    
    local info = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    info:SetPoint("TOPLEFT", 15, -35)
    info:SetWidth(470)
    info:SetJustifyH("LEFT")
    info:SetText("Paste a settings string below:")
    
    local scrollFrame = CreateFrame("ScrollFrame", nil, frame, "UIPanelScrollFrameTemplate")
    scrollFrame:SetPoint("TOPLEFT", 10, -55)
    scrollFrame:SetPoint("BOTTOMRIGHT", -30, 70)
    
    local editBox = CreateFrame("EditBox", nil, scrollFrame)
    editBox:SetMultiLine(true)
    editBox:SetFontObject("ChatFontNormal")
    editBox:SetWidth(scrollFrame:GetWidth())
    editBox:SetAutoFocus(true)
    editBox:SetScript("OnEscapePressed", function() frame:Hide() end)
    scrollFrame:SetScrollChild(editBox)
    frame.editBox = editBox
    
    local statusText = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    statusText:SetPoint("BOTTOMLEFT", 15, 45)
    statusText:SetPoint("BOTTOMRIGHT", -15, 45)
    statusText:SetJustifyH("LEFT")
    statusText:SetTextColor(1, 0.82, 0)
    frame.statusText = statusText
    
    local module = self
    local importBtn = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
    importBtn:SetSize(100, 22)
    importBtn:SetPoint("BOTTOMLEFT", 10, 10)
    importBtn:SetText("Import")
    importBtn:SetScript("OnClick", function()
        local importString = editBox:GetText()
        
        if not importString or importString == "" then
            statusText:SetTextColor(1, 0, 0)
            statusText:SetText("Error: Please paste a settings string")
            return
        end
        
        local data, err = module:DeserializeSettings(importString)
        if not data then
            statusText:SetTextColor(1, 0, 0)
            statusText:SetText("Error: " .. (err or "Invalid data"))
            return
        end
        
        local success, msg = module:ImportSettings(data)
        if success then
            statusText:SetTextColor(0, 1, 0)
            statusText:SetText("Success! " .. msg)
            C_Timer.After(1.5, function()
                frame:Hide()
            end)
        else
            statusText:SetTextColor(1, 0, 0)
            statusText:SetText("Error: " .. msg)
        end
    end)
    
    local closeBtn = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
    closeBtn:SetSize(80, 22)
    closeBtn:SetPoint("BOTTOMRIGHT", -10, 10)
    closeBtn:SetText("Cancel")
    closeBtn:SetScript("OnClick", function() frame:Hide() end)
    
    self.importFrame = frame
    frame:Show()
end

-- ============================================================================
-- SETTINGS UI: HUB
-- ============================================================================

function UnitFrames:CreateUnitFramesHub()
    if unitFramesHub then return unitFramesHub end
    
    local hub = CreateFrame("Frame", "TweaksUI_UnitFramesHub", UIParent, "BackdropTemplate")
    hub:SetSize(HUB_WIDTH, 350)  -- Increased height for preset dropdown
    hub:SetBackdrop(darkBackdrop)
    hub:SetBackdropColor(0.08, 0.08, 0.08, 0.95)
    hub:SetBackdropBorderColor(0.4, 0.4, 0.4, 1)
    hub:SetMovable(true)
    hub:EnableMouse(true)
    hub:SetClampedToScreen(true)
    hub:SetFrameStrata("DIALOG")
    
    local title = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
    title:SetPoint("TOP", 0, -12)
    title:SetText("Unit Frames")
    title:SetTextColor(1, 0.82, 0)
    
    local closeBtn = CreateFrame("Button", nil, hub, "UIPanelCloseButton")
    closeBtn:SetPoint("TOPRIGHT", -3, -3)
    closeBtn:SetScript("OnClick", function()
        self:HideAllPanels()
        hub:Hide()
    end)
    
    hub:RegisterForDrag("LeftButton")
    hub:SetScript("OnDragStart", hub.StartMoving)
    hub:SetScript("OnDragStop", hub.StopMovingOrSizing)
    
    -- Close all panels when hub is hidden
    hub:SetScript("OnHide", function()
        self:HideAllPanels()
    end)
    
    -- Update test mode button when hub is shown (may have changed externally)
    hub:SetScript("OnShow", function()
        if hub.UpdateTestModeButton then
            hub.UpdateTestModeButton()
        end
    end)
    
    local yOffset = -54
    
    -- Add Preset Dropdown
    if TweaksUI.PresetDropdown then
        local presetContainer, nextY = TweaksUI.PresetDropdown:Create(
            hub,
            "unitFrames",
            "Unit Frames",
            yOffset,
            {
                width = 140,
                showSaveButton = true,
                showDeleteButton = true,
            }
        )
        yOffset = nextY - 8
    end
    
    local buttonWidth = HUB_WIDTH - 20
    
    -- ===== INDIVIDUAL FRAMES SECTION =====
    local indivLabel = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    indivLabel:SetPoint("TOP", 0, yOffset)
    indivLabel:SetText("|cff888888Individual Frames|r")
    yOffset = yOffset - 16
    
    -- Player Frame button
    local playerBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    playerBtn:SetPoint("TOP", 0, yOffset)
    playerBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    playerBtn:SetText("Player Frame")
    playerBtn:SetScript("OnClick", function() self:TogglePanel("player") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Target Frame button
    local targetBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    targetBtn:SetPoint("TOP", 0, yOffset)
    targetBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    targetBtn:SetText("Target Frame")
    targetBtn:SetScript("OnClick", function() self:TogglePanel("target") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Focus Frame button
    local focusBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    focusBtn:SetPoint("TOP", 0, yOffset)
    focusBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    focusBtn:SetText("Focus Frame")
    focusBtn:SetScript("OnClick", function() self:TogglePanel("focus") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Target of Target button
    local totBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    totBtn:SetPoint("TOP", 0, yOffset)
    totBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    totBtn:SetText("Target of Target")
    totBtn:SetScript("OnClick", function() self:TogglePanel("targettarget") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Pet Frame button
    local petBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    petBtn:SetPoint("TOP", 0, yOffset)
    petBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    petBtn:SetText("Pet Frame")
    petBtn:SetScript("OnClick", function() self:TogglePanel("pet") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING * 2
    
    -- ===== PARTY FRAMES SECTION =====
    local sep1 = hub:CreateTexture(nil, "ARTWORK")
    sep1:SetPoint("TOP", 0, yOffset)
    sep1:SetSize(buttonWidth, 1)
    sep1:SetColorTexture(0.4, 0.4, 0.4, 0.6)
    yOffset = yOffset - 8
    
    local partyLabel = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    partyLabel:SetPoint("TOP", 0, yOffset)
    partyLabel:SetText("|cff888888Group Frames|r")
    yOffset = yOffset - 16
    
    -- Check if external addons are handling party and/or raid frames (separately)
    local partyAddon = self:GetExternalPartyAddon()
    local raidAddon = self:GetExternalRaidAddon()
    local partyDisabled = self:IsPartyDisabledByExternalAddon()
    local raidDisabled = self:IsRaidDisabledByExternalAddon()
    
    -- Show warning if any external addon detected
    if partyDisabled or raidDisabled then
        -- Determine what text to show
        local warningText, disabledText
        if partyDisabled and raidDisabled then
            -- Same addon handles both, or different addons
            if partyAddon == raidAddon then
                warningText = "|cffFFD100" .. partyAddon .. " detected|r"
                disabledText = "|cff888888(Party/Raid disabled)|r"
            else
                warningText = "|cffFFD100Multiple addons detected|r"
                disabledText = "|cff888888(Party: " .. (partyAddon or "?") .. ", Raid: " .. (raidAddon or "?") .. ")|r"
            end
        elseif partyDisabled then
            warningText = "|cffFFD100" .. partyAddon .. " detected|r"
            disabledText = "|cff888888(Party frames disabled)|r"
        else -- raidDisabled
            warningText = "|cffFFD100" .. raidAddon .. " detected|r"
            disabledText = "|cff888888(Raid frames disabled)|r"
        end
        
        local warningLabel = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        warningLabel:SetPoint("TOP", 0, yOffset)
        warningLabel:SetText(warningText)
        yOffset = yOffset - 14
        
        local disabledNote = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        disabledNote:SetPoint("TOP", 0, yOffset)
        disabledNote:SetText(disabledText)
        yOffset = yOffset - 16
    end
    
    -- Party Frames button
    local partyBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    partyBtn:SetPoint("TOP", 0, yOffset)
    partyBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    if partyDisabled then
        partyBtn:SetText("|cff666666Party Frames|r")
        partyBtn:SetScript("OnClick", function() 
            TweaksUI:Print("Party frames disabled - " .. (partyAddon or "external addon") .. " is handling party frames.")
        end)
        partyBtn:SetScript("OnEnter", function(self)
            GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
            GameTooltip:AddLine("Party Frames Disabled", 1, 0.82, 0)
            GameTooltip:AddLine(partyAddon .. " is handling party frames.", 1, 1, 1, true)
            GameTooltip:AddLine("Disable " .. partyAddon .. " to use TweaksUI party frames.", 0.7, 0.7, 0.7, true)
            GameTooltip:Show()
        end)
        partyBtn:SetScript("OnLeave", function() GameTooltip:Hide() end)
    else
        partyBtn:SetText("Party Frames")
        partyBtn:SetScript("OnClick", function() self:TogglePanel("party") end)
    end
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Small Raid Frames button
    local raidSmallBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    raidSmallBtn:SetPoint("TOP", 0, yOffset)
    raidSmallBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    if raidDisabled then
        raidSmallBtn:SetText("|cff666666Raid (10-20)|r")
        raidSmallBtn:SetScript("OnClick", function() 
            TweaksUI:Print("Raid frames disabled - " .. (raidAddon or "external addon") .. " is handling raid frames.")
        end)
        raidSmallBtn:SetScript("OnEnter", function(self)
            GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
            GameTooltip:AddLine("Raid Frames Disabled", 1, 0.82, 0)
            GameTooltip:AddLine(raidAddon .. " is handling raid frames.", 1, 1, 1, true)
            GameTooltip:AddLine("Disable " .. raidAddon .. " to use TweaksUI raid frames.", 0.7, 0.7, 0.7, true)
            GameTooltip:Show()
        end)
        raidSmallBtn:SetScript("OnLeave", function() GameTooltip:Hide() end)
    else
        raidSmallBtn:SetText("Raid (10-20)")
        raidSmallBtn:SetScript("OnClick", function() self:TogglePanel("raid_small") end)
    end
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Large Raid Frames button
    local raidLargeBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    raidLargeBtn:SetPoint("TOP", 0, yOffset)
    raidLargeBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    if raidDisabled then
        raidLargeBtn:SetText("|cff666666Raid (21-40)|r")
        raidLargeBtn:SetScript("OnClick", function() 
            TweaksUI:Print("Raid frames disabled - " .. (raidAddon or "external addon") .. " is handling raid frames.")
        end)
        raidLargeBtn:SetScript("OnEnter", function(self)
            GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
            GameTooltip:AddLine("Raid Frames Disabled", 1, 0.82, 0)
            GameTooltip:AddLine(raidAddon .. " is handling raid frames.", 1, 1, 1, true)
            GameTooltip:AddLine("Disable " .. raidAddon .. " to use TweaksUI raid frames.", 0.7, 0.7, 0.7, true)
            GameTooltip:Show()
        end)
        raidLargeBtn:SetScript("OnLeave", function() GameTooltip:Hide() end)
    else
        raidLargeBtn:SetText("Raid (21-40)")
        raidLargeBtn:SetScript("OnClick", function() self:TogglePanel("raid_large") end)
    end
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Tank Frames button
    local tankBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    tankBtn:SetPoint("TOP", 0, yOffset)
    tankBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    tankBtn:SetText("Tank Frames")
    tankBtn:SetScript("OnClick", function() self:TogglePanel("tanks") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING
    
    -- Boss Frames button
    local bossBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    bossBtn:SetPoint("TOP", 0, yOffset)
    bossBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    bossBtn:SetText("Boss Frames")
    bossBtn:SetScript("OnClick", function() self:TogglePanel("boss") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING * 2
    
    -- ===== GENERAL SETTINGS SECTION =====
    local sep2a = hub:CreateTexture(nil, "ARTWORK")
    sep2a:SetPoint("TOP", 0, yOffset)
    sep2a:SetSize(buttonWidth, 1)
    sep2a:SetColorTexture(0.4, 0.4, 0.4, 0.6)
    yOffset = yOffset - 8
    
    local generalLabel = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    generalLabel:SetPoint("TOP", 0, yOffset)
    generalLabel:SetText("|cff888888Module Settings|r")
    yOffset = yOffset - 16
    
    -- General Settings button
    local generalBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    generalBtn:SetPoint("TOP", 0, yOffset)
    generalBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    generalBtn:SetText("General Settings")
    generalBtn:SetScript("OnClick", function() self:TogglePanel("general") end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING * 2
    
    -- ===== TEST MODE SECTION =====
    local sep2 = hub:CreateTexture(nil, "ARTWORK")
    sep2:SetPoint("TOP", 0, yOffset)
    sep2:SetSize(buttonWidth, 1)
    sep2:SetColorTexture(0.4, 0.4, 0.4, 0.6)
    yOffset = yOffset - 8
    
    local testLabel = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    testLabel:SetPoint("TOP", 0, yOffset)
    testLabel:SetText("|cff888888Preview / Testing|r")
    yOffset = yOffset - 16
    
    -- Test Mode toggle button
    local testModeBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    testModeBtn:SetPoint("TOP", 0, yOffset)
    testModeBtn:SetSize(buttonWidth, BUTTON_HEIGHT)
    testModeBtn:SetText("|cff00ff00Test Mode: OFF|r")
    hub.testModeBtn = testModeBtn
    
    local function UpdateTestModeButton()
        local TestMode = TweaksUI.UnitFramesTestMode
        if TestMode and TestMode:IsGlobalTestMode() then
            testModeBtn:SetText("|cffff0000Test Mode: ON|r")
        else
            testModeBtn:SetText("|cff00ff00Test Mode: OFF|r")
        end
    end
    
    -- Store update function for external access
    hub.UpdateTestModeButton = UpdateTestModeButton
    
    testModeBtn:SetScript("OnClick", function()
        local TestMode = TweaksUI.UnitFramesTestMode
        if TestMode then
            TestMode:ToggleGlobalTestMode()
            UpdateTestModeButton()
        end
    end)
    testModeBtn:SetScript("OnEnter", function(self)
        GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
        GameTooltip:AddLine("Test Mode", 1, 0.82, 0)
        GameTooltip:AddLine("Shows all enabled frames with simulated", 1, 1, 1, true)
        GameTooltip:AddLine("data including auras, so you can preview", 1, 1, 1, true)
        GameTooltip:AddLine("and adjust settings without a real group.", 1, 1, 1, true)
        GameTooltip:AddLine(" ")
        GameTooltip:AddLine("Tip: Also available via /tuitest", 0.7, 0.7, 0.7)
        GameTooltip:Show()
    end)
    testModeBtn:SetScript("OnLeave", function() GameTooltip:Hide() end)
    yOffset = yOffset - BUTTON_HEIGHT - BUTTON_SPACING * 2
    
    -- ===== IMPORT/EXPORT SECTION =====
    local sep3 = hub:CreateTexture(nil, "ARTWORK")
    sep3:SetPoint("TOP", 0, yOffset)
    sep3:SetSize(buttonWidth, 1)
    sep3:SetColorTexture(0.4, 0.4, 0.4, 0.6)
    yOffset = yOffset - 12
    
    local ieLabel = hub:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    ieLabel:SetPoint("TOP", 0, yOffset)
    ieLabel:SetText("Import / Export")
    yOffset = yOffset - 18
    
    local exportBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    exportBtn:SetSize(buttonWidth / 2 - 4, 24)
    exportBtn:SetPoint("TOPLEFT", hub, "TOPLEFT", 10, yOffset)
    exportBtn:SetText("Export")
    exportBtn:SetScript("OnClick", function() self:ShowExportWindow() end)
    
    local importBtn = CreateFrame("Button", nil, hub, "UIPanelButtonTemplate")
    importBtn:SetSize(buttonWidth / 2 - 4, 24)
    importBtn:SetPoint("TOPRIGHT", hub, "TOPRIGHT", -10, yOffset)
    importBtn:SetText("Import")
    importBtn:SetScript("OnClick", function() self:ShowImportWindow() end)
    
    yOffset = yOffset - 30
    
    -- Update hub height based on content
    hub:SetSize(HUB_WIDTH, -yOffset + 20)
    
    hub:Hide()
    unitFramesHub = hub
    return hub
end

function UnitFrames:OpenUnitFramesHubDocked(parentPanel)
    self:CreateUnitFramesHub()
    
    if parentPanel and unitFramesHub then
        unitFramesHub:ClearAllPoints()
        unitFramesHub:SetPoint("TOPLEFT", parentPanel, "TOPRIGHT", 0, 0)
    end
    
    unitFramesHub:Show()
end

function UnitFrames:HideAllPanels()
    if unitFramesHub then
        unitFramesHub:Hide()
    end
    for _, panel in pairs(settingsPanels) do
        if panel and panel.Hide then
            panel:Hide()
        end
    end
    
    -- Disable global test mode if active
    local TestMode = TweaksUI.UnitFramesTestMode
    if TestMode and TestMode:IsGlobalTestMode() then
        TestMode:DisableGlobalTestMode()
    end
    
    -- Reset all preview states
    previewPlayer = false
    previewTarget = false
    previewFocus = false
    previewToT = false
    previewPet = false
    previewParty = false
    simulateRaidSmall = false
    simulateRaidLarge = false
    
    -- Clear preview state and restore normal visibility
    if currentOpenPanel then
        local prevPanel = currentOpenPanel
        currentOpenPanel = nil
        self:HidePanelPreview(prevPanel)
    end
    
    -- Restore state drivers for individual frames (except player)
    if not InCombatLockdown() then
        local stateConditions = {
            target = "[@target,exists] show; hide",
            focus = "[@focus,exists] show; hide",
            targettarget = "[@targettarget,exists] show; hide",
            pet = "[@pet,exists] show; hide",
        }
        for unit, stateCondition in pairs(stateConditions) do
            local frame = customFrames[unit]
            if frame then
                RegisterStateDriver(frame, "visibility", stateCondition)
            end
        end
    end
    
    -- Update frames
    for _, unit in ipairs(INDIVIDUAL_UNITS) do
        if unit ~= "player" then
            UpdateFrameData(unit)
        end
    end
    self:UpdatePartyFrames()
    self:UpdateRaidFrames()
end

function UnitFrames:TogglePanel(panelName)
    -- Hide other panels and clear their preview state
    for name, panel in pairs(settingsPanels) do
        if panel and name ~= panelName then
            panel:Hide()
            -- Clear preview for the closed panel
            if currentOpenPanel == name then
                local prevPanel = currentOpenPanel
                currentOpenPanel = nil
                self:HidePanelPreview(prevPanel)
            end
        end
    end
    
    if settingsPanels[panelName] then
        if settingsPanels[panelName]:IsShown() then
            settingsPanels[panelName]:Hide()
            -- Clear preview state when closing
            if currentOpenPanel == panelName then
                currentOpenPanel = nil
                self:HidePanelPreview(panelName)
            end
        else
            -- Always recreate panel to ensure fresh settings are loaded
            settingsPanels[panelName]:Hide()
            settingsPanels[panelName] = nil
            if panelName == "general" then
                self:CreateGeneralSettingsPanel()
            else
                self:CreateUnitPanel(panelName)
            end
            if settingsPanels[panelName] then
                settingsPanels[panelName]:Show()
                currentOpenPanel = panelName
                if panelName ~= "general" then
                    self:ShowPanelPreview(panelName)
                end
            end
        end
    else
        -- Handle general panel separately
        if panelName == "general" then
            self:CreateGeneralSettingsPanel()
        else
            self:CreateUnitPanel(panelName)
        end
        if settingsPanels[panelName] then
            settingsPanels[panelName]:Show()
            currentOpenPanel = panelName
            -- Show the frame and preview cast bar (skip for general)
            if panelName ~= "general" then
                self:ShowPanelPreview(panelName)
            end
        end
    end
end

-- Show preview for the currently open panel
function UnitFrames:ShowPanelPreview(panelName)
    -- Individual unit frames - just update, no auto-simulation
    -- Preview is controlled by checkbox in settings panel
    local individualUnits = {player = true, target = true, focus = true, targettarget = true, pet = true}
    if individualUnits[panelName] then
        local unitSettings = settings[panelName]
        
        -- Create the frame if it doesn't exist yet
        if not customFrames[panelName] and unitSettings and unitSettings.enabled then
            CreateCustomUnitFrame(panelName)
            UpdateFrameLayout(panelName)
            MaskBlizzardFrame(panelName)
        end
        
        -- Update the frame
        local frame = customFrames[panelName]
        if frame then
            UpdateFrameLayout(panelName)
            UpdateFrameData(panelName)
        end
    end
    
    -- Party frames - no longer auto-enable simulation, use checkbox
    if panelName == "party" then
        self:UpdatePartyFrames()
    end
    
    -- Tank frames
    if panelName == "tanks" then
        -- Enable simulation for tanks
        simulateTanks = true
        
        -- Recreate container to ensure fresh frames with all elements
        if tankContainer and not InCombatLockdown() then
            self:DestroyTankContainer()
        end
        if not tankContainer then
            self:CreateTankContainer()
        end
        if tankContainer and not InCombatLockdown() then
            tankContainer:Show()
            tankContainer:SetAlpha(1)
        end
        self:UpdateTankFrames()
    end
    
    -- Boss frames
    if panelName == "boss" then
        -- Enable simulation for boss
        simulateBoss = true
        
        -- Recreate container to ensure fresh frames with all elements
        if bossContainer and not InCombatLockdown() then
            self:DestroyBossContainer()
        end
        if not bossContainer then
            self:CreateBossContainer()
        end
        if bossContainer and not InCombatLockdown() then
            bossContainer:Show()
            bossContainer:SetAlpha(1)
        end
        self:UpdateBossFrames()
    end
    
    -- Raid frames - no longer auto-enable simulation, use /tuitest instead
    if panelName == "raid_small" then
        self:UpdateRaidFrames()
    end
    
    if panelName == "raid_large" then
        self:UpdateRaidFrames()
    end
end

-- Hide preview and restore normal visibility state
function UnitFrames:HidePanelPreview(panelName)
    if not panelName then return end
    
    -- Individual unit frames - reset preview flag and update
    local individualUnits = {player = true, target = true, focus = true, targettarget = true, pet = true}
    if individualUnits[panelName] then
        -- Reset the appropriate preview flag
        if panelName == "player" then previewPlayer = false
        elseif panelName == "target" then previewTarget = false
        elseif panelName == "focus" then previewFocus = false
        elseif panelName == "targettarget" then previewToT = false
        elseif panelName == "pet" then previewPet = false
        end
        
        local frame = customFrames[panelName]
        if frame and not InCombatLockdown() then
            -- Restore normal state driver based on unit existence
            local stateCondition
            if panelName == "target" then
                stateCondition = "[@target,exists] show; hide"
            elseif panelName == "focus" then
                stateCondition = "[@focus,exists] show; hide"
            elseif panelName == "targettarget" then
                stateCondition = "[@targettarget,exists] show; hide"
            elseif panelName == "pet" then
                stateCondition = "[@pet,exists] show; hide"
            end
            if stateCondition then
                RegisterStateDriver(frame, "visibility", stateCondition)
            end
            
            -- Update with real data
            UpdateFrameData(panelName)
        end
    end
    
    -- Party frames - reset preview flag
    if panelName == "party" then
        previewParty = false
        self:UpdatePartyFrames()
    end
    
    -- Tank frames
    if panelName == "tanks" then
        -- Disable simulation for tanks
        simulateTanks = false
        
        -- Update tank frames - this will hide simulated ones
        self:UpdateTankFrames()
        
        if tankContainer and not InCombatLockdown() then
            -- Hide if no real tanks
            local hasTanks = false
            if IsInGroup() then
                for i = 1, GetNumGroupMembers() do
                    local unit = IsInRaid() and "raid"..i or "party"..i
                    if UnitExists(unit) then
                        local role = UnitGroupRolesAssigned(unit)
                        if role == "TANK" then
                            hasTanks = true
                            break
                        end
                    end
                end
            end
            if not hasTanks then
                tankContainer:Hide()
            else
                VisibilityManager:ApplyVisibilityForUnit("tanks", true)
            end
        end
    end
    
    -- Boss frames
    if panelName == "boss" then
        -- Disable simulation for boss
        simulateBoss = false
        
        -- Update boss frames - this will hide simulated ones
        self:UpdateBossFrames()
        
        if bossContainer and not InCombatLockdown() then
            -- Check if any real bosses exist
            local hasBoss = false
            for i = 1, 5 do
                if UnitExists("boss" .. i) then
                    hasBoss = true
                    break
                end
            end
            -- Don't hide container - keep it always visible
            -- Individual frames will be hidden via RegisterUnitWatch if no bosses exist
            if hasBoss then
                VisibilityManager:ApplyVisibilityForUnit("boss", true)
            end
        end
    end
    
    -- Raid frames - just update, no simulation control
    if panelName == "raid_small" then
        self:UpdateRaidFrames()
    end
    
    if panelName == "raid_large" then
        self:UpdateRaidFrames()
    end
end

-- ============================================================================
-- GLOBAL TEST MODE SUPPORT
-- Enable/disable all previews at once for comprehensive testing
-- ============================================================================

function UnitFrames:EnableAllPreviews()
    if InCombatLockdown() then
        TweaksUI:Print("Cannot enable test mode during combat")
        return
    end
    
    -- Set all preview flags
    previewPlayer = true
    previewTarget = true
    previewFocus = true
    previewToT = true
    previewPet = true
    previewParty = true
    simulateRaidSmall = true
    simulateRaidLarge = true
    simulateTanks = true
    simulateBoss = true
    
    -- Create and show individual frames if enabled in settings
    local individualUnits = {"player", "target", "focus", "targettarget", "pet"}
    for _, unit in ipairs(individualUnits) do
        if settings[unit] and settings[unit].enabled then
            if not customFrames[unit] then
                CreateCustomUnitFrame(unit)
            end
            local frame = customFrames[unit]
            if frame then
                -- Override visibility for preview
                UnregisterStateDriver(frame, "visibility")
                frame:Show()
                UpdateFrameLayout(unit)
                UpdateFrameData(unit)
            end
        end
    end
    
    -- Show party frames
    if settings.party and settings.party.enabled then
        if not partyContainer then
            self:CreatePartyContainer()
        end
        if partyContainer then
            partyContainer:Show()
        end
        self:UpdatePartyFrames()
    end
    
    -- Show raid frames (small)
    if settings.raid and settings.raid.small and settings.raid.small.enabled then
        self:UpdateRaidFrames()
    end
    
    -- Show tank frames
    if settings.tanks and settings.tanks.enabled then
        if not tankContainer then
            self:CreateTankContainer()
        end
        if tankContainer then
            tankContainer:Show()
        end
        self:UpdateTankFrames()
    end
    
    -- Show boss frames
    if settings.boss and settings.boss.enabled then
        if not bossContainer then
            self:CreateBossContainer()
        end
        if bossContainer then
            bossContainer:Show()
        end
        self:UpdateBossFrames()
    end
end

function UnitFrames:DisableAllPreviews()
    if InCombatLockdown() then
        TweaksUI:Print("Cannot disable test mode during combat")
        return
    end
    
    -- Reset all preview flags
    previewPlayer = false
    previewTarget = false
    previewFocus = false
    previewToT = false
    previewPet = false
    previewParty = false
    simulateRaidSmall = false
    simulateRaidLarge = false
    simulateTanks = false
    simulateBoss = false
    
    -- Restore individual frame visibility drivers
    local stateConditions = {
        target = "[@target,exists] show; hide",
        focus = "[@focus,exists] show; hide",
        targettarget = "[@targettarget,exists] show; hide",
        pet = "[@pet,exists] show; hide",
    }
    
    for unit, condition in pairs(stateConditions) do
        local frame = customFrames[unit]
        if frame then
            RegisterStateDriver(frame, "visibility", condition)
            UpdateFrameData(unit)
        end
    end
    
    -- Update party frames
    self:UpdatePartyFrames()
    
    -- Update raid frames
    self:UpdateRaidFrames()
    
    -- Update tank frames
    self:UpdateTankFrames()
    if tankContainer then
        -- Check for real tanks
        local hasTanks = false
        if IsInGroup() then
            for i = 1, GetNumGroupMembers() do
                local testUnit = IsInRaid() and "raid"..i or "party"..i
                if UnitExists(testUnit) and UnitGroupRolesAssigned(testUnit) == "TANK" then
                    hasTanks = true
                    break
                end
            end
        end
        if not hasTanks then
            tankContainer:Hide()
        end
    end
    
    -- Update boss frames
    self:UpdateBossFrames()
    if bossContainer then
        local hasBoss = false
        for i = 1, 5 do
            if UnitExists("boss" .. i) then
                hasBoss = true
                break
            end
        end
        -- Boss container visibility handled by individual frame watches
    end
end

-- Check if a panel is currently open (for visibility manager)
function UnitFrames:IsPanelOpen(panelName)
    return currentOpenPanel == panelName
end


-- ============================================================================
-- SETTINGS UI: UNIT PANEL WITH SUB-HUB
-- ============================================================================

function UnitFrames:CreateUnitPanel(unit)
    local displayNames = {
        player = "Player Frame",
        target = "Target Frame",
        focus = "Focus Frame",
        targettarget = "Target of Target",
        pet = "Pet Frame",
        party = "Party Frames",
        raid_small = "Small Raid (10-20)",
        raid_large = "Large Raid (21-40)",
        tanks = "Tank Frames",
        boss = "Boss Frames",
    }
    
    local isParty = (unit == "party")
    local isRaidSmall = (unit == "raid_small")
    local isRaidLarge = (unit == "raid_large")
    local isRaid = isRaidSmall or isRaidLarge
    local isTanks = (unit == "tanks")
    local isBoss = (unit == "boss")
    local isGroupFrame = isParty or isRaid or isTanks or isBoss
    
    -- Check if external addon is handling this specific frame type
    local externalAddon, panelDisabled
    if isParty then
        externalAddon = self:GetExternalPartyAddon()
        panelDisabled = self:IsPartyDisabledByExternalAddon()
    elseif isRaid then
        externalAddon = self:GetExternalRaidAddon()
        panelDisabled = self:IsRaidDisabledByExternalAddon()
    else
        externalAddon = nil
        panelDisabled = false
    end
    
    -- Panel dimensions - single tabbed panel instead of sub-hub + sub-panel
    local PANEL_WIDTH = 620  -- Widened for more tabs
    local PANEL_HEIGHT = 620
    
    -- Main panel frame with tabs
    local container = CreateFrame("Frame", "TweaksUI_UF_" .. unit .. "_Container", UIParent, "BackdropTemplate")
    container:SetSize(PANEL_WIDTH, PANEL_HEIGHT)
    container:SetBackdrop(darkBackdrop)
    container:SetBackdropColor(0.08, 0.08, 0.08, 0.95)
    container:SetBackdropBorderColor(0.4, 0.4, 0.4, 1)
    container:EnableMouse(true)
    container:SetFrameStrata("DIALOG")
    
    if unitFramesHub then
        container:SetPoint("TOPLEFT", unitFramesHub, "TOPRIGHT", 0, 0)
    end
    
    -- Title
    local panelTitle = container:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
    panelTitle:SetPoint("TOP", 0, -10)
    panelTitle:SetText(displayNames[unit] or unit)
    panelTitle:SetTextColor(1, 0.82, 0)
    
    local closeBtn = CreateFrame("Button", nil, container, "UIPanelCloseButton")
    closeBtn:SetPoint("TOPRIGHT", -3, -3)
    closeBtn:SetScript("OnClick", function() container:Hide() end)
    
    -- Show warning banner if external addon is handling this frame type
    local contentYOffset = -35
    if panelDisabled and externalAddon then
        local warningBanner = CreateFrame("Frame", nil, container, "BackdropTemplate")
        warningBanner:SetPoint("TOPLEFT", 10, -35)
        warningBanner:SetPoint("TOPRIGHT", -10, -35)
        warningBanner:SetHeight(50)
        warningBanner:SetBackdrop({
            bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background-Dark",
            edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
            tile = true, tileSize = 16, edgeSize = 8,
            insets = { left = 2, right = 2, top = 2, bottom = 2 }
        })
        warningBanner:SetBackdropColor(0.6, 0.3, 0, 0.9)
        warningBanner:SetBackdropBorderColor(1, 0.5, 0, 1)
        
        local warningIcon = warningBanner:CreateTexture(nil, "ARTWORK")
        warningIcon:SetPoint("LEFT", 10, 0)
        warningIcon:SetSize(24, 24)
        warningIcon:SetAtlas("services-icon-warning")
        
        local warningText = warningBanner:CreateFontString(nil, "OVERLAY", "GameFontNormal")
        warningText:SetPoint("LEFT", warningIcon, "RIGHT", 8, 0)
        warningText:SetPoint("RIGHT", -10, 0)
        warningText:SetJustifyH("LEFT")
        warningText:SetText("|cffFFD100" .. externalAddon .. "|r is handling " .. (isParty and "party" or "raid") .. " frames.\nThese settings are disabled. Unload " .. externalAddon .. " to use TweaksUI.")
        warningText:SetTextColor(1, 1, 1)
        
        contentYOffset = -90
    end
    
    -- Category definitions - party/raid get Container first, all get same core categories
    local categories = {}
    
    if isGroupFrame then
        table.insert(categories, { id = "container", name = "Layout" })
    end
    
    table.insert(categories, { id = "frame", name = "Frame" })
    table.insert(categories, { id = "health", name = "Health" })
    table.insert(categories, { id = "power", name = "Power" })
    
    -- Class Power tab only for player frame
    if unit == "player" then
        table.insert(categories, { id = "classpower", name = "Class Power" })
    end
    
    table.insert(categories, { id = "absorb", name = "Absorb" })  -- New Absorb tab
    table.insert(categories, { id = "castbar", name = "Cast" })
    table.insert(categories, { id = "portrait", name = "Portrait" })
    table.insert(categories, { id = "text", name = "Text/Icons" })
    
    -- Party/raid frames get split tabs for auras
    if isParty or isRaid then
        table.insert(categories, { id = "buffs", name = "Buffs" })
        table.insert(categories, { id = "debuffs", name = "Debuffs" })
        table.insert(categories, { id = "overlays", name = "Overlays" })
    else
        -- Individual frames use combined auras tab
        table.insert(categories, { id = "auras", name = "Auras" })
    end
    
    table.insert(categories, { id = "visibility", name = "Visibility" })
    
    local categoryPanels = {}
    local tabButtons = {}
    local activeCategory = nil
    
    -- Get unit settings - for raid_small/raid_large, get from settings.raid.small/large
    local unitSettings
    local raidSizeType = nil  -- "small" or "large" for raid frames
    
    if isRaidSmall then
        unitSettings = settings.raid and settings.raid.small
        raidSizeType = "small"
    elseif isRaidLarge then
        unitSettings = settings.raid and settings.raid.large
        raidSizeType = "large"
    elseif isTanks then
        unitSettings = settings.tanks
    elseif isBoss then
        unitSettings = settings.boss
    else
        unitSettings = settings[unit]
    end
    
    if not unitSettings then
        container:Hide()
        return
    end
    
    -- For raid frames, also need access to the parent raid settings (for enabled checkbox)
    local parentRaidSettings = (isRaid) and settings.raid or nil
    
    local module = self
    
    -- ========================================================================
    -- HELPER FUNCTIONS FOR BUILDING UI
    -- ========================================================================
    
    -- Helper to copy values in-place (preserves table reference for UI bindings)
    local function CopyValuesInPlace(dest, source)
        for k, v in pairs(source) do
            if type(v) == "table" then
                if type(dest[k]) == "table" then
                    CopyValuesInPlace(dest[k], v)
                else
                    dest[k] = CopyTable(v)
                end
            else
                dest[k] = v
            end
        end
    end
    
    local function CreateCategoryContent(categoryId)
        -- Create a content frame for this tab (not a separate panel)
        local contentFrame = CreateFrame("ScrollFrame", nil, container, "UIPanelScrollFrameTemplate")
        contentFrame:SetPoint("TOPLEFT", 10, -60)
        contentFrame:SetPoint("BOTTOMRIGHT", -28, 50)
        
        local content = CreateFrame("Frame", nil, contentFrame)
        content:SetSize(PANEL_WIDTH - 50, 900)
        contentFrame:SetScrollChild(content)
        
        contentFrame.content = content
        contentFrame.categoryId = categoryId
        contentFrame:Hide()
        
        return contentFrame
    end
    
    -- Bottom section with copy dropdown (shared across all tabs)
    local bottomSep = container:CreateTexture(nil, "ARTWORK")
    bottomSep:SetPoint("BOTTOMLEFT", 10, 42)
    bottomSep:SetPoint("BOTTOMRIGHT", -10, 42)
    bottomSep:SetHeight(1)
    bottomSep:SetColorTexture(0.4, 0.4, 0.4, 0.6)
    
    local copyLabel = container:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    copyLabel:SetPoint("BOTTOMLEFT", 12, 16)
    copyLabel:SetText("Copy from:")
    
    local copyDropdownName = "TweaksUI_UF_" .. unit .. "_CopyDD"
    local copyDropdown = CreateFrame("Frame", copyDropdownName, container, "UIDropDownMenuTemplate")
    copyDropdown:SetPoint("BOTTOMLEFT", 65, 6)
    UIDropDownMenu_SetWidth(copyDropdown, 160)
    UIDropDownMenu_SetText(copyDropdown, "Select...")
    container.copyDropdown = copyDropdown
    
    -- Category name for display
    local categoryNames = {
        container = "Layout",
        frame = "Frame",
        health = "Health",
        power = "Power",
        castbar = "Cast Bar",
        portrait = "Portrait",
        text = "Text/Icons",
        debuffs = "Debuffs",
        visibility = "Visibility",
    }
    
    -- Function to update copy dropdown for current category
    local function UpdateCopyDropdown(categoryId)
        UIDropDownMenu_Initialize(copyDropdown, function(self, level)
            -- For container/visibility, no copy options
            if categoryId == "container" or categoryId == "visibility" then return end
            
            -- Copy sources
            local sources = {}
            
            if isGroupFrame then
                -- Party/Raid can copy from presets
                for presetId, preset in pairs(PRESET_LAYOUTS) do
                    if preset.name then
                        table.insert(sources, { name = preset.name .. " Preset", data = preset, isPreset = true })
                    end
                end
            else
                -- Individual frames can copy from other units
                for _, u in ipairs(INDIVIDUAL_UNITS) do
                    if u ~= unit and settings[u] then
                        table.insert(sources, { name = displayNames[u] or u, data = settings[u], isPreset = false })
                    end
                end
            end
            
            for _, source in ipairs(sources) do
                local info = UIDropDownMenu_CreateInfo()
                info.text = source.name .. " " .. (categoryNames[categoryId] or categoryId)
                info.func = function()
                    local sourceData = source.data
                    if sourceData then
                        if categoryId == "frame" then
                            local oldX, oldY = unitSettings.frame.x, unitSettings.frame.y
                            local oldAnchor = unitSettings.frame.anchor
                            CopyValuesInPlace(unitSettings.frame, sourceData.frame)
                            unitSettings.frame.x = oldX
                            unitSettings.frame.y = oldY
                            unitSettings.frame.anchor = oldAnchor
                        elseif categoryId == "health" then
                            CopyValuesInPlace(unitSettings.healthBar, sourceData.healthBar)
                            if sourceData.healthText then
                                CopyValuesInPlace(unitSettings.healthText, sourceData.healthText)
                            end
                        elseif categoryId == "power" then
                            CopyValuesInPlace(unitSettings.powerBar, sourceData.powerBar)
                            if sourceData.powerText then
                                CopyValuesInPlace(unitSettings.powerText, sourceData.powerText)
                            end
                        elseif categoryId == "absorb" then
                            if sourceData.absorbBar and unitSettings.absorbBar then
                                CopyValuesInPlace(unitSettings.absorbBar, sourceData.absorbBar)
                            end
                        elseif categoryId == "castbar" then
                            if sourceData.castBar and unitSettings.castBar then
                                CopyValuesInPlace(unitSettings.castBar, sourceData.castBar)
                            end
                        elseif categoryId == "portrait" then
                            if sourceData.portrait then
                                CopyValuesInPlace(unitSettings.portrait, sourceData.portrait)
                            end
                        elseif categoryId == "text" then
                            CopyValuesInPlace(unitSettings.nameText, sourceData.nameText)
                            if sourceData.levelText then
                                CopyValuesInPlace(unitSettings.levelText, sourceData.levelText)
                            end
                            if sourceData.raidTarget then
                                CopyValuesInPlace(unitSettings.raidTarget, sourceData.raidTarget)
                            end
                            if sourceData.roleIcon and unitSettings.roleIcon then
                                CopyValuesInPlace(unitSettings.roleIcon, sourceData.roleIcon)
                            end
                        elseif categoryId == "auras" then
                            if sourceData.debuffIndicators and unitSettings.debuffIndicators then
                                CopyValuesInPlace(unitSettings.debuffIndicators, sourceData.debuffIndicators)
                            end
                        end
                        module:RefreshFrame(unit)
                        UIDropDownMenu_SetText(copyDropdown, "Copied!")
                        C_Timer.After(1, function()
                            UIDropDownMenu_SetText(copyDropdown, "Select...")
                        end)
                    end
                end
                UIDropDownMenu_AddButton(info)
            end
        end)
    end
    
    local function BuildCategoryUI(contentFrame, categoryId)
        local content = contentFrame.content
        local yOffset = -5
        local controlIndex = 0
        
        -- For raid_small/raid_large, unitSettings already points to the correct sub-table
        -- So visualSettings is just unitSettings for all unit types now
        local visualSettings = unitSettings
        
        -- Helper: Section header
        local function CreateHeader(text)
            yOffset = yOffset - 8
            local header = content:CreateFontString(nil, "OVERLAY", "GameFontNormal")
            header:SetPoint("TOPLEFT", 0, yOffset)
            header:SetText("|cffffd100" .. text .. "|r")
            yOffset = yOffset - 18
            return header
        end
        
        -- Helper: Note/info text (smaller, gray)
        local function CreateNote(text)
            local note = content:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
            note:SetPoint("TOPLEFT", 22, yOffset)
            note:SetText("|cff888888" .. text .. "|r")
            note:SetWidth(270)
            note:SetJustifyH("LEFT")
            yOffset = yOffset - 14
            return note
        end
        
        -- Helper: Checkbox
        local function CreateCheckbox(text, settingsTable, key, callback)
            local cb = CreateFrame("CheckButton", nil, content, "UICheckButtonTemplate")
            cb:SetPoint("TOPLEFT", 0, yOffset)
            cb:SetSize(22, 22)
            cb.text:SetText(text)
            cb.text:SetFontObject("GameFontHighlightSmall")
            cb:SetChecked(settingsTable[key])
            cb:SetScript("OnClick", function(self)
                settingsTable[key] = self:GetChecked()
                UnitFrames:SaveSettings()
                if callback then callback() end
                module:RefreshFrame(unit)
            end)
            yOffset = yOffset - 24
            return cb
        end
        
        -- Helper: Slider with numeric input
        local function CreateSlider(label, settingsTable, key, minVal, maxVal, step, isFloat)
            -- Use the centralized slider with input helper
            local container = TweaksUI.Utilities:CreateSliderWithInput(content, {
                label = label,
                min = minVal,
                max = maxVal,
                step = step,
                value = settingsTable[key] or minVal,
                isFloat = isFloat or false,
                decimals = 2,
                width = 140,
                labelWidth = 85,
                valueWidth = 45,
                onValueChanged = function(value)
                    settingsTable[key] = value
                    module:RefreshFrame(unit)
                end,
            })
            container:SetPoint("TOPLEFT", 5, yOffset)
            
            yOffset = yOffset - 22
            return container.slider
        end
        
        -- Helper: Dropdown
        local function CreateDropdown(label, options, settingsTable, key, callback)
            controlIndex = controlIndex + 1
            
            local dropContainer = CreateFrame("Frame", nil, content)
            dropContainer:SetPoint("TOPLEFT", 5, yOffset)
            dropContainer:SetSize(280, 26)
            
            local dropLabel = dropContainer:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
            dropLabel:SetPoint("LEFT", 0, 0)
            dropLabel:SetText(label)
            dropLabel:SetWidth(85)
            dropLabel:SetJustifyH("LEFT")
            
            local dropdownName = "TweaksUI_UF_" .. unit .. "_" .. categoryId .. "_DD" .. controlIndex
            local dropdown = CreateFrame("Frame", dropdownName, dropContainer, "UIDropDownMenuTemplate")
            dropdown:SetPoint("LEFT", 68, 0)
            UIDropDownMenu_SetWidth(dropdown, 130)
            
            local currentName = settingsTable[key]
            for _, opt in ipairs(options) do
                if opt.id == settingsTable[key] then
                    currentName = opt.name
                    break
                end
            end
            UIDropDownMenu_SetText(dropdown, currentName)
            
            UIDropDownMenu_Initialize(dropdown, function(self, level)
                for _, opt in ipairs(options) do
                    local info = UIDropDownMenu_CreateInfo()
                    info.text = opt.name
                    info.checked = (settingsTable[key] == opt.id)
                    info.func = function()
                        settingsTable[key] = opt.id
                        UIDropDownMenu_SetText(dropdown, opt.name)
                        if callback then callback(opt.id) end
                        module:RefreshFrame(unit)
                    end
                    UIDropDownMenu_AddButton(info)
                end
            end)
            
            yOffset = yOffset - 26
            return dropdown
        end
        
        -- Helper: Color picker
        local function CreateColorPicker(label, settingsTable, key, callback)
            local colorContainer = CreateFrame("Frame", nil, content)
            colorContainer:SetPoint("TOPLEFT", 5, yOffset)
            colorContainer:SetSize(280, 22)
            
            local colorLabel = colorContainer:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
            colorLabel:SetPoint("LEFT", 0, 0)
            colorLabel:SetText(label)
            colorLabel:SetWidth(85)
            colorLabel:SetJustifyH("LEFT")
            
            -- Ensure color exists with defaults
            if not settingsTable[key] or type(settingsTable[key]) ~= "table" then
                settingsTable[key] = {1, 1, 0.6, 1}
            end
            
            local swatch = CreateFrame("Button", nil, colorContainer)
            swatch:SetPoint("LEFT", 88, 0)
            swatch:SetSize(22, 22)
            
            local swatchColor = swatch:CreateTexture(nil, "OVERLAY")
            swatchColor:SetAllPoints()
            local c = settingsTable[key]
            swatchColor:SetColorTexture(c[1] or 1, c[2] or 1, c[3] or 0.6, c[4] or 1)
            
            local swatchBorder = swatch:CreateTexture(nil, "BORDER")
            swatchBorder:SetPoint("TOPLEFT", -1, 1)
            swatchBorder:SetPoint("BOTTOMRIGHT", 1, -1)
            swatchBorder:SetColorTexture(0.3, 0.3, 0.3, 1)
            
            swatch:SetScript("OnClick", function()
                -- Read current color from settings table (not captured variable)
                local currentColor = settingsTable[key] or {1, 1, 0.6, 1}
                local prev = { r = currentColor[1] or 1, g = currentColor[2] or 1, b = currentColor[3] or 0.6, a = currentColor[4] or 1 }
                
                ColorPickerFrame:SetupColorPickerAndShow({
                    r = prev.r, g = prev.g, b = prev.b, opacity = prev.a,
                    hasOpacity = true,
                    swatchFunc = function()
                        local r, g, b = ColorPickerFrame:GetColorRGB()
                        local a = ColorPickerFrame:GetColorAlpha()
                        settingsTable[key] = { r, g, b, a }
                        swatchColor:SetColorTexture(r, g, b, a)
                        if callback then
                            callback()
                        else
                            module:RefreshFrame(unit)
                        end
                    end,
                    cancelFunc = function()
                        settingsTable[key] = { prev.r, prev.g, prev.b, prev.a }
                        swatchColor:SetColorTexture(prev.r, prev.g, prev.b, prev.a)
                        if callback then
                            callback()
                        else
                            module:RefreshFrame(unit)
                        end
                    end,
                })
            end)
            
            yOffset = yOffset - 24
            return swatch
        end
        
        -- Helper: Font dropdown (for duration text font selection)
        local function CreateFontDropdown(label, settingsTable, key, callback)
            controlIndex = controlIndex + 1
            
            local dropdownContainer = CreateFrame("Frame", nil, content)
            dropdownContainer:SetPoint("TOPLEFT", 5, yOffset)
            dropdownContainer:SetSize(280, 26)
            
            local dropdownLabel = dropdownContainer:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
            dropdownLabel:SetPoint("LEFT", 0, 0)
            dropdownLabel:SetText(label)
            dropdownLabel:SetWidth(85)
            dropdownLabel:SetJustifyH("LEFT")
            
            local dropdownName = "TweaksUI_UF_FontDD_" .. unit .. "_" .. controlIndex
            local dropdown = CreateFrame("Frame", dropdownName, dropdownContainer, "UIDropDownMenuTemplate")
            dropdown:SetPoint("LEFT", 70, 0)
            UIDropDownMenu_SetWidth(dropdown, 140)
            
            -- Get current font name
            local currentFont = settingsTable[key] or "Friz Quadrata TT"
            UIDropDownMenu_SetText(dropdown, currentFont)
            
            UIDropDownMenu_Initialize(dropdown, function(self, level)
                local fontList = {}
                if TweaksUI.Media and TweaksUI.Media.GetFontList then
                    fontList = TweaksUI.Media:GetFontList() or {}
                end
                
                -- Add default option first
                local defaultInfo = UIDropDownMenu_CreateInfo()
                defaultInfo.text = "Friz Quadrata TT"
                defaultInfo.checked = (settingsTable[key] == "Friz Quadrata TT" or settingsTable[key] == nil)
                defaultInfo.func = function()
                    settingsTable[key] = "Friz Quadrata TT"
                    UIDropDownMenu_SetText(dropdown, "Friz Quadrata TT")
                    if callback then callback() end
                end
                UIDropDownMenu_AddButton(defaultInfo, level)
                
                -- Add all fonts from LibSharedMedia
                for _, fontName in ipairs(fontList) do
                    if fontName ~= "Friz Quadrata TT" then
                        local info = UIDropDownMenu_CreateInfo()
                        info.text = fontName
                        info.checked = (settingsTable[key] == fontName)
                        info.func = function()
                            settingsTable[key] = fontName
                            UIDropDownMenu_SetText(dropdown, fontName)
                            if callback then callback() end
                        end
                        UIDropDownMenu_AddButton(info, level)
                    end
                end
            end)
            
            yOffset = yOffset - 28
            return dropdown
        end
        
        -- ====================================================================
        -- BUILD CATEGORY-SPECIFIC UI
        -- ====================================================================
        
        if categoryId == "frame" then
            -- FRAME & BACKGROUND
            
            -- Preview checkbox for individual frames (except player, which always exists)
            if not isGroupFrame and unit ~= "player" then
                local previewCb = CreateFrame("CheckButton", nil, content, "UICheckButtonTemplate")
                previewCb:SetPoint("TOPLEFT", 10, yOffset)
                previewCb:SetSize(22, 22)
                
                -- Check the appropriate preview flag
                local isPreviewActive = false
                if unit == "target" then isPreviewActive = previewTarget
                elseif unit == "focus" then isPreviewActive = previewFocus
                elseif unit == "targettarget" then isPreviewActive = previewToT
                elseif unit == "pet" then isPreviewActive = previewPet
                end
                previewCb:SetChecked(isPreviewActive)
                
                local previewLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormal")
                previewLabel:SetPoint("LEFT", previewCb, "RIGHT", 4, 0)
                previewLabel:SetText("|cffFFFF00Show Preview Frame|r")
                
                previewCb:SetScript("OnClick", function(self)
                    local checked = self:GetChecked()
                    if unit == "target" then previewTarget = checked
                    elseif unit == "focus" then previewFocus = checked
                    elseif unit == "targettarget" then previewToT = checked
                    elseif unit == "pet" then previewPet = checked
                    end
                    
                    -- Update the frame's state driver to allow preview
                    local frame = customFrames[unit]
                    if frame and not InCombatLockdown() then
                        if checked then
                            -- Override state driver to always show during preview
                            RegisterStateDriver(frame, "visibility", "show")
                            frame:Show()
                        else
                            -- Restore normal state driver based on unit existence
                            local stateCondition
                            if unit == "target" then
                                stateCondition = "[@target,exists] show; hide"
                            elseif unit == "focus" then
                                stateCondition = "[@focus,exists] show; hide"
                            elseif unit == "targettarget" then
                                stateCondition = "[@targettarget,exists] show; hide"
                            elseif unit == "pet" then
                                stateCondition = "[@pet,exists] show; hide"
                            end
                            if stateCondition then
                                RegisterStateDriver(frame, "visibility", stateCondition)
                            end
                        end
                    end
                    
                    -- Update the frame data
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                yOffset = yOffset - 26
                
                local hintText = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                hintText:SetPoint("TOPLEFT", 10, yOffset)
                hintText:SetText("|cff888888Preview frame when unit doesn't exist|r")
                yOffset = yOffset - 16
            end
            
            CreateHeader("General")
            -- For raid frames, use parent settings for enable checkbox
            if isRaid and parentRaidSettings then
                CreateCheckbox("Enable Raid Frames", parentRaidSettings, "enabled")
            else
                CreateCheckbox("Enable " .. (displayNames[unit] or unit), unitSettings, "enabled")
            end
            
            -- Frame Style Preset dropdown
            local styleOptions = {}
            for presetId, preset in pairs(PRESET_LAYOUTS) do
                if preset.name then
                    table.insert(styleOptions, { id = presetId, name = preset.name })
                end
            end
            -- Sort alphabetically
            table.sort(styleOptions, function(a, b) return a.name < b.name end)
            
            -- Create style dropdown
            local styleLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormal")
            styleLabel:SetPoint("TOPLEFT", 20, yOffset)
            styleLabel:SetText("Apply Style:")
            yOffset = yOffset - 20
            
            local styleDropdown = CreateFrame("Frame", "TUI_UF_StyleDropdown_" .. unit, content, "UIDropDownMenuTemplate")
            styleDropdown:SetPoint("TOPLEFT", 0, yOffset)
            UIDropDownMenu_SetWidth(styleDropdown, 150)
            UIDropDownMenu_SetText(styleDropdown, "Select Style...")
            
            UIDropDownMenu_Initialize(styleDropdown, function(self, level)
                for _, opt in ipairs(styleOptions) do
                    local info = UIDropDownMenu_CreateInfo()
                    info.text = opt.name
                    info.func = function()
                        -- Apply the preset to this unit
                        local preset = PRESET_LAYOUTS[opt.id]
                        if preset and unitSettings then
                            -- Preserve position
                            local oldX = visualSettings.frame and visualSettings.frame.x
                            local oldY = visualSettings.frame and visualSettings.frame.y
                            local oldAnchor = visualSettings.frame and visualSettings.frame.anchor
                            
                            -- Apply each section from the preset
                            if preset.frame and visualSettings.frame then
                                for k, v in pairs(preset.frame) do
                                    if type(v) == "table" then
                                        visualSettings.frame[k] = visualSettings.frame[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.frame[k][k2] = v2
                                        end
                                    else
                                        visualSettings.frame[k] = v
                                    end
                                end
                                -- Restore position
                                if oldX then visualSettings.frame.x = oldX end
                                if oldY then visualSettings.frame.y = oldY end
                                if oldAnchor then visualSettings.frame.anchor = oldAnchor end
                            end
                            if preset.healthBar and visualSettings.healthBar then
                                for k, v in pairs(preset.healthBar) do
                                    if type(v) == "table" then
                                        visualSettings.healthBar[k] = visualSettings.healthBar[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.healthBar[k][k2] = v2
                                        end
                                    else
                                        visualSettings.healthBar[k] = v
                                    end
                                end
                            end
                            if preset.powerBar and visualSettings.powerBar then
                                for k, v in pairs(preset.powerBar) do
                                    if type(v) == "table" then
                                        visualSettings.powerBar[k] = visualSettings.powerBar[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.powerBar[k][k2] = v2
                                        end
                                    else
                                        visualSettings.powerBar[k] = v
                                    end
                                end
                            end
                            if preset.healthText and visualSettings.healthText then
                                for k, v in pairs(preset.healthText) do
                                    if type(v) == "table" then
                                        visualSettings.healthText[k] = visualSettings.healthText[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.healthText[k][k2] = v2
                                        end
                                    else
                                        visualSettings.healthText[k] = v
                                    end
                                end
                            end
                            if preset.powerText and visualSettings.powerText then
                                for k, v in pairs(preset.powerText) do
                                    if type(v) == "table" then
                                        visualSettings.powerText[k] = visualSettings.powerText[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.powerText[k][k2] = v2
                                        end
                                    else
                                        visualSettings.powerText[k] = v
                                    end
                                end
                            end
                            if preset.nameText and visualSettings.nameText then
                                for k, v in pairs(preset.nameText) do
                                    if type(v) == "table" then
                                        visualSettings.nameText[k] = visualSettings.nameText[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.nameText[k][k2] = v2
                                        end
                                    else
                                        visualSettings.nameText[k] = v
                                    end
                                end
                            end
                            if preset.levelText and visualSettings.levelText then
                                for k, v in pairs(preset.levelText) do
                                    if type(v) == "table" then
                                        visualSettings.levelText[k] = visualSettings.levelText[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.levelText[k][k2] = v2
                                        end
                                    else
                                        visualSettings.levelText[k] = v
                                    end
                                end
                            end
                            if preset.portrait and visualSettings.portrait then
                                for k, v in pairs(preset.portrait) do
                                    if type(v) == "table" then
                                        visualSettings.portrait[k] = visualSettings.portrait[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.portrait[k][k2] = v2
                                        end
                                    else
                                        visualSettings.portrait[k] = v
                                    end
                                end
                            end
                            if preset.raidTarget and visualSettings.raidTarget then
                                for k, v in pairs(preset.raidTarget) do
                                    if type(v) == "table" then
                                        visualSettings.raidTarget[k] = visualSettings.raidTarget[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.raidTarget[k][k2] = v2
                                        end
                                    else
                                        visualSettings.raidTarget[k] = v
                                    end
                                end
                            end
                            if preset.castBar and visualSettings.castBar then
                                for k, v in pairs(preset.castBar) do
                                    if type(v) == "table" then
                                        visualSettings.castBar[k] = visualSettings.castBar[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.castBar[k][k2] = v2
                                        end
                                    else
                                        visualSettings.castBar[k] = v
                                    end
                                end
                            end
                            if preset.debuffIndicators and visualSettings.debuffIndicators then
                                for k, v in pairs(preset.debuffIndicators) do
                                    if type(v) == "table" then
                                        visualSettings.debuffIndicators[k] = visualSettings.debuffIndicators[k] or {}
                                        for k2, v2 in pairs(v) do
                                            visualSettings.debuffIndicators[k][k2] = v2
                                        end
                                    else
                                        visualSettings.debuffIndicators[k] = v
                                    end
                                end
                            end
                            
                            -- Refresh the frame
                            module:RefreshFrame(unit)
                            
                            UIDropDownMenu_SetText(styleDropdown, opt.name .. " Applied!")
                            C_Timer.After(1.5, function()
                                UIDropDownMenu_SetText(styleDropdown, "Select Style...")
                            end)
                        end
                    end
                    UIDropDownMenu_AddButton(info)
                end
            end)
            yOffset = yOffset - 30
            
            -- Skip Scale for party/raid - container handles scaling
            if not isGroupFrame then
                CreateSlider("Scale:", visualSettings.frame, "scale", 0.5, 2.0, 0.05, true)
            end
            
            -- Skip X/Y/Anchor for party/raid - container handles positioning
            if not isGroupFrame then
                CreateSlider("X Position:", visualSettings.frame, "x", -800, 800, 1)
                CreateSlider("Y Position:", visualSettings.frame, "y", -500, 500, 1)
                CreateDropdown("Anchor:", ANCHOR_POINTS, visualSettings.frame, "anchor")
            end
            
            CreateHeader("Size")
            if visualSettings.frame.autoSize ~= nil then
                CreateCheckbox("Auto Size (fit to bars)", visualSettings.frame, "autoSize")
            end
            CreateSlider("Width:", visualSettings.frame, "width", 50, 400, 1)
            CreateSlider("Height:", visualSettings.frame, "height", 20, 100, 1)
            
            if visualSettings.frame.padding ~= nil then
                CreateHeader("Spacing")
                CreateSlider("Padding:", visualSettings.frame, "padding", 0, 10, 1)
                CreateSlider("Bar Spacing:", visualSettings.frame, "barSpacing", 0, 10, 1)
                CreateSlider("Extend Top:", visualSettings.frame, "bgExtendTop", 0, 30, 1)
                CreateSlider("Extend Bottom:", visualSettings.frame, "bgExtendBottom", 0, 30, 1)
            end
            
            CreateHeader("Background")
            CreateCheckbox("Show Background", visualSettings.frame, "showBackground")
            CreateColorPicker("BG Color:", visualSettings.frame, "bgColor")
            
            CreateHeader("Border")
            CreateCheckbox("Show Border", visualSettings.frame, "showBorder")
            CreateColorPicker("Border Color:", visualSettings.frame, "borderColor")
            CreateSlider("Border Size:", visualSettings.frame, "borderSize", 1, 5, 1)
            
        elseif categoryId == "health" then
            -- HEALTH BAR
            
            
            CreateHeader("Health Bar")
            if visualSettings.healthBar then
                if visualSettings.healthBar.enabled ~= nil then
                    CreateCheckbox("Enable Health Bar", visualSettings.healthBar, "enabled")
                end
                CreateSlider("Height:", visualSettings.healthBar, "height", 4, 60, 1)
                CreateDropdown("Color Mode:", HEALTH_COLOR_MODES, visualSettings.healthBar, "colorMode")
                CreateColorPicker("Custom Color:", visualSettings.healthBar, "customColor")
                
                if LibSharedMedia then
                    local textures = LibSharedMedia:List("statusbar")
                    local texOpts = {}
                    for _, tex in ipairs(textures) do
                        table.insert(texOpts, { id = tex, name = tex })
                    end
                    CreateDropdown("Texture:", texOpts, visualSettings.healthBar, "texture")
                    
                    -- Bar shape/masking dropdown
                    if TweaksUI.BarMasking then
                        local shapeOpts = {}
                        for _, shape in ipairs(TweaksUI.BarMasking:GetShapeList()) do
                            table.insert(shapeOpts, { id = shape, name = TweaksUI.BarMasking:GetShapeName(shape) })
                        end
                        CreateDropdown("Bar Shape:", shapeOpts, visualSettings.healthBar, "maskShape")
                    end
                end
                
                CreateHeader("Background & Border")
                CreateCheckbox("Show Background", visualSettings.healthBar, "bgEnabled")
                CreateColorPicker("Background Color:", visualSettings.healthBar, "bgColor")
                CreateCheckbox("Show Border", visualSettings.healthBar, "borderEnabled")
                CreateColorPicker("Border Color:", visualSettings.healthBar, "borderColor")
                CreateSlider("Border Size:", visualSettings.healthBar, "borderSize", 1, 4, 1)
            end
            
            if visualSettings.healthText then
                CreateHeader("Health Text")
                CreateCheckbox("Enable Health Text", visualSettings.healthText, "enabled")
                CreateDropdown("Format:", HEALTH_TEXT_FORMATS, visualSettings.healthText, "format")
                
                -- Midnight Beta warning for percentage formats
                if HAS_MIDNIGHT_APIS then
                    local warningLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    warningLabel:SetPoint("TOPLEFT", 20, yOffset)
                    warningLabel:SetWidth(PANEL_WIDTH - 80)
                    warningLabel:SetText("|cffff8800Note:|r Percentage displays may show incorrect values in Midnight Beta due to 'secret values'. Use Current or Current/Max format for accurate displays.")
                    warningLabel:SetJustifyH("LEFT")
                    yOffset = yOffset - 30
                end
                
                -- Always show abbreviate checkbox (default to true if not set)
                if visualSettings.healthText.abbreviate == nil then
                    visualSettings.healthText.abbreviate = true
                end
                CreateCheckbox("Abbreviate Numbers (85k)", visualSettings.healthText, "abbreviate")
                
                -- Always show colorByHealth checkbox (default to false if not set)
                if visualSettings.healthText.colorByHealth == nil then
                    visualSettings.healthText.colorByHealth = false
                end
                CreateCheckbox("Color by Health %", visualSettings.healthText, "colorByHealth")
                CreateSlider("Font Size:", visualSettings.healthText, "fontSize", 8, 24, 1)
                CreateDropdown("Outline:", FONT_OUTLINES, visualSettings.healthText, "fontOutline")
                if visualSettings.healthText.color then
                    CreateColorPicker("Text Color:", visualSettings.healthText, "color")
                end
                
                CreateHeader("Health Text Position")
                if visualSettings.healthText.hAlign then
                    CreateDropdown("H Align:", HORIZONTAL_ALIGN, visualSettings.healthText, "hAlign")
                    CreateDropdown("V Align:", VERTICAL_ALIGN, visualSettings.healthText, "vAlign")
                end
                CreateSlider("Offset X:", visualSettings.healthText, "offsetX", -100, 100, 1)
                CreateSlider("Offset Y:", visualSettings.healthText, "offsetY", -50, 50, 1)
            end
            
            -- Heal Prediction settings (for all frame types)
            CreateHeader("Heal Prediction")
            
            -- Ensure healPrediction settings exist
            if not unitSettings.healPrediction or type(unitSettings.healPrediction) ~= "table" then
                unitSettings.healPrediction = {
                    enabled = true,
                    showMyHeals = true,
                    showOtherHeals = true,
                    separateColors = false,
                    myHealsColor = { 0.0, 0.8, 0.2, 0.5 },
                    otherHealsColor = { 0.0, 0.6, 0.8, 0.5 },
                    allHealsColor = { 0.0, 0.7, 0.4, 0.5 },
                    showAbsorbs = true,
                    absorbColor = { 0.8, 0.8, 0.2, 0.6 },
                    absorbOverlay = true,
                }
            end
            local hpSettings = unitSettings.healPrediction
            
            CreateCheckbox("Show Incoming Heals", hpSettings, "enabled", function()
                local HealPrediction = TweaksUI.UnitFramesHealPrediction
                if HealPrediction then
                    if hpSettings.enabled then
                        HealPrediction:RegisterEvents()
                        HealPrediction:Start(0.05)
                    else
                        HealPrediction:Stop()
                        HealPrediction:UnregisterEvents()
                        -- Reset appropriate frames based on unit type
                        if isParty then
                            HealPrediction:ResetAllFrames(module:GetPartyMemberFrames())
                        elseif isRaid then
                            HealPrediction:ResetAllFrames(module:GetRaidMemberFrames())
                        end
                    end
                end
            end)
            CreateCheckbox("Show My Heals", hpSettings, "showMyHeals")
            CreateCheckbox("Show Other Players' Heals", hpSettings, "showOtherHeals")
            CreateCheckbox("Separate Colors (my vs others)", hpSettings, "separateColors")
            CreateCheckbox("Show Absorb Shields", hpSettings, "showAbsorbs")
            CreateCheckbox("Absorb Overlay Effect", hpSettings, "absorbOverlay")
            
        elseif categoryId == "power" then
            -- POWER BAR
            
            
            CreateHeader("Power Bar")
            if visualSettings.powerBar then
                CreateCheckbox("Enable Power Bar", visualSettings.powerBar, "enabled")
                CreateSlider("Height:", visualSettings.powerBar, "height", 2, 30, 1)
                if visualSettings.powerBar.colorMode then
                    CreateDropdown("Color Mode:", POWER_COLOR_MODES, visualSettings.powerBar, "colorMode")
                    CreateColorPicker("Custom Color:", visualSettings.powerBar, "customColor")
                end
                
                if LibSharedMedia then
                    local textures = LibSharedMedia:List("statusbar")
                    local texOpts = {}
                    for _, tex in ipairs(textures) do
                        table.insert(texOpts, { id = tex, name = tex })
                    end
                    CreateDropdown("Texture:", texOpts, visualSettings.powerBar, "texture")
                    
                    -- Bar shape/masking dropdown
                    if TweaksUI.BarMasking then
                        local shapeOpts = {}
                        for _, shape in ipairs(TweaksUI.BarMasking:GetShapeList()) do
                            table.insert(shapeOpts, { id = shape, name = TweaksUI.BarMasking:GetShapeName(shape) })
                        end
                        CreateDropdown("Bar Shape:", shapeOpts, visualSettings.powerBar, "maskShape")
                    end
                end
                
                CreateHeader("Background & Border")
                CreateCheckbox("Show Background", visualSettings.powerBar, "bgEnabled")
                CreateColorPicker("Background Color:", visualSettings.powerBar, "bgColor")
                CreateCheckbox("Show Border", visualSettings.powerBar, "borderEnabled")
                CreateColorPicker("Border Color:", visualSettings.powerBar, "borderColor")
                CreateSlider("Border Size:", visualSettings.powerBar, "borderSize", 1, 4, 1)
            end
            
            if visualSettings.powerText then
                CreateHeader("Power Text")
                CreateCheckbox("Enable Power Text", visualSettings.powerText, "enabled")
                CreateDropdown("Format:", POWER_TEXT_FORMATS, visualSettings.powerText, "format")
                
                -- Midnight Beta warning for percentage formats
                if HAS_MIDNIGHT_APIS then
                    local warningLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    warningLabel:SetPoint("TOPLEFT", 20, yOffset)
                    warningLabel:SetWidth(PANEL_WIDTH - 80)
                    warningLabel:SetText("|cffff8800Note:|r Percentage may show incorrect values in Midnight Beta.")
                    warningLabel:SetJustifyH("LEFT")
                    yOffset = yOffset - 20
                end
                
                -- Always show abbreviate checkbox (default to true if not set)
                if visualSettings.powerText.abbreviate == nil then
                    visualSettings.powerText.abbreviate = true
                end
                CreateCheckbox("Abbreviate Numbers (85k)", visualSettings.powerText, "abbreviate")
                CreateSlider("Font Size:", visualSettings.powerText, "fontSize", 8, 18, 1)
                CreateDropdown("Outline:", FONT_OUTLINES, visualSettings.powerText, "fontOutline")
                if visualSettings.powerText.color then
                    CreateColorPicker("Text Color:", visualSettings.powerText, "color")
                end
                
                if visualSettings.powerText.hAlign then
                    CreateHeader("Power Text Position")
                    CreateDropdown("H Align:", HORIZONTAL_ALIGN, visualSettings.powerText, "hAlign")
                    CreateDropdown("V Align:", VERTICAL_ALIGN, visualSettings.powerText, "vAlign")
                    CreateSlider("Offset X:", visualSettings.powerText, "offsetX", -100, 100, 1)
                    CreateSlider("Offset Y:", visualSettings.powerText, "offsetY", -50, 50, 1)
                end
            end
            
        elseif categoryId == "classpower" then
            -- ================================================================
            -- CLASS POWER (Combo Points, Holy Power, Chi, etc.)
            -- Dedicated tab for player frame only
            -- ================================================================
            
            -- Ensure classPower settings exist (for older profiles)
            if not visualSettings.classPower then
                visualSettings.classPower = {
                    enabled = true,
                    height = 8,
                    spacing = 2,
                    position = "below",
                    offsetY = 0,
                    style = "segments",
                    texture = "Blizzard",
                    useResourceColor = true,
                    customColor = { 1, 0.8, 0, 1 },
                    bgColor = { 0.15, 0.15, 0.15, 0.8 },
                    inactiveColor = { 0.2, 0.2, 0.2, 0.6 },
                    showBorder = true,
                    borderColor = { 0, 0, 0, 1 },
                    borderSize = 1,
                }
            end
            
            CreateHeader("Class Power")
            CreateCheckbox("Enable Class Power", visualSettings.classPower, "enabled")
            
            -- Info about what this controls
            local infoLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            infoLabel:SetPoint("TOPLEFT", 20, yOffset)
            infoLabel:SetWidth(PANEL_WIDTH - 80)
            infoLabel:SetText("|cff888888Controls: Combo Points, Holy Power, Chi, Soul Shards, Arcane Charges, Runes, Essence, Stagger|r")
            infoLabel:SetJustifyH("LEFT")
            yOffset = yOffset - 25
            
            local staggerNote = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            staggerNote:SetPoint("TOPLEFT", 20, yOffset)
            staggerNote:SetWidth(PANEL_WIDTH - 80)
            staggerNote:SetText("|cff666666Note: Stagger shows as a continuous bar with percentage|r")
            staggerNote:SetJustifyH("LEFT")
            yOffset = yOffset - 20
            
            CreateHeader("Position & Size")
            local CP_POSITIONS = {
                { id = "below", name = "Below Power Bar" },
                { id = "above", name = "Above Health Bar" },
                { id = "inside", name = "Inside Power Bar" },
            }
            CreateDropdown("Position:", CP_POSITIONS, visualSettings.classPower, "position")
            CreateSlider("Height:", visualSettings.classPower, "height", 4, 16, 1)
            CreateSlider("Spacing:", visualSettings.classPower, "spacing", 0, 8, 1)
            CreateSlider("Offset Y:", visualSettings.classPower, "offsetY", -20, 20, 1)
            
            CreateHeader("Colors")
            CreateCheckbox("Use Resource Color", visualSettings.classPower, "useResourceColor")
            CreateColorPicker("Custom Color:", visualSettings.classPower, "customColor")
            CreateColorPicker("Background:", visualSettings.classPower, "bgColor")
            CreateColorPicker("Inactive Color:", visualSettings.classPower, "inactiveColor")
            
            CreateHeader("Border")
            CreateCheckbox("Show Border", visualSettings.classPower, "showBorder")
            CreateColorPicker("Border Color:", visualSettings.classPower, "borderColor")
            CreateSlider("Border Size:", visualSettings.classPower, "borderSize", 1, 4, 1)
            
            -- Text format options - different for stagger vs discrete resources
            local _, playerClass = UnitClass("player")
            local isBrewmaster = false
            if playerClass == "MONK" then
                local specIndex = GetSpecialization()
                local specID = specIndex and GetSpecializationInfo(specIndex)
                isBrewmaster = (specID == 268) or (specIndex == 1)
            end
            
            if isBrewmaster then
                CreateHeader("Stagger Text")
                local STAGGER_TEXT_FORMATS = {
                    { id = "amount", name = "Amount (23.5K)" },
                    { id = "percent", name = "Percent (45%)" },
                    { id = "both", name = "Both (23.5K (45%))" },
                }
                if not visualSettings.classPower.staggerTextFormat then
                    visualSettings.classPower.staggerTextFormat = "percent"
                end
                CreateDropdown("Text Format:", STAGGER_TEXT_FORMATS, visualSettings.classPower, "staggerTextFormat")
            else
                CreateHeader("Text")
                CreateCheckbox("Show Text", visualSettings.classPower, "showText")
                local CP_TEXT_FORMATS = {
                    { id = "current", name = "Current (3)" },
                    { id = "current_max", name = "Current / Max (3/5)" },
                }
                if not visualSettings.classPower.textFormat then
                    visualSettings.classPower.textFormat = "current"
                end
                CreateDropdown("Text Format:", CP_TEXT_FORMATS, visualSettings.classPower, "textFormat")
            end
            
        elseif categoryId == "absorb" then
            -- ================================================================
            -- ABSORB BAR
            -- ================================================================
            
            if visualSettings.absorbBar then
                CreateHeader("Absorb Bar")
                CreateCheckbox("Enable Absorb Bar", visualSettings.absorbBar, "enabled")
                
                local ABSORB_STYLES = {
                    { id = "overlay", name = "Overlay (on health bar)" },
                    { id = "bar", name = "Separate Bar" },
                }
                CreateDropdown("Style:", ABSORB_STYLES, visualSettings.absorbBar, "style")
                CreateSlider("Height (bar style):", visualSettings.absorbBar, "height", 2, 20, 1)
                
                local ABSORB_FILL_DIRS = {
                    { id = "leftToRight", name = "Left to Right" },
                    { id = "rightToLeft", name = "Right to Left" },
                }
                CreateDropdown("Fill Direction:", ABSORB_FILL_DIRS, visualSettings.absorbBar, "fillDirection")
                CreateSlider("Offset X:", visualSettings.absorbBar, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.absorbBar, "offsetY", -50, 50, 1)
                
                CreateHeader("Appearance")
                CreateColorPicker("Bar Color:", visualSettings.absorbBar, "color")
                
                if LibSharedMedia then
                    local textures = LibSharedMedia:List("statusbar")
                    local texOpts = {}
                    for _, tex in ipairs(textures) do
                        table.insert(texOpts, { id = tex, name = tex })
                    end
                    CreateDropdown("Texture:", texOpts, visualSettings.absorbBar, "texture")
                end
                
                CreateHeader("Background")
                CreateCheckbox("Show Background", visualSettings.absorbBar, "bgEnabled")
                CreateColorPicker("Background Color:", visualSettings.absorbBar, "bgColor")
                
                CreateHeader("Border")
                CreateCheckbox("Show Border", visualSettings.absorbBar, "borderEnabled")
                CreateColorPicker("Border Color:", visualSettings.absorbBar, "borderColor")
                CreateSlider("Border Size:", visualSettings.absorbBar, "borderSize", 1, 4, 1)
                
                CreateHeader("Label")
                CreateCheckbox("Show Label", visualSettings.absorbBar, "showLabel")
                
                if visualSettings.absorbBar.showLabel then
                    -- Create text input for label
                    local labelContainer = CreateFrame("Frame", nil, content)
                    labelContainer:SetPoint("TOPLEFT", 5, yOffset)
                    labelContainer:SetSize(280, 24)
                    
                    local labelLabel = labelContainer:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
                    labelLabel:SetPoint("LEFT", 0, 0)
                    labelLabel:SetText("Label Text:")
                    labelLabel:SetWidth(85)
                    labelLabel:SetJustifyH("LEFT")
                    
                    local labelEditBox = CreateFrame("EditBox", nil, labelContainer, "InputBoxTemplate")
                    labelEditBox:SetPoint("LEFT", 88, 0)
                    labelEditBox:SetSize(140, 20)
                    labelEditBox:SetAutoFocus(false)
                    labelEditBox:SetText(visualSettings.absorbBar.labelText or "Absorb")
                    labelEditBox:SetScript("OnEnterPressed", function(self)
                        visualSettings.absorbBar.labelText = self:GetText()
                        self:ClearFocus()
                        module:RefreshFrame(unit)
                    end)
                    labelEditBox:SetScript("OnEscapePressed", function(self)
                        self:SetText(visualSettings.absorbBar.labelText or "Absorb")
                        self:ClearFocus()
                    end)
                    yOffset = yOffset - 28
                    
                    local LABEL_POSITIONS = {
                        { id = "LEFT", name = "Left" },
                        { id = "RIGHT", name = "Right" },
                        { id = "TOP", name = "Top" },
                        { id = "BOTTOM", name = "Bottom" },
                        { id = "CENTER", name = "Center" },
                    }
                    CreateDropdown("Label Position:", LABEL_POSITIONS, visualSettings.absorbBar, "labelPosition")
                    CreateSlider("Label Font Size:", visualSettings.absorbBar, "labelFontSize", 6, 16, 1)
                    CreateColorPicker("Label Color:", visualSettings.absorbBar, "labelColor")
                    CreateSlider("Label Offset X:", visualSettings.absorbBar, "labelOffsetX", -50, 50, 1)
                    CreateSlider("Label Offset Y:", visualSettings.absorbBar, "labelOffsetY", -30, 30, 1)
                end
                
                CreateHeader("Value Text")
                CreateCheckbox("Show Value Text", visualSettings.absorbBar, "showText")
                
                if visualSettings.absorbBar.showText then
                    local ABSORB_FORMATS = {
                        { id = "current", name = "Current" },
                        { id = "current_max", name = "Current / Max Health" },
                    }
                    CreateDropdown("Text Format:", ABSORB_FORMATS, visualSettings.absorbBar, "textFormat")
                    CreateSlider("Text Font Size:", visualSettings.absorbBar, "textFontSize", 8, 16, 1)
                    CreateSlider("Text Offset X:", visualSettings.absorbBar, "textOffsetX", -50, 50, 1)
                    CreateSlider("Text Offset Y:", visualSettings.absorbBar, "textOffsetY", -20, 20, 1)
                end
            else
                local label = content:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
                label:SetPoint("TOPLEFT", 10, yOffset)
                label:SetText("Absorb bar settings not available for this frame type.")
                yOffset = yOffset - 20
            end
            
        elseif categoryId == "castbar" then
            -- CAST BAR
            
            -- Helper function to update preview after cast bar changes
            local function UpdateCastBarPreview()
                if currentOpenPanel then
                    module:ShowPanelPreview(currentOpenPanel)
                end
            end
            
            CreateHeader("Cast Bar Settings")
            if visualSettings.castBar then
                CreateCheckbox("Enable Cast Bar", visualSettings.castBar, "enabled", UpdateCastBarPreview)
                CreateSlider("Height:", visualSettings.castBar, "height", 4, 20, 1)
                CreateCheckbox("Show Spell Icon", visualSettings.castBar, "showIcon", UpdateCastBarPreview)
                CreateCheckbox("Show Timer", visualSettings.castBar, "showTimer", UpdateCastBarPreview)
                CreateCheckbox("Show Spell Name", visualSettings.castBar, "showSpellName", UpdateCastBarPreview)
                if visualSettings.castBar.attachedTo then
                    local CASTBAR_POSITIONS = {
                        { id = "bottom", name = "Below Frame" },
                        { id = "health", name = "Inside Health Bar" },
                    }
                    CreateDropdown("Position:", CASTBAR_POSITIONS, visualSettings.castBar, "attachedTo")
                    CreateSlider("Offset Y:", visualSettings.castBar, "offsetY", -20, 20, 1)
                end
                
                CreateHeader("Appearance")
                if LibSharedMedia then
                    local textures = LibSharedMedia:List("statusbar")
                    local texOpts = {}
                    for _, tex in ipairs(textures) do
                        table.insert(texOpts, { id = tex, name = tex })
                    end
                    CreateDropdown("Texture:", texOpts, visualSettings.castBar, "texture")
                end
                CreateColorPicker("Cast Color:", visualSettings.castBar, "color")
                CreateColorPicker("Interrupted Color:", visualSettings.castBar, "interruptedColor")
                CreateColorPicker("Non-Interruptible:", visualSettings.castBar, "nonInterruptibleColor")
                
                CreateHeader("Background & Border")
                CreateCheckbox("Show Background", visualSettings.castBar, "bgEnabled")
                CreateColorPicker("Background Color:", visualSettings.castBar, "bgColor")
                CreateCheckbox("Show Border", visualSettings.castBar, "borderEnabled")
                CreateColorPicker("Border Color:", visualSettings.castBar, "borderColor")
                CreateSlider("Border Size:", visualSettings.castBar, "borderSize", 1, 4, 1)
            else
                local label = content:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
                label:SetPoint("TOPLEFT", 5, yOffset)
                label:SetText("|cffff6666Cast bar settings unavailable for this layout.|r")
                yOffset = yOffset - 20
            end
            
        elseif categoryId == "text" then
            -- TEXT & ICONS
            
            
            if visualSettings.nameText then
                CreateHeader("Name Text")
                CreateCheckbox("Enable Name", visualSettings.nameText, "enabled")
                if visualSettings.nameText.anchorToHealthBar ~= nil then
                    CreateCheckbox("Inside Health Bar", visualSettings.nameText, "anchorToHealthBar")
                end
                CreateSlider("Font Size:", visualSettings.nameText, "fontSize", 8, 24, 1)
                CreateDropdown("Outline:", FONT_OUTLINES, visualSettings.nameText, "fontOutline")
                CreateDropdown("Color Mode:", NAME_COLOR_MODES, visualSettings.nameText, "colorMode")
                CreateColorPicker("Custom Color:", visualSettings.nameText, "customColor")
                CreateDropdown("Anchor:", ANCHOR_POINTS, visualSettings.nameText, "anchor")
                CreateSlider("Offset X:", visualSettings.nameText, "offsetX", -100, 100, 1)
                CreateSlider("Offset Y:", visualSettings.nameText, "offsetY", -50, 50, 1)
                if visualSettings.nameText.maxLength then
                    CreateSlider("Max Length:", visualSettings.nameText, "maxLength", 0, 20, 1)
                end
            end
            
            -- Level Text - skip for party/raid frames (level synced in instances)
            if visualSettings.levelText and not isGroupFrame then
                CreateHeader("Level Text")
                CreateCheckbox("Enable Level", visualSettings.levelText, "enabled")
                CreateCheckbox("Show Classification", visualSettings.levelText, "showClassification")
                CreateCheckbox("Hide at Max Level", visualSettings.levelText, "hideAtMaxLevel")
                CreateSlider("Font Size:", visualSettings.levelText, "fontSize", 8, 18, 1)
                CreateDropdown("Outline:", FONT_OUTLINES, visualSettings.levelText, "fontOutline")
                CreateDropdown("Anchor:", ANCHOR_POINTS, visualSettings.levelText, "anchor")
                CreateSlider("Offset X:", visualSettings.levelText, "offsetX", -100, 100, 1)
                CreateSlider("Offset Y:", visualSettings.levelText, "offsetY", -50, 50, 1)
            end
            
            if visualSettings.raidTarget then
                CreateHeader("Raid Target Icon")
                CreateCheckbox("Enable Raid Target", visualSettings.raidTarget, "enabled")
                CreateSlider("Size:", visualSettings.raidTarget, "size", 8, 64, 1)
                CreateDropdown("Icon Anchor:", ANCHOR_POINTS, visualSettings.raidTarget, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.raidTarget, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.raidTarget, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.raidTarget, "offsetY", -50, 50, 1)
            end
            
            if visualSettings.roleIcon then
                CreateHeader("Role Icon")
                CreateCheckbox("Enable Role Icon", visualSettings.roleIcon, "enabled")
                CreateSlider("Size:", visualSettings.roleIcon, "size", 8, 64, 1)
                CreateDropdown("Icon Anchor:", ANCHOR_POINTS, visualSettings.roleIcon, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.roleIcon, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.roleIcon, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.roleIcon, "offsetY", -50, 50, 1)
            end
            
            -- ================================================================
            -- STATUS INDICATORS (Combat & Resting) - Player frame only
            -- ================================================================
            if visualSettings.statusIndicators then
                CreateHeader("Status Indicators")
                local statusNote = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                statusNote:SetPoint("TOPLEFT", 10, yOffset)
                statusNote:SetText("|cff888888(Combat swords / Resting Zzz - Player only)|r")
                yOffset = yOffset - 16
                
                CreateCheckbox("Enable Status Indicators", visualSettings.statusIndicators, "enabled")
                CreateCheckbox("Show Combat Indicator", visualSettings.statusIndicators, "showCombat")
                CreateCheckbox("Show Resting Indicator", visualSettings.statusIndicators, "showResting")
                CreateSlider("Size:", visualSettings.statusIndicators, "size", 12, 48, 1)
                CreateDropdown("Icon Anchor:", ANCHOR_POINTS, visualSettings.statusIndicators, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.statusIndicators, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.statusIndicators, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.statusIndicators, "offsetY", -50, 50, 1)
            end
            
            -- ================================================================
            -- LEADER INDICATOR
            -- ================================================================
            if visualSettings.leaderIndicator then
                CreateHeader("Leader Indicator")
                local leaderNote = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                leaderNote:SetPoint("TOPLEFT", 10, yOffset)
                leaderNote:SetText("|cff888888(Crown for leader, diamond for assistant)|r")
                yOffset = yOffset - 16
                
                CreateCheckbox("Enable Leader Indicator", visualSettings.leaderIndicator, "enabled")
                CreateSlider("Size:", visualSettings.leaderIndicator, "size", 8, 32, 1)
                CreateDropdown("Icon Anchor:", ANCHOR_POINTS, visualSettings.leaderIndicator, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.leaderIndicator, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.leaderIndicator, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.leaderIndicator, "offsetY", -50, 50, 1)
            end
            
            -- ================================================================
            -- SUMMON INDICATOR
            -- ================================================================
            if visualSettings.summonIndicator then
                CreateHeader("Summon Indicator")
                local summonNote = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                summonNote:SetPoint("TOPLEFT", 10, yOffset)
                summonNote:SetText("|cff888888(Shows pending/accepted warlock summons)|r")
                yOffset = yOffset - 16
                
                CreateCheckbox("Enable Summon Indicator", visualSettings.summonIndicator, "enabled")
                CreateSlider("Size:", visualSettings.summonIndicator, "size", 12, 40, 1)
                CreateDropdown("Icon Anchor:", ANCHOR_POINTS, visualSettings.summonIndicator, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.summonIndicator, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.summonIndicator, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.summonIndicator, "offsetY", -50, 50, 1)
                CreateColorPicker("Pending Color:", visualSettings.summonIndicator, "pendingColor")
                CreateColorPicker("Accepted Color:", visualSettings.summonIndicator, "acceptedColor")
            end
            
            -- ================================================================
            -- TARGET HIGHLIGHT
            -- ================================================================
            if visualSettings.targetHighlight then
                CreateHeader("Target Highlight")
                local targetNote = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                targetNote:SetPoint("TOPLEFT", 10, yOffset)
                targetNote:SetText("|cff888888(Highlights when this unit is your target)|r")
                yOffset = yOffset - 16
                
                CreateCheckbox("Enable Target Highlight", visualSettings.targetHighlight, "enabled")
                
                local targetStyleOptions = {
                    { id = "border", name = "Border" },
                    { id = "glow", name = "Glow" },
                }
                CreateDropdown("Style:", targetStyleOptions, visualSettings.targetHighlight, "style")
                CreateColorPicker("Highlight Color:", visualSettings.targetHighlight, "color")
                CreateSlider("Border Thickness:", visualSettings.targetHighlight, "thickness", 1, 5, 1)
            end
            
        elseif categoryId == "portrait" then
            -- PORTRAIT
            
            
            CreateHeader("Portrait Settings")
            if visualSettings.portrait then
                CreateDropdown("Mode:", PORTRAIT_MODES, visualSettings.portrait, "mode", function(newMode)
                    visualSettings.portrait.enabled = (newMode ~= "none")
                end)
                CreateDropdown("Position:", PORTRAIT_POSITIONS, visualSettings.portrait, "position")
                CreateCheckbox("Outside Frame", visualSettings.portrait, "outside")
                CreateSlider("Size:", visualSettings.portrait, "size", 10, 80, 1)
                CreateSlider("Offset X:", visualSettings.portrait, "offsetX", -80, 50, 1)
                CreateSlider("Offset Y:", visualSettings.portrait, "offsetY", -50, 50, 1)
            else
                local label = content:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
                label:SetPoint("TOPLEFT", 5, yOffset)
                label:SetText("|cffff6666Portrait settings unavailable for this layout.|r")
                yOffset = yOffset - 20
            end
            
        elseif categoryId == "container" then
            -- PARTY/RAID CONTAINER (group-specific)
            
            if isParty then
                -- Show Preview checkbox (not saved, transient state)
                local previewCb = CreateFrame("CheckButton", nil, content, "UICheckButtonTemplate")
                previewCb:SetPoint("TOPLEFT", 10, yOffset)
                previewCb:SetSize(22, 22)
                previewCb:SetChecked(previewParty)
                
                local previewLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormal")
                previewLabel:SetPoint("LEFT", previewCb, "RIGHT", 4, 0)
                previewLabel:SetText("|cffFFFF00Show Preview Frames|r")
                
                previewCb:SetScript("OnClick", function(self)
                    previewParty = self:GetChecked()
                    module:UpdatePartyFrames()
                end)
                yOffset = yOffset - 26
                
                -- Add drag hint for moving containers
                local dragHint = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                dragHint:SetPoint("TOPLEFT", 10, yOffset)
                dragHint:SetWidth(PANEL_WIDTH - 40)
                dragHint:SetJustifyH("LEFT")
                dragHint:SetText("|cff888888Preview frames let you position when not in a group|r")
                yOffset = yOffset - 18
                
                CreateHeader("Party Container")
                CreateCheckbox("Enable Party Frames", unitSettings, "enabled")
                CreateCheckbox("Hide When in Raid", unitSettings, "hideInRaid")
                
                if unitSettings.container then
                    CreateHeader("Growth Direction")
                    local growthOptions = {
                        { id = "DOWN", name = "Down" },
                        { id = "UP", name = "Up" },
                        { id = "RIGHT", name = "Right" },
                        { id = "LEFT", name = "Left" },
                    }
                    CreateDropdown("Direction:", growthOptions, unitSettings.container, "growthDirection")
                    CreateSlider("Spacing:", unitSettings.container, "spacing", 0, 20, 1)
                    CreateSlider("Scale:", unitSettings.container, "scale", 0.5, 2.0, 0.05, true)
                    
                    CreateHeader("Container Position")
                    CreateSlider("X Position:", unitSettings.container, "x", -800, 800, 1)
                    CreateSlider("Y Position:", unitSettings.container, "y", -500, 500, 1)
                    CreateDropdown("Anchor:", ANCHOR_POINTS, unitSettings.container, "anchor")
                    
                    CreateHeader("Sorting")
                    
                    -- Ensure sorting settings exist and is a proper table (may have old string value from previous version)
                    if not unitSettings.sorting or type(unitSettings.sorting) ~= "table" then
                        unitSettings.sorting = {
                            enabled = true,
                            sortByRole = true,
                            separateMeleeRanged = true,
                            sortByClass = false,
                            sortAlphabetically = true,
                            selfPosition = "NORMAL",
                        }
                    end
                    local sortSettings = unitSettings.sorting
                    
                    CreateCheckbox("Enable Sorting", sortSettings, "enabled", function()
                        module:UpdatePartyFrames()
                    end)
                    
                    CreateCheckbox("Sort by Role (Tank  Healer  DPS)", sortSettings, "sortByRole", function()
                        module:UpdatePartyFrames()
                    end)
                    
                    CreateCheckbox("Separate Melee/Ranged DPS", sortSettings, "separateMeleeRanged", function()
                        module:UpdatePartyFrames()
                    end)
                    
                    CreateCheckbox("Sort by Class (within role)", sortSettings, "sortByClass", function()
                        module:UpdatePartyFrames()
                    end)
                    
                    CreateCheckbox("Sort Alphabetically (within class)", sortSettings, "sortAlphabetically", function()
                        module:UpdatePartyFrames()
                    end)
                    
                    -- Self position dropdown
                    local selfOptions = {
                        { id = "NORMAL", name = "Sort Normally" },
                        { id = "FIRST", name = "Always First" },
                        { id = "LAST", name = "Always Last" },
                    }
                    CreateDropdown("Your Position:", selfOptions, sortSettings, "selfPosition", function()
                        module:UpdatePartyFrames()
                    end)
                    
                    -- Range Fade Section
                    CreateHeader("Range Fade")
                    
                    -- Ensure rangeFade settings exist and is a proper table
                    if not unitSettings.rangeFade or type(unitSettings.rangeFade) ~= "table" then
                        unitSettings.rangeFade = {
                            enabled = true,
                            checkInterval = 0.2,
                            outOfRangeAlpha = 0.4,
                            perElementFade = true,
                        }
                    end
                    local rfSettings = unitSettings.rangeFade
                    
                    CreateCheckbox("Fade Out-of-Range Members", rfSettings, "enabled", function()
                        local RangeFade = TweaksUI.UnitFramesRangeFade
                        if RangeFade then
                            if rfSettings.enabled then
                                RangeFade:Start(rfSettings.checkInterval)
                            else
                                RangeFade:Stop()
                                RangeFade:ResetAllFrames(module:GetPartyMemberFrames())
                            end
                        end
                    end)
                    
                    CreateCheckbox("Per-Element Fade (names stay visible)", rfSettings, "perElementFade")
                    
                    CreateSlider("Out-of-Range Opacity:", rfSettings, "outOfRangeAlpha", 0, 1, 0.05, true)
                end
            elseif isRaid then
                -- Show Preview checkbox (not saved, transient state)
                local previewCb = CreateFrame("CheckButton", nil, content, "UICheckButtonTemplate")
                previewCb:SetPoint("TOPLEFT", 10, yOffset)
                previewCb:SetSize(22, 22)
                -- Check the appropriate flag for this raid size
                previewCb:SetChecked(isRaidSmall and simulateRaidSmall or simulateRaidLarge)
                
                local previewLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormal")
                previewLabel:SetPoint("LEFT", previewCb, "RIGHT", 4, 0)
                previewLabel:SetText("|cffFFFF00Show Preview Frames|r")
                
                previewCb:SetScript("OnClick", function(self)
                    if isRaidSmall then
                        simulateRaidSmall = self:GetChecked()
                    else
                        simulateRaidLarge = self:GetChecked()
                    end
                    module:UpdateRaidFrames()
                end)
                yOffset = yOffset - 26
                
                -- Add drag hint
                local dragHint = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                dragHint:SetPoint("TOPLEFT", 10, yOffset)
                dragHint:SetWidth(PANEL_WIDTH - 40)
                dragHint:SetJustifyH("LEFT")
                dragHint:SetText("|cff888888Preview frames let you position when not in a raid|r")
                yOffset = yOffset - 18
                
                -- RAID FRAMES - separate panels for small and large
                local layoutLabel = isRaidSmall and "Small Raid (10-20)" or "Large Raid (21-40)"
                CreateHeader(layoutLabel)
                
                -- Enable checkbox controls the master raid enabled flag
                if parentRaidSettings then
                    CreateCheckbox("Enable Raid Frames", parentRaidSettings, "enabled")
                    
                    -- Size threshold only shown in small raid panel
                    if isRaidSmall then
                        CreateHeader("Size Threshold")
                        local thresholdInfo = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                        thresholdInfo:SetPoint("TOPLEFT", 10, yOffset)
                        thresholdInfo:SetWidth(300)
                        thresholdInfo:SetJustifyH("LEFT")
                        thresholdInfo:SetText("|cff888888Small layout for  threshold players|r")
                        yOffset = yOffset - 18
                        CreateSlider("Threshold:", parentRaidSettings, "sizeThreshold", 10, 30, 1)
                    end
                end
                
                -- Layout settings for this specific size
                if unitSettings.layout then
                    CreateHeader("Layout Mode")
                    local layoutModes = {
                        { id = "GRID", name = "Grid (ignore groups)" },
                        { id = "GROUP_ROWS", name = "Group Rows (G1 G2 G3...)" },
                        { id = "GROUP_COLUMNS", name = "Group Columns (G1 over G2)" },
                    }
                    CreateDropdown("Mode:", layoutModes, unitSettings.layout, "mode")
                    
                    -- Grid-specific settings
                    CreateHeader("Grid Settings")
                    local gridInfo = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    gridInfo:SetPoint("TOPLEFT", 10, yOffset)
                    gridInfo:SetText("|cff888888(Only used in Grid mode)|r")
                    yOffset = yOffset - 16
                    
                    CreateSlider("Columns:", unitSettings.layout, "columns", 1, 10, 1)
                    CreateSlider("Spacing:", unitSettings.layout, "spacing", 0, 10, 1)
                    
                    local growthOptions = {
                        { id = "DOWN", name = "Down" },
                        { id = "UP", name = "Up" },
                        { id = "RIGHT", name = "Right" },
                        { id = "LEFT", name = "Left" },
                    }
                    CreateDropdown("Fill Direction:", growthOptions, unitSettings.layout, "growthDirection")
                    
                    -- Group-specific settings
                    CreateHeader("Group Layout Settings")
                    local groupInfo = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    groupInfo:SetPoint("TOPLEFT", 10, yOffset)
                    groupInfo:SetText("|cff888888(Only used in Group Rows/Columns modes)|r")
                    yOffset = yOffset - 16
                    
                    CreateSlider("Groups per Row:", unitSettings.layout, "groupsPerRow", 1, 8, 1)
                    CreateSlider("Groups per Column:", unitSettings.layout, "groupsPerColumn", 1, 8, 1)
                    CreateSlider("Group Spacing:", unitSettings.layout, "groupSpacing", 0, 20, 1)
                    
                    CreateHeader("Members Within Group")
                    CreateSlider("Members per Row:", unitSettings.layout, "membersPerRow", 1, 5, 1)
                    
                    local memberGrowthOptions = {
                        { id = "DOWN", name = "Down (rows of members)" },
                        { id = "RIGHT", name = "Right (columns of members)" },
                    }
                    CreateDropdown("Member Fill:", memberGrowthOptions, unitSettings.layout, "memberGrowth")
                end
                
                -- Container position
                if unitSettings.container then
                    CreateHeader("Container")
                    CreateSlider("Scale:", unitSettings.container, "scale", 0.5, 2.0, 0.05, true)
                    CreateSlider("X Position:", unitSettings.container, "x", -800, 800, 1)
                    CreateSlider("Y Position:", unitSettings.container, "y", -500, 500, 1)
                    CreateDropdown("Anchor:", ANCHOR_POINTS, unitSettings.container, "anchor")
                end
                
                -- Sorting Section (for raids)
                CreateHeader("Sorting")
                
                -- Ensure sorting settings exist
                if not unitSettings.sorting or type(unitSettings.sorting) ~= "table" then
                    unitSettings.sorting = {
                        enabled = true,
                        sortByRole = true,
                        separateMeleeRanged = false,
                        sortByClass = false,
                        sortAlphabetically = true,
                        sortByGroup = true,
                        selfPosition = "NORMAL",
                    }
                end
                local sortSettings = unitSettings.sorting
                
                CreateCheckbox("Enable Sorting", sortSettings, "enabled", function()
                    module:UpdateRaidFrames()
                end)
                CreateCheckbox("Sort by Role (Tank  Healer  DPS)", sortSettings, "sortByRole", function()
                    module:UpdateRaidFrames()
                end)
                CreateCheckbox("Keep Group Order", sortSettings, "sortByGroup", function()
                    module:UpdateRaidFrames()
                end)
                CreateCheckbox("Sort by Class (within role)", sortSettings, "sortByClass", function()
                    module:UpdateRaidFrames()
                end)
                CreateCheckbox("Sort Alphabetically", sortSettings, "sortAlphabetically", function()
                    module:UpdateRaidFrames()
                end)
                
                -- Range Fade Section (for raids)
                CreateHeader("Range Fade")
                
                -- Ensure rangeFade settings exist
                if not unitSettings.rangeFade or type(unitSettings.rangeFade) ~= "table" then
                    unitSettings.rangeFade = {
                        enabled = true,
                        checkInterval = 0.2,
                        outOfRangeAlpha = 0.4,
                        perElementFade = isRaidSmall,
                    }
                end
                local rfSettings = unitSettings.rangeFade
                
                CreateCheckbox("Fade Out-of-Range Members", rfSettings, "enabled")
                CreateCheckbox("Per-Element Fade (names stay visible)", rfSettings, "perElementFade")
                CreateSlider("Out-of-Range Opacity:", rfSettings, "outOfRangeAlpha", 0, 1, 0.05, true)
                
            elseif isTanks then
                -- TANK FRAMES
                CreateHeader("Tank Frames")
                CreateCheckbox("Enable Tank Frames", unitSettings, "enabled")
                
                CreateHeader("Which Tanks to Show")
                CreateCheckbox("Show Main Tanks", unitSettings, "showMainTank")
                CreateCheckbox("Show Main Assists", unitSettings, "showMainAssist")
                CreateCheckbox("Show Role Tanks", unitSettings, "showRoleTanks")
                CreateSlider("Max Tanks:", unitSettings, "maxTanks", 2, 6, 1)
                
                if unitSettings.layout then
                    CreateHeader("Layout")
                    local dirOptions = {
                        { id = "DOWN", name = "Stack Down" },
                        { id = "UP", name = "Stack Up" },
                        { id = "RIGHT", name = "Stack Right" },
                        { id = "LEFT", name = "Stack Left" },
                    }
                    CreateDropdown("Direction:", dirOptions, unitSettings.layout, "direction")
                    CreateSlider("Spacing:", unitSettings.layout, "spacing", 0, 10, 1)
                end
                
                if unitSettings.container then
                    CreateHeader("Container Position")
                    CreateSlider("Scale:", unitSettings.container, "scale", 0.5, 2.0, 0.05, true)
                    CreateSlider("X Position:", unitSettings.container, "x", -800, 800, 1)
                    CreateSlider("Y Position:", unitSettings.container, "y", -500, 500, 1)
                    CreateDropdown("Anchor:", ANCHOR_POINTS, unitSettings.container, "anchor")
                end
            elseif isBoss then
                -- BOSS FRAMES
                CreateHeader("Boss Frames")
                CreateCheckbox("Enable Boss Frames", unitSettings, "enabled")
                
                CreateSlider("Max Bosses:", unitSettings, "maxBosses", 1, 5, 1)
                
                if unitSettings.layout then
                    CreateHeader("Layout")
                    local dirOptions = {
                        { id = "DOWN", name = "Stack Down" },
                        { id = "UP", name = "Stack Up" },
                        { id = "RIGHT", name = "Stack Right" },
                        { id = "LEFT", name = "Stack Left" },
                    }
                    CreateDropdown("Direction:", dirOptions, unitSettings.layout, "direction")
                    CreateSlider("Spacing:", unitSettings.layout, "spacing", 0, 10, 1)
                end
                
                if unitSettings.container then
                    CreateHeader("Container Position")
                    CreateSlider("Scale:", unitSettings.container, "scale", 0.5, 2.0, 0.05, true)
                    CreateSlider("X Position:", unitSettings.container, "x", -800, 800, 1)
                    CreateSlider("Y Position:", unitSettings.container, "y", -500, 500, 1)
                    CreateDropdown("Anchor:", ANCHOR_POINTS, unitSettings.container, "anchor")
                end
                
                if unitSettings.castBar then
                    CreateHeader("Cast Bar")
                    CreateCheckbox("Show Cast Bar", unitSettings.castBar, "enabled")
                    CreateSlider("Height:", unitSettings.castBar, "height", 5, 20, 1)
                    CreateCheckbox("Show Spell Icon", unitSettings.castBar, "showIcon")
                    CreateCheckbox("Show Timer", unitSettings.castBar, "showTimer")
                end
            end
            
        elseif categoryId == "auras" then
            -- DEBUFF INDICATORS
            
            
            if visualSettings.debuffIndicators then
                CreateHeader("Debuff Indicators (Colored Boxes)")
                
                local indDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                indDesc:SetPoint("TOPLEFT", 5, yOffset)
                indDesc:SetWidth(PANEL_WIDTH - 60)
                indDesc:SetText("Small colored boxes indicating dispellable debuffs on the unit. Each box represents one debuff, colored by type.")
                indDesc:SetTextColor(0.7, 0.7, 0.7)
                indDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 28
                
                -- Color Legend button
                local legendBtn = CreateFrame("Button", nil, content, "UIPanelButtonTemplate")
                legendBtn:SetPoint("TOPLEFT", 5, yOffset)
                legendBtn:SetSize(120, 22)
                legendBtn:SetText("Show Color Legend")
                legendBtn:SetScript("OnClick", function()
                    module:ShowDispelColorLegend(container)
                end)
                yOffset = yOffset - 28
                
                CreateCheckbox("Enable Debuff Indicators", visualSettings.debuffIndicators, "enabled")
                CreateCheckbox("Only Show Debuffs I Can Dispel", visualSettings.debuffIndicators, "onlyPlayerDispellable", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Appearance")
                CreateSlider("Size:", visualSettings.debuffIndicators, "size", 8, 32, 1)
                CreateDropdown("Position:", ANCHOR_POINTS, visualSettings.debuffIndicators, "position")
                CreateSlider("Offset X:", visualSettings.debuffIndicators, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.debuffIndicators, "offsetY", -50, 50, 1)
            end
            
            -- BUFF/DEBUFF AURA ICONS FOR INDIVIDUAL FRAMES (player, target, focus, etc.)
            if not isParty and not isRaid and not isTanks and not isBoss then
                -- Buffs Section
                CreateHeader("Buff Icons")
                
                -- Ensure buffs settings exist
                if not unitSettings.buffs then
                    unitSettings.buffs = {
                        enabled = false,
                        maxAuras = 8,
                        size = 20,
                        spacing = 2,
                        growDirection = "RIGHT",
                        anchor = "BOTTOMLEFT",
                        frameAnchor = "TOPLEFT",
                        offsetX = 0,
                        offsetY = 2,
                        filter = "HELPFUL",
                        hidePermanent = false,
                        sortRule = "Default",
                        sortDirection = "Normal",
                        showDuration = true,
                        showDurationText = true,
                        showStacks = true,
                        showBorder = true,
                    }
                end
                local buffSettings = unitSettings.buffs
                
                local buffDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                buffDesc:SetPoint("TOPLEFT", 5, yOffset)
                buffDesc:SetWidth(PANEL_WIDTH - 60)
                buffDesc:SetText("Shows buff icons on this frame.")
                buffDesc:SetTextColor(0.7, 0.7, 0.7)
                buffDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 20
                
                CreateCheckbox("Enable Buff Icons", buffSettings, "enabled", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Only Show My Buffs", buffSettings, "onlyPlayerCast", function()
                    if buffSettings.onlyPlayerCast then
                        buffSettings.filter = "HELPFUL|PLAYER"
                    else
                        buffSettings.filter = "HELPFUL"
                    end
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                buffSettings.onlyPlayerCast = buffSettings.filter and buffSettings.filter:find("PLAYER") ~= nil
                
                CreateCheckbox("Hide Permanent Buffs", buffSettings, "hidePermanent", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Sort By:", AURA_SORT_RULES, buffSettings, "sortRule", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, buffSettings, "sortDirection", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Max Icons:", buffSettings, "maxAuras", 1, 16, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Icon Size:", buffSettings, "size", 10, 120, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Spacing:", buffSettings, "spacing", 0, 10, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Grow Direction:", GROW_DIRECTIONS, buffSettings, "growDirection", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, buffSettings, "anchor", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, buffSettings, "frameAnchor", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Offset X:", buffSettings, "offsetX", -100, 100, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Offset Y:", buffSettings, "offsetY", -100, 100, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Show Cooldown Sweep", buffSettings, "showDuration", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Show Duration Text", buffSettings, "showDurationText", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Duration Font Size:", buffSettings, "durationFontSize", 6, 24, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Show Stack Count", buffSettings, "showStacks", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Stack Font Size:", buffSettings, "stackFontSize", 6, 16, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                -- Debuffs Section
                CreateHeader("Debuff Icons")
                
                -- Ensure debuffs settings exist
                if not unitSettings.debuffs then
                    unitSettings.debuffs = {
                        enabled = true,
                        maxAuras = 8,
                        size = 22,
                        spacing = 2,
                        growDirection = "RIGHT",
                        anchor = "TOPLEFT",
                        frameAnchor = "BOTTOMLEFT",
                        offsetX = 0,
                        offsetY = -2,
                        filter = "HARMFUL",
                        hidePermanent = false,
                        sortRule = "Default",
                        sortDirection = "Normal",
                        showDuration = true,
                        showDurationText = true,
                        showStacks = true,
                        showBorder = true,
                        colorByDispelType = true,
                    }
                end
                local debuffIconSettings = unitSettings.debuffs
                
                local debuffDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                debuffDesc:SetPoint("TOPLEFT", 5, yOffset)
                debuffDesc:SetWidth(PANEL_WIDTH - 60)
                debuffDesc:SetText("Shows debuff icons on this frame.")
                debuffDesc:SetTextColor(0.7, 0.7, 0.7)
                debuffDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 20
                
                CreateCheckbox("Enable Debuff Icons", debuffIconSettings, "enabled", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Color Border by Dispel Type", debuffIconSettings, "colorByDispelType", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Hide Permanent Debuffs", debuffIconSettings, "hidePermanent", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Sort By:", AURA_SORT_RULES, debuffIconSettings, "sortRule", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, debuffIconSettings, "sortDirection", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Max Icons:", debuffIconSettings, "maxAuras", 1, 16, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Icon Size:", debuffIconSettings, "size", 10, 120, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Spacing:", debuffIconSettings, "spacing", 0, 10, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Grow Direction:", GROW_DIRECTIONS, debuffIconSettings, "growDirection", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, debuffIconSettings, "anchor", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, debuffIconSettings, "frameAnchor", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Offset X:", debuffIconSettings, "offsetX", -100, 100, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Offset Y:", debuffIconSettings, "offsetY", -100, 100, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Show Cooldown Sweep", debuffIconSettings, "showDuration", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Show Duration Text", debuffIconSettings, "showDurationText", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Duration Font Size:", debuffIconSettings, "durationFontSize", 6, 24, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateCheckbox("Show Stack Count", debuffIconSettings, "showStacks", function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
                
                CreateSlider("Stack Font Size:", debuffIconSettings, "stackFontSize", 6, 16, 1, false, function()
                    UpdateFrameLayout(unit)
                    UpdateFrameData(unit)
                end)
            end
            
            -- DISPEL OVERLAY SECTION (for party and raid frames)
            -- Groups with Debuff Indicators since both relate to dispellable debuffs
            if isParty or isRaid then
                CreateHeader("Dispel Overlay (Frame Highlight)")
                
                -- Ensure dispelOverlay settings exist
                if not visualSettings.dispelOverlay then
                    visualSettings.dispelOverlay = {
                        enabled = true,
            fillAlpha = 0.5,
                        fillAlpha = 0.5,
                        showBorder = true,
                        borderSize = 2,
                        borderAlpha = 0.9,
                        showGlow = true,
                        glowSize = 3,
                        glowAlpha = 0.25,
                        showPulse = true,
                        onlyPlayerDispellable = false,
                        showBleed = false,
                        showEnrage = false,
                    }
                end
                -- Migrate: add fillAlpha if missing
                if visualSettings.dispelOverlay.fillAlpha == nil then
                    visualSettings.dispelOverlay.fillAlpha = 0.5
                end
                local dispelSettings = visualSettings.dispelOverlay
                
                local dispelDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                dispelDesc:SetPoint("TOPLEFT", 5, yOffset)
                dispelDesc:SetWidth(PANEL_WIDTH - 60)
                dispelDesc:SetText("Highlights the frame border when a unit has a dispellable debuff. Colors indicate debuff type (Magic=blue, Curse=purple, Disease=brown, Poison=green).")
                dispelDesc:SetTextColor(0.7, 0.7, 0.7)
                dispelDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 40
                
                CreateCheckbox("Enable Dispel Overlay", dispelSettings, "enabled", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Only Show Debuffs I Can Dispel", dispelSettings, "onlyPlayerDispellable", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Fill Overlay")
                CreateSlider("Fill Opacity:", dispelSettings, "fillAlpha", 0, 1.0, 0.05, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Border")
                CreateCheckbox("Show Border", dispelSettings, "showBorder", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Border Size:", dispelSettings, "borderSize", 1, 6, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Border Opacity:", dispelSettings, "borderAlpha", 0.1, 1.0, 0.05, true, function()
                    -- Invalidate curve cache
                    local DispelOverlay = TweaksUI.DispelOverlay
                    if DispelOverlay and DispelOverlay.InvalidateCurves then
                        DispelOverlay:InvalidateCurves()
                    end
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Glow Effect")
                CreateCheckbox("Show Glow", dispelSettings, "showGlow", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Glow Size:", dispelSettings, "glowSize", 1, 10, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Glow Opacity:", dispelSettings, "glowAlpha", 0.1, 1.0, 0.05, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Animation")
                CreateCheckbox("Pulse Animation", dispelSettings, "showPulse", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Special Debuff Types")
                CreateCheckbox("Show Bleed Effects", dispelSettings, "showBleed", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Enrage Effects", dispelSettings, "showEnrage", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
            end
            
            -- THREAT OVERLAY SECTION (for party and raid frames)
            if isParty or isRaid then
                CreateHeader("Threat Overlay (Aggro Highlight)")
                
                -- Ensure threatOverlay settings exist
                if not visualSettings.threatOverlay then
                    visualSettings.threatOverlay = {
                        enabled = false,
                        showBorder = true,
                        borderSize = 2,
                        borderAlpha = 0.9,
                        showGlow = true,
                        glowSize = 4,
                        glowAlpha = 0.3,
                        showPulse = true,
                        onlyTanking = false,
                    }
                end
                local threatSettings = visualSettings.threatOverlay
                
                local threatDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                threatDesc:SetPoint("TOPLEFT", 5, yOffset)
                threatDesc:SetWidth(PANEL_WIDTH - 60)
                threatDesc:SetText("Shows a red border/glow when a unit has threat or aggro on any enemy.")
                threatDesc:SetTextColor(0.7, 0.7, 0.7)
                threatDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 28
                
                CreateCheckbox("Enable Threat Overlay", threatSettings, "enabled", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Only Show When Tanking", threatSettings, "onlyTanking", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Border")
                CreateCheckbox("Show Border", threatSettings, "showBorder", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Border Size:", threatSettings, "borderSize", 1, 6, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Border Opacity:", threatSettings, "borderAlpha", 0.1, 1.0, 0.05, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Glow Effect")
                CreateCheckbox("Show Glow", threatSettings, "showGlow", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Glow Size:", threatSettings, "glowSize", 1, 10, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Glow Opacity:", threatSettings, "glowAlpha", 0.1, 1.0, 0.05, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Animation")
                CreateCheckbox("Pulse Animation", threatSettings, "showPulse", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
            end
            
            -- BUFF/DEBUFF AURA ICONS SECTION (for party and raid frames)
            if isParty or isRaid then
                CreateHeader("Buff Display (Aura Icons)")
                
                -- Ensure buffs settings exist
                if not visualSettings.buffs then
                    visualSettings.buffs = {
                        enabled = false,
                        maxAuras = 4,
                        size = 16,
                        spacing = 2,
                        growDirection = "RIGHT",
                        anchor = "BOTTOMLEFT",
                        frameAnchor = "TOPLEFT",
                        offsetX = 0,
                        offsetY = 2,
                        filter = "HELPFUL|PLAYER",
                        hidePermanent = true,
                        showDuration = true,
                        showDurationText = false,
                        showStacks = true,
                        showBorder = true,
                        durationFontSize = 10,
                        stackFontSize = 10,
                        sweepAlpha = 1.0,
                        durationColor = { 1, 1, 0.6, 1 },
                    }
                end
                local buffSettings = visualSettings.buffs
                
                local buffDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                buffDesc:SetPoint("TOPLEFT", 5, yOffset)
                buffDesc:SetWidth(PANEL_WIDTH - 60)
                buffDesc:SetText("Shows buff icons on frames. Useful for tracking HoTs and other beneficial effects you cast.")
                buffDesc:SetTextColor(0.7, 0.7, 0.7)
                buffDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 28
                
                CreateCheckbox("Enable Buff Icons", buffSettings, "enabled", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Only Show My Buffs", buffSettings, "onlyPlayerCast", function()
                    -- Toggle between HELPFUL and HELPFUL|PLAYER
                    if buffSettings.onlyPlayerCast then
                        buffSettings.filter = "HELPFUL|PLAYER"
                    else
                        buffSettings.filter = "HELPFUL"
                    end
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                -- Sync onlyPlayerCast with filter
                buffSettings.onlyPlayerCast = buffSettings.filter and buffSettings.filter:find("PLAYER") ~= nil
                
                CreateCheckbox("Hide Permanent Buffs", buffSettings, "hidePermanent", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Sort By:", AURA_SORT_RULES, buffSettings, "sortRule", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, buffSettings, "sortDirection", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Max Icons:", buffSettings, "maxAuras", 1, 8, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Icon Size:", buffSettings, "size", 10, 120, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Spacing:", buffSettings, "spacing", 0, 8, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Grow Direction:", GROW_DIRECTIONS, buffSettings, "growDirection", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, buffSettings, "anchor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, buffSettings, "frameAnchor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Offset X:", buffSettings, "offsetX", -50, 50, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Offset Y:", buffSettings, "offsetY", -50, 50, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Cooldown Sweep", buffSettings, "showDuration", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Duration Text", buffSettings, "showDurationText", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateFontDropdown("Duration Font:", buffSettings, "durationFont", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Font Outline:", FONT_OUTLINES, buffSettings, "durationOutline", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Duration Font Size:", buffSettings, "durationFontSize", 6, 36, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Duration Offset X:", buffSettings, "durationOffsetX", -20, 20, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Duration Offset Y:", buffSettings, "durationOffsetY", -20, 20, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Sweep Alpha:", buffSettings, "sweepAlpha", 0, 1, 0.1, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateColorPicker("Duration Color:", buffSettings, "durationColor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Stack Count", buffSettings, "showStacks", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Stack Font Size:", buffSettings, "stackFontSize", 6, 16, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                -- DEBUFF ICONS SECTION
                CreateHeader("Debuff Display (Aura Icons)")
                
                -- Ensure debuffs settings exist
                if not visualSettings.debuffs then
                    visualSettings.debuffs = {
                        enabled = false,
                        maxAuras = 4,
                        size = 18,
                        spacing = 2,
                        growDirection = "RIGHT",
                        anchor = "TOPLEFT",
                        frameAnchor = "BOTTOMLEFT",
                        offsetX = 0,
                        offsetY = -2,
                        filter = "HARMFUL",
                        hidePermanent = true,
                        showDuration = true,
                        showDurationText = false,
                        showStacks = true,
                        showBorder = true,
                        colorByDispelType = true,
                        durationFontSize = 10,
                        stackFontSize = 10,
                        sweepAlpha = 1.0,
                        durationColor = { 1, 1, 0.6, 1 },
                    }
                end
                local debuffIconSettings = visualSettings.debuffs
                
                local debuffIconDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                debuffIconDesc:SetPoint("TOPLEFT", 5, yOffset)
                debuffIconDesc:SetWidth(PANEL_WIDTH - 60)
                debuffIconDesc:SetText("Shows debuff icons on frames. Different from Debuff Indicators (small squares) - these show actual spell icons with duration.")
                debuffIconDesc:SetTextColor(0.7, 0.7, 0.7)
                debuffIconDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 28
                
                CreateCheckbox("Enable Debuff Icons", debuffIconSettings, "enabled", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Hide Permanent Debuffs", debuffIconSettings, "hidePermanent", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Sort By:", AURA_SORT_RULES, debuffIconSettings, "sortRule", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, debuffIconSettings, "sortDirection", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Max Icons:", debuffIconSettings, "maxAuras", 1, 8, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Icon Size:", debuffIconSettings, "size", 10, 120, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Spacing:", debuffIconSettings, "spacing", 0, 8, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Grow Direction:", GROW_DIRECTIONS, debuffIconSettings, "growDirection", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, debuffIconSettings, "anchor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, debuffIconSettings, "frameAnchor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Offset X:", debuffIconSettings, "offsetX", -50, 50, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Offset Y:", debuffIconSettings, "offsetY", -50, 50, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Cooldown Sweep", debuffIconSettings, "showDuration", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Duration Text", debuffIconSettings, "showDurationText", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateFontDropdown("Duration Font:", debuffIconSettings, "durationFont", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Font Outline:", FONT_OUTLINES, debuffIconSettings, "durationOutline", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Duration Font Size:", debuffIconSettings, "durationFontSize", 6, 36, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Duration Offset X:", debuffIconSettings, "durationOffsetX", -20, 20, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Duration Offset Y:", debuffIconSettings, "durationOffsetY", -20, 20, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Sweep Alpha:", debuffIconSettings, "sweepAlpha", 0, 1, 0.1, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateColorPicker("Duration Color:", debuffIconSettings, "durationColor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Stack Count", debuffIconSettings, "showStacks", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Stack Font Size:", debuffIconSettings, "stackFontSize", 6, 16, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Color Border by Dispel Type", debuffIconSettings, "colorByDispelType", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
            end
            
            -- Range Check Settings (party frames only)
            if visualSettings.debuffIndicators then
                if unit and unit:match("^party") and settings.party and settings.party.rangeCheck then
                    CreateHeader("Range Indication")
                    
                    local rc = settings.party.rangeCheck
                    
                    -- Enable checkbox
                    local enableRangeCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
                    enableRangeCB:SetPoint("TOPLEFT", 5, yOffset)
                    enableRangeCB.Text:SetText("Fade out-of-range units")
                    enableRangeCB:SetChecked(rc.enabled or false)
                    enableRangeCB:SetScript("OnClick", function(self)
                        rc.enabled = self:GetChecked() and true or false
                        UnitFrames:SaveSettings()
                        UnitFrames:SaveSettings()
                        if rc.enabled then
                            InitRangeChecker()
                        else
                            StopRangeChecker()
                        end
                    end)
                    yOffset = yOffset - 28
                    
                    -- Out of range alpha slider
                    local alphaLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    alphaLabel:SetPoint("TOPLEFT", 5, yOffset)
                    alphaLabel:SetText("Out of Range Alpha:")
                    yOffset = yOffset - 16
                    
                    local alphaSlider = CreateFrame("Slider", nil, content, "OptionsSliderTemplate")
                    alphaSlider:SetPoint("TOPLEFT", 10, yOffset)
                    alphaSlider:SetWidth(180)
                    alphaSlider:SetMinMaxValues(0, 1)
                    alphaSlider:SetValueStep(0.05)
                    alphaSlider:SetObeyStepOnDrag(true)
                    alphaSlider:SetValue(rc.outOfRangeAlpha or 0.4)
                    alphaSlider.Low:SetText("0%")
                    alphaSlider.High:SetText("100%")
                    alphaSlider.Text:SetText(string.format("%.0f%%", (rc.outOfRangeAlpha or 0.4) * 100))
                    alphaSlider:SetScript("OnValueChanged", function(self, value)
                        rc.outOfRangeAlpha = value
                        UnitFrames:SaveSettings()
                        self.Text:SetText(string.format("%.0f%%", value * 100))
                    end)
                    yOffset = yOffset - 35
                    
                    -- Smooth fade checkbox
                    local smoothCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
                    smoothCB:SetPoint("TOPLEFT", 5, yOffset)
                    smoothCB.Text:SetText("Smooth fade transition")
                    smoothCB:SetChecked(rc.useSmoothFade or false)
                    smoothCB:SetScript("OnClick", function(self)
                        rc.useSmoothFade = self:GetChecked() and true or false
                        UnitFrames:SaveSettings()
                        UnitFrames:SaveSettings()
                    end)
                    yOffset = yOffset - 28
                end
                
                -- Range Check Settings (tank frames)
                if unit and unit == "tanks" and settings.tanks and settings.tanks.rangeCheck then
                    CreateHeader("Range Indication")
                    
                    local rc = settings.tanks.rangeCheck
                    
                    -- Enable checkbox
                    local enableRangeCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
                    enableRangeCB:SetPoint("TOPLEFT", 5, yOffset)
                    enableRangeCB.Text:SetText("Fade out-of-range units")
                    enableRangeCB:SetChecked(rc.enabled or false)
                    enableRangeCB:SetScript("OnClick", function(self)
                        rc.enabled = self:GetChecked() and true or false
                        UnitFrames:SaveSettings()
                        UnitFrames:SaveSettings()
                        if rc.enabled then
                            InitRangeChecker()
                        else
                            StopRangeChecker()
                        end
                    end)
                    yOffset = yOffset - 28
                    
                    -- Out of range alpha slider
                    local alphaLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    alphaLabel:SetPoint("TOPLEFT", 5, yOffset)
                    alphaLabel:SetText("Out of Range Alpha:")
                    yOffset = yOffset - 16
                    
                    local alphaSlider = CreateFrame("Slider", nil, content, "OptionsSliderTemplate")
                    alphaSlider:SetPoint("TOPLEFT", 10, yOffset)
                    alphaSlider:SetWidth(180)
                    alphaSlider:SetMinMaxValues(0, 1)
                    alphaSlider:SetValueStep(0.05)
                    alphaSlider:SetObeyStepOnDrag(true)
                    alphaSlider:SetValue(rc.outOfRangeAlpha or 0.4)
                    alphaSlider.Low:SetText("0%")
                    alphaSlider.High:SetText("100%")
                    alphaSlider.Text:SetText(string.format("%.0f%%", (rc.outOfRangeAlpha or 0.4) * 100))
                    alphaSlider:SetScript("OnValueChanged", function(self, value)
                        rc.outOfRangeAlpha = value
                        UnitFrames:SaveSettings()
                        self.Text:SetText(string.format("%.0f%%", value * 100))
                    end)
                    yOffset = yOffset - 35
                    
                    -- Smooth fade checkbox
                    local smoothCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
                    smoothCB:SetPoint("TOPLEFT", 5, yOffset)
                    smoothCB.Text:SetText("Smooth fade transition")
                    smoothCB:SetChecked(rc.useSmoothFade or false)
                    smoothCB:SetScript("OnClick", function(self)
                        rc.useSmoothFade = self:GetChecked() and true or false
                        UnitFrames:SaveSettings()
                        UnitFrames:SaveSettings()
                    end)
                    yOffset = yOffset - 28
                end
            else
                local label = content:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
                label:SetPoint("TOPLEFT", 5, yOffset)
                label:SetText("|cff888888Debuff indicators not available for this frame type.|r")
                yOffset = yOffset - 20
            end
            
            -- ================================================================
            -- AURA DISPLAY (Phase 3) - Full buff/debuff icons for TANK/BOSS ONLY
            -- Individual frames use "Buff Icons"/"Debuff Icons" sections above
            -- ================================================================
            if isTanks or isBoss then
                -- Buffs section
                if visualSettings.buffs then
                    CreateHeader("Buffs Display")
                CreateCheckbox("Enable Buffs", visualSettings.buffs, "enabled")
                CreateSlider("Max Buffs:", visualSettings.buffs, "maxAuras", 1, 16, 1)
                CreateSlider("Icon Size:", visualSettings.buffs, "size", 12, 120, 1)
                CreateSlider("Spacing:", visualSettings.buffs, "spacing", 0, 8, 1)
                CreateSlider("Wrap After:", visualSettings.buffs, "wrapAfter", 1, 8, 1)
                
                CreateDropdown("Grow Direction:", GROW_DIRECTIONS, visualSettings.buffs, "growDirection")
                CreateDropdown("Wrap Direction:", GROW_DIRECTIONS, visualSettings.buffs, "wrapDirection")
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, visualSettings.buffs, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.buffs, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.buffs, "offsetX", -100, 100, 1)
                CreateSlider("Offset Y:", visualSettings.buffs, "offsetY", -100, 100, 1)
                
                local BUFF_FILTERS = {
                    { id = "HELPFUL", name = "All Buffs" },
                    { id = "HELPFUL|PLAYER", name = "My Buffs Only" },
                    { id = "HELPFUL|RAID", name = "Raid Buffs" },
                }
                CreateDropdown("Filter:", BUFF_FILTERS, visualSettings.buffs, "filter")
                CreateCheckbox("Hide Permanent Buffs", visualSettings.buffs, "hidePermanent")
                CreateNote("(Best with 'By Time Remaining' sort)")
                
                -- Sorting options (Midnight Beta 4+)
                if HAS_AURA_SORTING then
                    local SORT_RULES = {
                        { id = "Default", name = "Default" },
                        { id = "Expiration", name = "By Time Remaining" },
                        { id = "Name", name = "By Name" },
                        { id = "BigDefensive", name = "Big Defensives First" },
                    }
                    CreateDropdown("Sort By:", SORT_RULES, visualSettings.buffs, "sortRule")
                    
                    local SORT_DIRS = {
                        { id = "Normal", name = "Normal" },
                        { id = "Reverse", name = "Reverse" },
                    }
                    CreateDropdown("Sort Direction:", SORT_DIRS, visualSettings.buffs, "sortDirection")
                end
                
                CreateCheckbox("Show Duration Spiral", visualSettings.buffs, "showDuration")
                CreateCheckbox("Show Duration Text", visualSettings.buffs, "showDurationText")
                CreateFontDropdown("Duration Font:", visualSettings.buffs, "durationFont")
                CreateDropdown("Font Outline:", FONT_OUTLINES, visualSettings.buffs, "durationOutline")
                CreateSlider("Duration Font Size:", visualSettings.buffs, "durationFontSize", 6, 36, 1)
                CreateCheckbox("Show Stack Counts", visualSettings.buffs, "showStacks")
                CreateSlider("Stack Font Size:", visualSettings.buffs, "stackFontSize", 6, 16, 1)
                CreateCheckbox("Show Border", visualSettings.buffs, "showBorder")
                CreateColorPicker("Border Color:", visualSettings.buffs, "borderColor")
            end
            
            -- Debuffs section
            if visualSettings.debuffs then
                CreateHeader("Debuffs Display")
                CreateCheckbox("Enable Debuffs", visualSettings.debuffs, "enabled")
                CreateSlider("Max Debuffs:", visualSettings.debuffs, "maxAuras", 1, 16, 1)
                CreateSlider("Icon Size:", visualSettings.debuffs, "size", 12, 120, 1)
                CreateSlider("Spacing:", visualSettings.debuffs, "spacing", 0, 8, 1)
                CreateSlider("Wrap After:", visualSettings.debuffs, "wrapAfter", 1, 8, 1)
                
                CreateDropdown("Grow Direction:", GROW_DIRECTIONS, visualSettings.debuffs, "growDirection")
                CreateDropdown("Wrap Direction:", GROW_DIRECTIONS, visualSettings.debuffs, "wrapDirection")
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, visualSettings.debuffs, "anchor")
                CreateDropdown("Frame Anchor:", ANCHOR_POINTS, visualSettings.debuffs, "frameAnchor")
                CreateSlider("Offset X:", visualSettings.debuffs, "offsetX", -100, 100, 1)
                CreateSlider("Offset Y:", visualSettings.debuffs, "offsetY", -100, 100, 1)
                
                local DEBUFF_FILTERS = {
                    { id = "HARMFUL", name = "All Debuffs" },
                    { id = "HARMFUL|PLAYER", name = "My Debuffs Only" },
                    { id = "HARMFUL|RAID", name = "Raid Debuffs" },
                }
                CreateDropdown("Filter:", DEBUFF_FILTERS, visualSettings.debuffs, "filter")
                CreateCheckbox("Hide Permanent Debuffs", visualSettings.debuffs, "hidePermanent")
                CreateNote("(Best with 'By Time Remaining' sort)")
                
                -- Sorting options (Midnight Beta 4+)
                if HAS_AURA_SORTING then
                    local SORT_RULES = {
                        { id = "Default", name = "Default" },
                        { id = "Expiration", name = "By Time Remaining" },
                        { id = "Name", name = "By Name" },
                        { id = "BigDefensive", name = "Big Defensives First" },
                    }
                    CreateDropdown("Sort By:", SORT_RULES, visualSettings.debuffs, "sortRule")
                    
                    local SORT_DIRS = {
                        { id = "Normal", name = "Normal" },
                        { id = "Reverse", name = "Reverse" },
                    }
                    CreateDropdown("Sort Direction:", SORT_DIRS, visualSettings.debuffs, "sortDirection")
                end
                
                CreateCheckbox("Show Duration Spiral", visualSettings.debuffs, "showDuration")
                CreateCheckbox("Show Duration Text", visualSettings.debuffs, "showDurationText")
                CreateFontDropdown("Duration Font:", visualSettings.debuffs, "durationFont")
                CreateDropdown("Font Outline:", FONT_OUTLINES, visualSettings.debuffs, "durationOutline")
                CreateSlider("Duration Font Size:", visualSettings.debuffs, "durationFontSize", 6, 36, 1)
                CreateCheckbox("Show Stack Counts", visualSettings.debuffs, "showStacks")
                CreateSlider("Stack Font Size:", visualSettings.debuffs, "stackFontSize", 6, 16, 1)
                CreateCheckbox("Show Border", visualSettings.debuffs, "showBorder")
                CreateColorPicker("Border Color:", visualSettings.debuffs, "borderColor")
                
                -- Dispel type coloring
                CreateCheckbox("Color by Dispel Type", visualSettings.debuffs, "colorByDispelType")
                CreateCheckbox("Dispel Color on Border Only", visualSettings.debuffs, "dispelBorderOnly")
                
                -- Midnight API note
                if HAS_DISPEL_COLOR_API then
                    local apiNote = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    apiNote:SetPoint("TOPLEFT", 20, yOffset)
                    apiNote:SetWidth(PANEL_WIDTH - 80)
                    apiNote:SetText("|cff00ff00Using Midnight color curves for dispel colors.|r")
                    apiNote:SetJustifyH("LEFT")
                    yOffset = yOffset - 20
                end
            end
            end -- end isTanks or isBoss aura display section
            
            -- DEFENSIVE ICONS SECTION (for party and raid frames)
            if isParty or isRaid then
                CreateHeader("Defensive Icons")
                
                -- Ensure defensiveIcon settings exist
                if not visualSettings.defensiveIcon then
                    visualSettings.defensiveIcon = {
                        enabled = true,
                        size = 28,
                        scale = 1.0,
                        anchor = "CENTER",
                        offsetX = 0,
                        offsetY = 0,
                        showBorder = true,
                        borderSize = 2,
                        borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
                        showCooldown = true,
                        showSwipe = true,
                        showDuration = true,
        showDurationText = false,
                    }
                end
                local defSettings = visualSettings.defensiveIcon
                
                local defDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                defDesc:SetPoint("TOPLEFT", 5, yOffset)
                defDesc:SetWidth(PANEL_WIDTH - 60)
                defDesc:SetText("Shows a prominent icon when a unit has a major defensive cooldown active (Pain Suppression, Shield Wall, Ironbark, etc.)")
                defDesc:SetTextColor(0.7, 0.7, 0.7)
                defDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 30
                
                CreateCheckbox("Enable Defensive Icons", defSettings, "enabled", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Icon Size:", defSettings, "size", 16, 48, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Scale:", defSettings, "scale", 0.5, 2.0, 0.1, true, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateDropdown("Anchor:", ANCHOR_POINTS, defSettings, "anchor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Offset X:", defSettings, "offsetX", -50, 50, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Offset Y:", defSettings, "offsetY", -50, 50, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateHeader("Border & Cooldown")
                CreateCheckbox("Show Border", defSettings, "showBorder", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateSlider("Border Size:", defSettings, "borderSize", 1, 6, 1, false, function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateColorPicker("Border Color:", defSettings, "borderColor", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Cooldown Spiral", defSettings, "showSwipe", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Duration Text", defSettings, "showDuration", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
                
                CreateCheckbox("Show Countdown Numbers", defSettings, "showDurationText", function()
                    if isParty then
                        module:UpdatePartyFrames()
                    elseif isRaid then
                        module:UpdateRaidFrames()
                    end
                end)
            end
        
        -- ====================================================================
        -- BUFFS TAB (party/raid only) - Buff aura icons
        -- ====================================================================
        elseif categoryId == "buffs" then
            CreateHeader("Buff Display (Aura Icons)")
            
            -- Ensure buffs settings exist
            if not visualSettings.buffs then
                visualSettings.buffs = {
                    enabled = false,
                    maxAuras = 4,
                    size = 16,
                    spacing = 2,
                    growDirection = "RIGHT",
                    anchor = "BOTTOMLEFT",
                    frameAnchor = "TOPLEFT",
                    offsetX = 0,
                    offsetY = 2,
                    filter = "HELPFUL|PLAYER",
                    hidePermanent = true,
                    showDuration = true,
                    showDurationText = false,
                    showStacks = true,
                    showBorder = true,
                    durationFontSize = 10,
                    stackFontSize = 10,
                    sweepAlpha = 1.0,
                    durationColor = { 1, 1, 0.6, 1 },
                }
            end
            local buffSettings = visualSettings.buffs
            
            local buffDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            buffDesc:SetPoint("TOPLEFT", 5, yOffset)
            buffDesc:SetWidth(PANEL_WIDTH - 60)
            buffDesc:SetText("Shows buff icons on frames. Useful for tracking HoTs and other beneficial effects you cast on party/raid members.")
            buffDesc:SetTextColor(0.7, 0.7, 0.7)
            buffDesc:SetJustifyH("LEFT")
            yOffset = yOffset - 28
            
            CreateCheckbox("Enable Buff Icons", buffSettings, "enabled", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Only Show My Buffs", buffSettings, "onlyPlayerCast", function()
                if buffSettings.onlyPlayerCast then
                    buffSettings.filter = "HELPFUL|PLAYER"
                else
                    buffSettings.filter = "HELPFUL"
                end
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            buffSettings.onlyPlayerCast = buffSettings.filter and buffSettings.filter:find("PLAYER") ~= nil
            
            CreateCheckbox("Hide Permanent Buffs", buffSettings, "hidePermanent", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Sort By:", AURA_SORT_RULES, buffSettings, "sortRule", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, buffSettings, "sortDirection", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Size & Layout")
            CreateSlider("Max Icons:", buffSettings, "maxAuras", 1, 8, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Icon Size:", buffSettings, "size", 10, 120, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Spacing:", buffSettings, "spacing", 0, 8, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Grow Direction:", GROW_DIRECTIONS, buffSettings, "growDirection", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Position")
            CreateDropdown("Anchor:", ANCHOR_POINTS, buffSettings, "anchor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Frame Anchor:", ANCHOR_POINTS, buffSettings, "frameAnchor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Offset X:", buffSettings, "offsetX", -50, 50, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Offset Y:", buffSettings, "offsetY", -50, 50, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Display Options")
            CreateCheckbox("Show Cooldown Sweep", buffSettings, "showDuration", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Duration Text", buffSettings, "showDurationText", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateFontDropdown("Duration Font:", buffSettings, "durationFont", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Font Outline:", FONT_OUTLINES, buffSettings, "durationOutline", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Duration Font Size:", buffSettings, "durationFontSize", 6, 36, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Duration Offset X:", buffSettings, "durationOffsetX", -20, 20, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Duration Offset Y:", buffSettings, "durationOffsetY", -20, 20, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Sweep Alpha:", buffSettings, "sweepAlpha", 0, 1, 0.1, true, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateColorPicker("Duration Color:", buffSettings, "durationColor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Stack Count", buffSettings, "showStacks", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Stack Font Size:", buffSettings, "stackFontSize", 6, 16, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            -- DEFENSIVE ICONS SECTION (for party and raid frames)
            CreateHeader("Defensive Icons")
            
            -- Ensure defensiveIcon settings exist
            if not visualSettings.defensiveIcon then
                visualSettings.defensiveIcon = {
                    enabled = true,
                    size = 28,
                    scale = 1.0,
                    anchor = "CENTER",
                    offsetX = 0,
                    offsetY = 0,
                    showBorder = true,
                    borderSize = 2,
                    borderColor = { r = 0, g = 0.8, b = 0, a = 1 },
                    showCooldown = true,
                    showSwipe = true,
                    showDuration = true,
        showDurationText = false,
                }
            end
            local defSettings = visualSettings.defensiveIcon
            
            local defDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            defDesc:SetPoint("TOPLEFT", 5, yOffset)
            defDesc:SetWidth(PANEL_WIDTH - 60)
            defDesc:SetText("Shows a prominent icon when a unit has a major defensive cooldown active (Pain Suppression, Shield Wall, Ironbark, etc.)")
            defDesc:SetTextColor(0.7, 0.7, 0.7)
            defDesc:SetJustifyH("LEFT")
            yOffset = yOffset - 30
            
            CreateCheckbox("Enable Defensive Icons", defSettings, "enabled", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Icon Size:", defSettings, "size", 16, 48, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Scale:", defSettings, "scale", 0.5, 2.0, 0.1, true, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Anchor:", ANCHOR_POINTS, defSettings, "anchor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Offset X:", defSettings, "offsetX", -50, 50, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Offset Y:", defSettings, "offsetY", -50, 50, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Border & Cooldown")
            CreateCheckbox("Show Border", defSettings, "showBorder", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Border Size:", defSettings, "borderSize", 1, 6, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateColorPicker("Border Color:", defSettings, "borderColor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Cooldown Spiral", defSettings, "showSwipe", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Duration Text", defSettings, "showDuration", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Countdown Numbers", defSettings, "showDurationText", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
        
        -- ====================================================================
        -- DEBUFFS TAB (party/raid only) - Debuff indicators + aura icons
        -- ====================================================================
        elseif categoryId == "debuffs" then
            -- DEBUFF INDICATORS (colored boxes)
            if visualSettings.debuffIndicators then
                CreateHeader("Debuff Indicators (Colored Boxes)")
                
                local indDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                indDesc:SetPoint("TOPLEFT", 5, yOffset)
                indDesc:SetWidth(PANEL_WIDTH - 60)
                indDesc:SetText("Small colored boxes indicating dispellable debuffs on the unit. Each box represents one debuff, colored by type.")
                indDesc:SetTextColor(0.7, 0.7, 0.7)
                indDesc:SetJustifyH("LEFT")
                yOffset = yOffset - 28
                
                -- Color Legend button
                local legendBtn = CreateFrame("Button", nil, content, "UIPanelButtonTemplate")
                legendBtn:SetPoint("TOPLEFT", 5, yOffset)
                legendBtn:SetSize(120, 22)
                legendBtn:SetText("Show Color Legend")
                legendBtn:SetScript("OnClick", function()
                    module:ShowDispelColorLegend(container)
                end)
                yOffset = yOffset - 28
                
                CreateCheckbox("Enable Debuff Indicators", visualSettings.debuffIndicators, "enabled")
                CreateCheckbox("Only Show Debuffs I Can Dispel", visualSettings.debuffIndicators, "onlyPlayerDispellable", function()
                    module:UpdateTankFrames()
                end)
                
                CreateHeader("Appearance")
                CreateSlider("Size:", visualSettings.debuffIndicators, "size", 8, 32, 1)
                CreateDropdown("Position:", ANCHOR_POINTS, visualSettings.debuffIndicators, "position")
                CreateSlider("Offset X:", visualSettings.debuffIndicators, "offsetX", -50, 50, 1)
                CreateSlider("Offset Y:", visualSettings.debuffIndicators, "offsetY", -50, 50, 1)
            end
            
            -- DEBUFF ICONS (full aura display)
            CreateHeader("Debuff Display (Aura Icons)")
            
            -- Ensure debuffs settings exist
            if not visualSettings.debuffs then
                visualSettings.debuffs = {
                    enabled = false,
                    maxAuras = 4,
                    size = 18,
                    spacing = 2,
                    growDirection = "RIGHT",
                    anchor = "TOPLEFT",
                    frameAnchor = "BOTTOMLEFT",
                    offsetX = 0,
                    offsetY = -2,
                    filter = "HARMFUL",
                    hidePermanent = true,
                    showDuration = true,
                    showDurationText = false,
                    showStacks = true,
                    showBorder = true,
                    colorByDispelType = true,
                    durationFontSize = 10,
                    stackFontSize = 10,
                    sweepAlpha = 1.0,
                    durationColor = { 1, 1, 0.6, 1 },
                }
            end
            local debuffSettings = visualSettings.debuffs
            
            local debuffDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            debuffDesc:SetPoint("TOPLEFT", 5, yOffset)
            debuffDesc:SetWidth(PANEL_WIDTH - 60)
            debuffDesc:SetText("Shows actual debuff icons with spell textures and durations. Different from indicators above.")
            debuffDesc:SetTextColor(0.7, 0.7, 0.7)
            debuffDesc:SetJustifyH("LEFT")
            yOffset = yOffset - 28
            
            CreateCheckbox("Enable Debuff Icons", debuffSettings, "enabled", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Hide Permanent Debuffs", debuffSettings, "hidePermanent", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Sort By:", AURA_SORT_RULES, debuffSettings, "sortRule", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, debuffSettings, "sortDirection", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Size & Layout")
            CreateSlider("Max Icons:", debuffSettings, "maxAuras", 1, 8, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Icon Size:", debuffSettings, "size", 10, 120, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Spacing:", debuffSettings, "spacing", 0, 8, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Grow Direction:", GROW_DIRECTIONS, debuffSettings, "growDirection", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Position")
            CreateDropdown("Anchor:", ANCHOR_POINTS, debuffSettings, "anchor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Frame Anchor:", ANCHOR_POINTS, debuffSettings, "frameAnchor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Offset X:", debuffSettings, "offsetX", -50, 50, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Offset Y:", debuffSettings, "offsetY", -50, 50, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateHeader("Display Options")
            CreateCheckbox("Show Cooldown Sweep", debuffSettings, "showDuration", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Duration Text", debuffSettings, "showDurationText", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateFontDropdown("Duration Font:", debuffSettings, "durationFont", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateDropdown("Font Outline:", FONT_OUTLINES, debuffSettings, "durationOutline", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Duration Font Size:", debuffSettings, "durationFontSize", 6, 36, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Duration Offset X:", debuffSettings, "durationOffsetX", -20, 20, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Duration Offset Y:", debuffSettings, "durationOffsetY", -20, 20, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Sweep Alpha:", debuffSettings, "sweepAlpha", 0, 1, 0.1, true, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateColorPicker("Duration Color:", debuffSettings, "durationColor", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Stack Count", debuffSettings, "showStacks", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Stack Font Size:", debuffSettings, "stackFontSize", 6, 16, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Color Border by Dispel Type", debuffSettings, "colorByDispelType", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
        
        -- ====================================================================
        -- OVERLAYS TAB (party/raid only) - Dispel, Threat, Range
        -- ====================================================================
        elseif categoryId == "overlays" then
            -- DISPEL OVERLAY
            CreateHeader("Dispel Overlay (Frame Highlight)")
            
            if not visualSettings.dispelOverlay then
                visualSettings.dispelOverlay = {
                    enabled = true,
            fillAlpha = 0.5,
                    fillAlpha = 0.5,
                    showBorder = true,
                    borderSize = 2,
                    borderAlpha = 0.9,
                    showGlow = true,
                    glowSize = 3,
                    glowAlpha = 0.25,
                    showPulse = true,
                    onlyPlayerDispellable = false,
                    showBleed = false,
                    showEnrage = false,
                }
            end
            -- Migrate: add fillAlpha if missing
            if visualSettings.dispelOverlay.fillAlpha == nil then
                visualSettings.dispelOverlay.fillAlpha = 0.5
            end
            local dispelSettings = visualSettings.dispelOverlay
            
            local dispelDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            dispelDesc:SetPoint("TOPLEFT", 5, yOffset)
            dispelDesc:SetWidth(PANEL_WIDTH - 60)
            dispelDesc:SetText("Highlights the frame border when a unit has a dispellable debuff.")
            dispelDesc:SetTextColor(0.7, 0.7, 0.7)
            dispelDesc:SetJustifyH("LEFT")
            yOffset = yOffset - 28
            
            CreateCheckbox("Enable Dispel Overlay", dispelSettings, "enabled", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Only Show Debuffs I Can Dispel", dispelSettings, "onlyPlayerDispellable", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Fill Opacity:", dispelSettings, "fillAlpha", 0, 1.0, 0.05, true, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Border", dispelSettings, "showBorder", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Border Size:", dispelSettings, "borderSize", 1, 6, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Glow", dispelSettings, "showGlow", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Glow Size:", dispelSettings, "glowSize", 1, 10, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Pulse Animation", dispelSettings, "showPulse", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Bleed Effects", dispelSettings, "showBleed", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Enrage Effects", dispelSettings, "showEnrage", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            -- THREAT OVERLAY
            CreateHeader("Threat Overlay (Aggro Highlight)")
            
            if not visualSettings.threatOverlay then
                visualSettings.threatOverlay = {
                    enabled = false,
                    showBorder = true,
                    borderSize = 2,
                    borderAlpha = 0.9,
                    showGlow = true,
                    glowSize = 4,
                    glowAlpha = 0.3,
                    showPulse = true,
                    onlyTanking = false,
                }
            end
            local threatSettings = visualSettings.threatOverlay
            
            local threatDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            threatDesc:SetPoint("TOPLEFT", 5, yOffset)
            threatDesc:SetWidth(PANEL_WIDTH - 60)
            threatDesc:SetText("Shows a red border/glow when a unit has threat or aggro.")
            threatDesc:SetTextColor(0.7, 0.7, 0.7)
            threatDesc:SetJustifyH("LEFT")
            yOffset = yOffset - 28
            
            CreateCheckbox("Enable Threat Overlay", threatSettings, "enabled", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Only Show When Tanking", threatSettings, "onlyTanking", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Border", threatSettings, "showBorder", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Border Size:", threatSettings, "borderSize", 1, 6, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Show Glow", threatSettings, "showGlow", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateSlider("Glow Size:", threatSettings, "glowSize", 1, 10, 1, false, function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            CreateCheckbox("Pulse Animation", threatSettings, "showPulse", function()
                if isParty then module:UpdatePartyFrames()
                elseif isRaid then module:UpdateRaidFrames() end
            end)
            
            -- RANGE CHECK
            if isParty and settings.party and settings.party.rangeCheck then
                CreateHeader("Range Indication")
                
                local rc = settings.party.rangeCheck
                
                CreateCheckbox("Fade Out-of-Range Units", rc, "enabled", function()
                    if rc.enabled then
                        InitRangeChecker()
                    else
                        StopRangeChecker()
                    end
                end)
                
                CreateSlider("Out of Range Alpha:", rc, "outOfRangeAlpha", 0, 1, 0.05, true, function()
                    -- Alpha update
                end)
                
                CreateCheckbox("Smooth Fade Transition", rc, "useSmoothFade")
            end
        
        elseif categoryId == "visibility" then
            -- VISIBILITY SETTINGS
            
            -- Ensure visibility settings exist for this frame
            if not visualSettings.visibility then
                visualSettings.visibility = {
                    enabled = false,
                    combat = false,
                    mouseover = false,
                    target = false,
                    group = false,
                    instance = false,
                    instanceTypes = {},
                    fadeAlpha = 0,
                }
            end
            local vis = visualSettings.visibility
            
            -- Description
            local desc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            desc:SetPoint("TOPLEFT", 5, yOffset)
            desc:SetWidth(PANEL_WIDTH - 60)
            desc:SetText("Control when this frame is visible. When enabled, the frame hides until ANY checked condition is met.")
            desc:SetTextColor(0.7, 0.7, 0.7)
            desc:SetJustifyH("LEFT")
            yOffset = yOffset - 40
            
            CreateHeader("Visibility Controls")
            
            -- Enable checkbox
            local enableCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
            enableCB:SetPoint("TOPLEFT", 5, yOffset)
            enableCB.Text:SetText("Enable visibility controls for this frame")
            enableCB:SetChecked(vis.enabled or false)
            enableCB:SetScript("OnClick", function(self)
                vis.enabled = self:GetChecked() and true or false
                UnitFrames:SaveSettings()
                UnitFrames:SaveSettings()
                VisibilityManager:ApplyVisibilityForUnit(unit)
                VisibilityManager:UpdateMouseoverForUnit(unit)
            end)
            yOffset = yOffset - 28
            
            -- Conditions header
            local condLabel = content:CreateFontString(nil, "OVERLAY", "GameFontNormal")
            condLabel:SetPoint("TOPLEFT", 5, yOffset)
            condLabel:SetText("Show this frame when:")
            condLabel:SetTextColor(1, 0.82, 0)
            yOffset = yOffset - 22
            
            -- Combat
            local combatCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
            combatCB:SetPoint("TOPLEFT", 15, yOffset)
            combatCB.Text:SetText("In combat")
            combatCB:SetChecked(vis.combat or false)
            combatCB:SetScript("OnClick", function(self)
                vis.combat = self:GetChecked() and true or false
                UnitFrames:SaveSettings()
                UnitFrames:SaveSettings()
                VisibilityManager:ApplyVisibilityForUnit(unit)
            end)
            yOffset = yOffset - 24
            
            -- Mouseover
            local mouseoverCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
            mouseoverCB:SetPoint("TOPLEFT", 15, yOffset)
            mouseoverCB.Text:SetText("Mouse over this frame")
            mouseoverCB:SetChecked(vis.mouseover or false)
            mouseoverCB:SetScript("OnClick", function(self)
                vis.mouseover = self:GetChecked() and true or false
                UnitFrames:SaveSettings()
                UnitFrames:SaveSettings()
                VisibilityManager:UpdateMouseoverForUnit(unit)
                VisibilityManager:ApplyVisibilityForUnit(unit)
            end)
            yOffset = yOffset - 24
            
            -- Target
            local targetCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
            targetCB:SetPoint("TOPLEFT", 15, yOffset)
            targetCB.Text:SetText("Have a target")
            targetCB:SetChecked(vis.target or false)
            targetCB:SetScript("OnClick", function(self)
                vis.target = self:GetChecked() and true or false
                UnitFrames:SaveSettings()
                UnitFrames:SaveSettings()
                VisibilityManager:ApplyVisibilityForUnit(unit)
            end)
            yOffset = yOffset - 24
            
            -- Group
            local groupCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
            groupCB:SetPoint("TOPLEFT", 15, yOffset)
            groupCB.Text:SetText("In a party or raid")
            groupCB:SetChecked(vis.group or false)
            groupCB:SetScript("OnClick", function(self)
                vis.group = self:GetChecked() and true or false
                UnitFrames:SaveSettings()
                UnitFrames:SaveSettings()
                VisibilityManager:ApplyVisibilityForUnit(unit)
            end)
            yOffset = yOffset - 24
            
            -- Instance
            local instanceCB = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
            instanceCB:SetPoint("TOPLEFT", 15, yOffset)
            instanceCB.Text:SetText("In specific instances:")
            instanceCB:SetChecked(vis.instance or false)
            instanceCB:SetScript("OnClick", function(self)
                vis.instance = self:GetChecked() and true or false
                UnitFrames:SaveSettings()
                UnitFrames:SaveSettings()
                VisibilityManager:ApplyVisibilityForUnit(unit)
            end)
            yOffset = yOffset - 22
            
            -- Instance type sub-options
            local instanceTypes = {
                { id = "party", text = "Dungeons" },
                { id = "raid", text = "Raids" },
                { id = "arena", text = "Arenas" },
                { id = "pvp", text = "Battlegrounds" },
                { id = "scenario", text = "Scenarios" },
            }
            
            vis.instanceTypes = vis.instanceTypes or {}
            for _, inst in ipairs(instanceTypes) do
                local cb = CreateFrame("CheckButton", nil, content, "ChatConfigCheckButtonTemplate")
                cb:SetPoint("TOPLEFT", 35, yOffset)
                cb.Text:SetText(inst.text)
                cb.Text:SetFontObject("GameFontNormalSmall")
                cb:SetChecked(vis.instanceTypes[inst.id] or false)
                cb:SetScript("OnClick", function(self)
                    vis.instanceTypes[inst.id] = self:GetChecked() and true or false
                    UnitFrames:SaveSettings()
                    UnitFrames:SaveSettings()
                    VisibilityManager:ApplyVisibilityForUnit(unit)
                end)
                yOffset = yOffset - 20
            end
            yOffset = yOffset - 15
            
            -- Fade alpha section
            CreateHeader("Hidden Opacity")
            
            local fadeDesc = content:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            fadeDesc:SetPoint("TOPLEFT", 5, yOffset)
            fadeDesc:SetWidth(PANEL_WIDTH - 60)
            fadeDesc:SetText("When conditions are not met, fade to this opacity (0 = invisible)")
            fadeDesc:SetTextColor(0.6, 0.6, 0.6)
            yOffset = yOffset - 22
            
            local fadeLabel = content:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
            fadeLabel:SetPoint("TOPLEFT", 5, yOffset)
            fadeLabel:SetText(string.format("Opacity: %d%%", vis.fadeAlpha or 0))
            yOffset = yOffset - 22
            
            local fadeSlider = CreateFrame("Slider", nil, content, "OptionsSliderTemplate")
            fadeSlider:SetPoint("TOPLEFT", 5, yOffset)
            fadeSlider:SetMinMaxValues(0, 100)
            fadeSlider:SetValueStep(5)
            fadeSlider:SetObeyStepOnDrag(true)
            fadeSlider:SetWidth(200)
            fadeSlider.Low:SetText("0%")
            fadeSlider.High:SetText("100%")
            
            local initSlider = true
            fadeSlider:SetScript("OnValueChanged", function(self, value)
                if initSlider then return end
                fadeLabel:SetText(string.format("Opacity: %d%%", value))
                vis.fadeAlpha = value
                UnitFrames:SaveSettings()
                VisibilityManager:ApplyVisibilityForUnit(unit)
            end)
            fadeSlider:SetValue(vis.fadeAlpha or 0)
            initSlider = false
            yOffset = yOffset - 45
        end
    end
    
    -- ========================================================================
    -- CREATE TAB BUTTONS AND CONTENT
    -- ========================================================================
    
    -- Tab container
    local tabContainer = CreateFrame("Frame", nil, container)
    tabContainer:SetPoint("TOPLEFT", 5, -32)
    tabContainer:SetPoint("TOPRIGHT", -5, -32)
    tabContainer:SetHeight(24)
    
    local currentTabIndex = 1
    
    local function ShowTab(categoryId)
        -- Hide all content frames
        for id, contentFrame in pairs(categoryPanels) do
            contentFrame:Hide()
        end
        -- Update tab button appearance
        for i, btn in ipairs(tabButtons) do
            if btn.categoryId == categoryId then
                btn.bg:SetColorTexture(0.25, 0.25, 0.4, 1)
                btn.text:SetTextColor(1, 1, 1)
                currentTabIndex = i
            else
                btn.bg:SetColorTexture(0.15, 0.15, 0.15, 0.9)
                btn.text:SetTextColor(0.7, 0.7, 0.7)
            end
        end
        -- Show selected content
        if categoryPanels[categoryId] then
            categoryPanels[categoryId]:Show()
            activeCategory = categoryId
        end
        -- Update copy dropdown for this category
        UpdateCopyDropdown(categoryId)
    end
    
    local tabWidth = (PANEL_WIDTH - 14) / #categories
    
    for i, cat in ipairs(categories) do
        -- Create tab button
        local tabBtn = CreateFrame("Button", nil, tabContainer)
        tabBtn:SetSize(tabWidth - 1, 22)
        tabBtn:SetPoint("LEFT", (i - 1) * tabWidth, 0)
        
        tabBtn.bg = tabBtn:CreateTexture(nil, "BACKGROUND")
        tabBtn.bg:SetAllPoints()
        tabBtn.bg:SetColorTexture(0.15, 0.15, 0.15, 0.9)
        
        tabBtn.text = tabBtn:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        tabBtn.text:SetPoint("CENTER")
        tabBtn.text:SetText(cat.name)
        tabBtn.text:SetTextColor(0.7, 0.7, 0.7)
        
        tabBtn.categoryId = cat.id
        
        tabBtn:SetScript("OnClick", function()
            ShowTab(cat.id)
        end)
        
        tabBtn:SetScript("OnEnter", function(self)
            if activeCategory ~= cat.id then
                self.bg:SetColorTexture(0.2, 0.2, 0.3, 0.95)
            end
        end)
        
        tabBtn:SetScript("OnLeave", function(self)
            if activeCategory ~= cat.id then
                self.bg:SetColorTexture(0.15, 0.15, 0.15, 0.9)
            end
        end)
        
        tabButtons[i] = tabBtn
        
        -- Create the content frame for this tab
        local contentFrame = CreateCategoryContent(cat.id)
        BuildCategoryUI(contentFrame, cat.id)
        categoryPanels[cat.id] = contentFrame
    end
    
    -- Show first tab by default (container for party/raid, frame for others)
    ShowTab(isGroupFrame and "container" or "frame")
    
    container:Hide()
    settingsPanels[unit] = container
end

-- ============================================================================
-- GENERAL SETTINGS PANEL
-- ============================================================================

function UnitFrames:CreateGeneralSettingsPanel()
    if settingsPanels["general"] then return end
    
    local container = CreateFrame("Frame", "TweaksUI_UF_GeneralPanel", UIParent, "BackdropTemplate")
    container:SetSize(PANEL_WIDTH, 620)  -- Height for mouseover highlight controls
    container:SetBackdrop(darkBackdrop)
    container:SetBackdropColor(0.08, 0.08, 0.08, 0.95)
    container:SetBackdropBorderColor(0, 0, 0, 1)
    container:SetFrameStrata("DIALOG")
    container:SetMovable(true)
    container:EnableMouse(true)
    container:SetClampedToScreen(true)
    
    -- Position relative to hub
    if unitFramesHub then
        container:SetPoint("TOPLEFT", unitFramesHub, "TOPRIGHT", 0, 0)
    else
        container:SetPoint("CENTER")
    end
    
    -- Title
    local title = container:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
    title:SetPoint("TOP", 0, -12)
    title:SetText("General Settings")
    
    -- Subtitle
    local subtitle = container:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    subtitle:SetPoint("TOP", title, "BOTTOM", 0, -4)
    subtitle:SetText("|cff888888Module-wide options (Midnight Beta 4+)|r")
    
    -- Close button
    local closeBtn = CreateFrame("Button", nil, container, "UIPanelCloseButton")
    closeBtn:SetPoint("TOPRIGHT", -3, -3)
    closeBtn:SetScript("OnClick", function() container:Hide() end)
    
    -- Content area
    local contentFrame = CreateFrame("Frame", nil, container)
    contentFrame:SetPoint("TOPLEFT", 15, -60)
    contentFrame:SetPoint("BOTTOMRIGHT", -15, 15)
    
    local yPos = 0
    local generalSettings = settings.general
    local controlIndex = 0
    
    -- Helper to create checkbox
    local function CreateCheckbox(text, key, callback)
        controlIndex = controlIndex + 1
        local cb = CreateFrame("CheckButton", "TweaksUI_UF_General_CB" .. controlIndex, contentFrame, "UICheckButtonTemplate")
        cb:SetPoint("TOPLEFT", 0, yPos)
        cb.text:SetText(text)
        cb.text:SetFontObject("GameFontHighlight")
        cb:SetChecked(generalSettings[key])
        cb:SetScript("OnClick", function(self)
            generalSettings[key] = self:GetChecked()
            UnitFrames:SaveSettings()
            UnitFrames:SaveSettings()
            if callback then callback() end
        end)
        yPos = yPos - 28
        return cb
    end
    
    -- Helper to create dropdown
    local function CreateDropdown(label, options, key, callback)
        controlIndex = controlIndex + 1
        
        local lbl = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
        lbl:SetPoint("TOPLEFT", 0, yPos)
        lbl:SetText(label)
        yPos = yPos - 18
        
        local dropdownName = "TweaksUI_UF_General_DD" .. controlIndex
        local dropdown = CreateFrame("Frame", dropdownName, contentFrame, "UIDropDownMenuTemplate")
        dropdown:SetPoint("TOPLEFT", -16, yPos)
        UIDropDownMenu_SetWidth(dropdown, 180)
        
        local function UpdateDropdownText()
            local currentValue = generalSettings[key]
            for _, opt in ipairs(options) do
                if opt.id == currentValue then
                    UIDropDownMenu_SetText(dropdown, opt.name)
                    return
                end
            end
            UIDropDownMenu_SetText(dropdown, currentValue or "Select...")
        end
        
        UIDropDownMenu_Initialize(dropdown, function(self, level)
            for _, opt in ipairs(options) do
                local info = UIDropDownMenu_CreateInfo()
                info.text = opt.name
                info.value = opt.id
                info.checked = (generalSettings[key] == opt.id)
                info.func = function()
                    generalSettings[key] = opt.id
                    UIDropDownMenu_SetText(dropdown, opt.name)
                    if callback then callback() end
                end
                UIDropDownMenu_AddButton(info, level)
            end
        end)
        
        UpdateDropdownText()
        yPos = yPos - 32
        return dropdown
    end
    
    -- Section: Global Font
    local fontLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    fontLabel:SetPoint("TOPLEFT", 0, yPos)
    fontLabel:SetText("|cffffd100Text Font|r")
    yPos = yPos - 20
    
    -- Font dropdown
    controlIndex = controlIndex + 1
    local fontDropdownName = "TweaksUI_UF_General_FontDD" .. controlIndex
    local fontDropdown = CreateFrame("Frame", fontDropdownName, contentFrame, "UIDropDownMenuTemplate")
    fontDropdown:SetPoint("TOPLEFT", -16, yPos)
    UIDropDownMenu_SetWidth(fontDropdown, 200)
    UIDropDownMenu_SetText(fontDropdown, generalSettings.font or "Friz Quadrata TT")
    
    UIDropDownMenu_Initialize(fontDropdown, function(self, level)
        local fontList = TweaksUI.Media:GetFontList()
        for _, fontName in ipairs(fontList) do
            local info = UIDropDownMenu_CreateInfo()
            info.text = fontName
            info.checked = (generalSettings.font == fontName)
            info.func = function()
                generalSettings.font = fontName
                UIDropDownMenu_SetText(fontDropdown, fontName)
                -- Refresh all frames to apply new font
                UnitFrames:RefreshAllFrames()
            end
            UIDropDownMenu_AddButton(info, level)
        end
    end)
    yPos = yPos - 35
    
    local fontInfo = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    fontInfo:SetPoint("TOPLEFT", 0, yPos + 8)
    fontInfo:SetText("|cff888888Font used for all unit frame text (names, health, etc.)|r")
    yPos = yPos - 20
    
    -- Section: Bar Animations
    local animLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    animLabel:SetPoint("TOPLEFT", 0, yPos)
    animLabel:SetText("|cffffd100Bar Animations|r")
    yPos = yPos - 20
    
    CreateCheckbox("Enable Smooth Bar Animations", "smoothBars", function()
        -- Settings will take effect on next update
    end)
    
    -- Info text
    local animInfo = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    animInfo:SetPoint("TOPLEFT", 24, yPos + 8)
    animInfo:SetText("|cff888888Health/power bars animate smoothly instead of jumping|r")
    yPos = yPos - 16
    
    -- Section: Aura Display
    local auraLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    auraLabel:SetPoint("TOPLEFT", 0, yPos)
    auraLabel:SetText("|cffffd100Aura Display|r")
    yPos = yPos - 20
    
    CreateDropdown("Sort Rule:", AURA_SORT_RULES, "auraSortRule")
    CreateDropdown("Sort Direction:", AURA_SORT_DIRECTIONS, "auraSortDirection")
    
    -- Section: Debuff Indicators
    local debuffLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    debuffLabel:SetPoint("TOPLEFT", 0, yPos)
    debuffLabel:SetText("|cffffd100Debuff Indicators|r")
    yPos = yPos - 20
    
    CreateCheckbox("Color by Dispel Type", "dispelColors", function()
        -- Refresh all frames to apply new colors
        self:RefreshAllFrames()
    end)
    
    local dispelInfo = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    dispelInfo:SetPoint("TOPLEFT", 24, yPos + 8)
    dispelInfo:SetText("|cff888888Magic=Blue, Curse=Purple, Disease=Brown, Poison=Green|r")
    yPos = yPos - 16
    
    CreateCheckbox("Color Auras by Duration", "auraDurationColors", function()
        -- Settings will take effect on next update
    end)
    
    local durInfo = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    durInfo:SetPoint("TOPLEFT", 24, yPos + 8)
    durInfo:SetText("|cff888888Aura icons change color as they expire (greenred)|r")
    yPos = yPos - 24
    
    -- ================================================================
    -- Section: Mouseover Highlight (Universal)
    -- ================================================================
    local moLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    moLabel:SetPoint("TOPLEFT", 0, yPos)
    moLabel:SetText("|cffffd100Mouseover Highlight|r")
    yPos = yPos - 4
    
    local moNote = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    moNote:SetPoint("TOPLEFT", 0, yPos)
    moNote:SetText("|cff888888(Applies to all unit frames)|r")
    yPos = yPos - 18
    
    -- Ensure mouseoverHighlight settings exist
    if not generalSettings.mouseoverHighlight then
        generalSettings.mouseoverHighlight = {
            enabled = false,
            style = "overlay",
            color = { 1, 1, 1, 0.15 },
            borderThickness = 2,
        }
    end
    local mhs = generalSettings.mouseoverHighlight
    
    -- Enable checkbox
    controlIndex = controlIndex + 1
    local moEnable = CreateFrame("CheckButton", "TweaksUI_UF_General_MOEnable", contentFrame, "UICheckButtonTemplate")
    moEnable:SetPoint("TOPLEFT", 0, yPos)
    moEnable.text:SetText("Enable Mouseover Highlight")
    moEnable.text:SetFontObject("GameFontHighlight")
    moEnable:SetChecked(mhs.enabled)
    moEnable:SetScript("OnClick", function(self)
        mhs.enabled = self:GetChecked()
        UnitFrames:SaveSettings()
        UnitFrames:SaveSettings()
        UnitFrames:RefreshAllFrames()
    end)
    yPos = yPos - 28
    
    -- Style dropdown
    local styleLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    styleLabel:SetPoint("TOPLEFT", 0, yPos)
    styleLabel:SetText("Style:")
    yPos = yPos - 18
    
    local styleOptions = {
        { id = "overlay", name = "Overlay (color fill)" },
        { id = "border", name = "Border (solid line)" },
    }
    
    controlIndex = controlIndex + 1
    local styleDropdownName = "TweaksUI_UF_General_MOStyle"
    local styleDropdown = CreateFrame("Frame", styleDropdownName, contentFrame, "UIDropDownMenuTemplate")
    styleDropdown:SetPoint("TOPLEFT", -16, yPos)
    UIDropDownMenu_SetWidth(styleDropdown, 180)
    
    local function UpdateStyleDropdownText()
        for _, opt in ipairs(styleOptions) do
            if opt.id == mhs.style then
                UIDropDownMenu_SetText(styleDropdown, opt.name)
                return
            end
        end
        UIDropDownMenu_SetText(styleDropdown, "Select...")
    end
    
    UIDropDownMenu_Initialize(styleDropdown, function(self, level)
        for _, opt in ipairs(styleOptions) do
            local info = UIDropDownMenu_CreateInfo()
            info.text = opt.name
            info.value = opt.id
            info.checked = (mhs.style == opt.id)
            info.func = function()
                mhs.style = opt.id
                UIDropDownMenu_SetText(styleDropdown, opt.name)
                UnitFrames:RefreshAllFrames()
            end
            UIDropDownMenu_AddButton(info, level)
        end
    end)
    UpdateStyleDropdownText()
    yPos = yPos - 32
    
    -- Color picker
    local colorLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    colorLabel:SetPoint("TOPLEFT", 0, yPos)
    colorLabel:SetText("Color:")
    
    controlIndex = controlIndex + 1
    local colorSwatch = CreateFrame("Button", "TweaksUI_UF_General_MOColor", contentFrame)
    colorSwatch:SetSize(24, 24)
    colorSwatch:SetPoint("LEFT", colorLabel, "RIGHT", 8, 0)
    
    -- Border (background layer, slightly larger)
    local colorBorder = colorSwatch:CreateTexture(nil, "BACKGROUND")
    colorBorder:SetPoint("TOPLEFT", -2, 2)
    colorBorder:SetPoint("BOTTOMRIGHT", 2, -2)
    colorBorder:SetColorTexture(0, 0, 0, 1)
    
    -- Color texture
    local colorTex = colorSwatch:CreateTexture(nil, "ARTWORK")
    colorTex:SetAllPoints()
    colorTex:SetColorTexture(mhs.color[1], mhs.color[2], mhs.color[3], 1)
    
    colorSwatch:SetScript("OnClick", function()
        local r, g, b, a = unpack(mhs.color)
        
        -- Modern ColorPickerFrame API (Dragonflight+)
        local info = {
            swatchFunc = function()
                local newR, newG, newB = ColorPickerFrame:GetColorRGB()
                mhs.color[1] = newR
                mhs.color[2] = newG
                mhs.color[3] = newB
                colorTex:SetColorTexture(newR, newG, newB, 1)
                UnitFrames:RefreshAllFrames()
            end,
            cancelFunc = function(previousValues)
                if previousValues then
                    mhs.color[1] = previousValues.r
                    mhs.color[2] = previousValues.g
                    mhs.color[3] = previousValues.b
                    colorTex:SetColorTexture(previousValues.r, previousValues.g, previousValues.b, 1)
                    UnitFrames:RefreshAllFrames()
                end
            end,
            r = r,
            g = g,
            b = b,
        }
        ColorPickerFrame:SetupColorPickerAndShow(info)
    end)
    yPos = yPos - 28
    
    -- Opacity slider
    local opacityLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    opacityLabel:SetPoint("TOPLEFT", 0, yPos)
    opacityLabel:SetText("Opacity:")
    yPos = yPos - 18
    
    controlIndex = controlIndex + 1
    local opacitySlider = CreateFrame("Slider", "TweaksUI_UF_General_MOOpacity", contentFrame, "OptionsSliderTemplate")
    opacitySlider:SetPoint("TOPLEFT", 5, yPos)
    opacitySlider:SetWidth(180)
    opacitySlider:SetMinMaxValues(0, 100)
    opacitySlider:SetValueStep(5)
    opacitySlider:SetObeyStepOnDrag(true)
    local currentOpacity = math.floor((mhs.color[4] or 0.15) * 100 + 0.5)
    opacitySlider:SetValue(currentOpacity)
    opacitySlider.Low:SetText("0%")
    opacitySlider.High:SetText("100%")
    opacitySlider.Text:SetText(currentOpacity .. "%")
    opacitySlider:SetScript("OnValueChanged", function(self, value)
        value = math.floor(value + 0.5)
        mhs.color[4] = value / 100
        UnitFrames:SaveSettings()
        self.Text:SetText(value .. "%")
        UnitFrames:RefreshAllFrames()
    end)
    yPos = yPos - 28
    
    -- Border thickness slider (only for border style)
    local thickLabel = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
    thickLabel:SetPoint("TOPLEFT", 0, yPos)
    thickLabel:SetText("Border Thickness:")
    yPos = yPos - 18
    
    controlIndex = controlIndex + 1
    local thickSlider = CreateFrame("Slider", "TweaksUI_UF_General_MOThickness", contentFrame, "OptionsSliderTemplate")
    thickSlider:SetPoint("TOPLEFT", 5, yPos)
    thickSlider:SetWidth(180)
    thickSlider:SetMinMaxValues(1, 5)
    thickSlider:SetValueStep(1)
    thickSlider:SetObeyStepOnDrag(true)
    thickSlider:SetValue(mhs.borderThickness or 2)
    thickSlider.Low:SetText("1")
    thickSlider.High:SetText("5")
    thickSlider.Text:SetText(tostring(mhs.borderThickness or 2))
    thickSlider:SetScript("OnValueChanged", function(self, value)
        value = math.floor(value + 0.5)
        mhs.borderThickness = value
        UnitFrames:SaveSettings()
        self.Text:SetText(tostring(value))
        UnitFrames:RefreshAllFrames()
    end)
    yPos = yPos - 28
    
    local thickNote = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    thickNote:SetPoint("TOPLEFT", 0, yPos + 6)
    thickNote:SetText("|cff888888(Only applies to Border style)|r")
    yPos = yPos - 30
    
    -- Spacer before API note
    yPos = yPos - 10
    
    -- API availability note
    local apiNote = contentFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    apiNote:SetPoint("TOPLEFT", 0, yPos)
    apiNote:SetWidth(PANEL_WIDTH - 30)
    apiNote:SetJustifyH("LEFT")
    
    local apiStatus = {}
    if HAS_MIDNIGHT_APIS then table.insert(apiStatus, "|cff00ff00 Smooth Bars|r") else table.insert(apiStatus, "|cffff0000 Smooth Bars|r") end
    if HAS_AURA_SORTING then table.insert(apiStatus, "|cff00ff00 Aura Sorting|r") else table.insert(apiStatus, "|cffff0000 Aura Sorting|r") end
    if HAS_DISPEL_COLOR_API then table.insert(apiStatus, "|cff00ff00 Dispel Colors|r") else table.insert(apiStatus, "|cffff0000 Dispel Colors|r") end
    if HAS_AURA_DURATION_API then table.insert(apiStatus, "|cff00ff00 Duration Colors|r") else table.insert(apiStatus, "|cffff0000 Duration Colors|r") end
    
    apiNote:SetText("API Support: " .. table.concat(apiStatus, "  "))
    
    container:Hide()
    settingsPanels["general"] = container
end

-- Public method to refresh all visibility (used by /tui showall)
function UnitFrames:RefreshAllVisibility()
    VisibilityManager:ApplyAllVisibility(true)
    VisibilityManager:UpdateAllMouseover()
end

-- Get current settings (always fetches fresh from database reference)
function UnitFrames:GetSettings()
    if not settings then
        settings = TweaksUI.Database:GetModuleSettings(TweaksUI.MODULE_IDS.UNIT_FRAMES) or {}
    end
    return settings
end

-- Save settings to database (call after any settings change)
function UnitFrames:SaveSettings()
    if settings then
        TweaksUI.Database:SetModuleSettings(TweaksUI.MODULE_IDS.UNIT_FRAMES, settings)
    end
end

-- Return module
return UnitFrames
